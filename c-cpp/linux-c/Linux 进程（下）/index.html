<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="https://cwlrin.wiki/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.20"><link rel="modulepreload" href="/js/chunk-7SEFNKBW.js"></link><link rel="modulepreload" href="/js/chunk-B6LR4GZ7.js"></link><link rel="modulepreload" href="/js/chunk-R2ID445Y.js"></link><link rel="modulepreload" href="/js/copy-tex-6KGJ4I7N.js"></link><link rel="modulepreload" href="/js/index.esm-77JWK77F.js"></link><link rel="modulepreload" href="/js/post-NFR2DBU7.js"></link><link rel="modulepreload" href="/js/quicklink-KETDXBC3.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaQWw1YWp5Y014QW9hZExCU0llOHBFQlNfM2I5ZjhQTkVVY3AtZUs1Q1hYLWc_ZT1Ra2p5ejY.png" as="image" fetchpriority="high"><meta name="keywords" content="C,"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="https://cwlrin.wiki/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"><title>Linux 进程（下）</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Linux 进程（下）</h1><div class="meta"><span class="item" title="创建时间：2020-08-31 09:39:25"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-08-31T09:39:25+08:00">2020-08-31</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>38k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>34 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaQWw1YWp5Y014QW9hZExCU0llOHBFQlNfM2I5ZjhQTkVVY3AtZUs1Q1hYLWc_ZT1Ra2p5ejY.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/linux-c/" itemprop="item" rel="index" title="分类于Linux C"><span itemprop="name">Linux C<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwlrin.wiki/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="进程控制"><a class="anchor" href="#进程控制">#</a> 进程控制</h2>
<h3 id="孤儿进程"><a class="anchor" href="#孤儿进程">#</a> 孤儿进程</h3>
<p>在操作系统中，如果父进程在子进程退出之前终止，子进程的状态会发生变化，成为所谓的 “孤儿进程”。在这种情况下，操作系统会将孤儿进程自动分配给 PID 为 1 的特殊进程，即 init 进程，作为其新的父进程。</p>
<p>孤儿进程的处理：</p>
<ul>
<li><strong>收养机制</strong>：操作系统确保所有孤儿进程都有一个父进程。当父进程退出时，操作系统会介入，将孤儿进程的父进程设置为 init 进程（PID 为 1）。</li>
<li><strong>资源清理</strong>：当孤儿进程退出时，它的资源清理工作将由其新的父进程 ——init 进程来完成。这确保了系统资源得到适当的释放和回收。</li>
</ul>
<p>init 进程的角色：<strong>init 进程</strong>：在类 UNIX 系统中，init 进程是第一个启动的进程，其 PID 固定为 1。它负责管理系统中的所有其他进程，包括收养孤儿进程并处理它们的资源清理。</p>
<p>孤儿进程的生命周期：孤儿进程在父进程退出后继续执行，直到它完成自己的任务并退出。在整个生命周期中，孤儿进程由 init 进程代为管理。</p>
<p>当子进程执行完毕后，如果父进程未能及时调用  <code>wait()</code>  或  <code>waitpid()</code>  函数来获取子进程的退出状态并进行清理，子进程将不会立即从系统中消失。相反，它将转变为所谓的 “僵尸进程”（zombie process）。僵尸进程保留了一个进程控制块（PCB），但不再占用其他系统资源。</p>
<h3 id="僵尸进程"><a class="anchor" href="#僵尸进程">#</a> 僵尸进程</h3>
<p>僵尸进程的产生：</p>
<ul>
<li><strong>子进程退出</strong>：子进程执行完毕后，会向其父进程发送  <code>SIGCHLD</code>  信号，通知父进程其已经终止。</li>
<li><strong>父进程的责任</strong>：父进程应当捕捉此信号，并调用  <code>wait()</code>  或  <code>waitpid()</code>  函数来处理子进程的退出状态。如果父进程未能这么做，子进程将变成僵尸进程。</li>
</ul>
<p>僵尸进程的影响：</p>
<ul>
<li><strong>资源占用</strong>：僵尸进程虽然不再执行，但它的 PCB 继续占用内核态空间，这可能导致内核资源的浪费。</li>
<li><strong>系统性能</strong>：如果系统中存在大量的僵尸进程，它们可能会占用过多的内核空间，从而影响系统性能。</li>
</ul>
<p>僵尸进程的处理：</p>
<ul>
<li><strong>父进程的角色</strong>：父进程应当定期检查子进程的状态，并在子进程退出后及时调用  <code>wait()</code>  或  <code>waitpid()</code>  函数进行清理。</li>
<li><strong>系统管理员的职责</strong>：系统管理员应当监控系统中的僵尸进程数量，并采取措施确保父进程能够及时处理这些子进程。</li>
</ul>
<h2 id="守护进程"><a class="anchor" href="#守护进程">#</a> 守护进程</h2>
<h3 id="进程的用户-id-和组-id"><a class="anchor" href="#进程的用户-id-和组-id">#</a> 进程的用户 ID 和组 ID</h3>
<p>在操作系统中，进程在运行时必须与特定的用户身份关联，这使得内核能够实施有效的权限控制。程序在执行时默认继承启动它的用户的身份。</p>
<p>用户身份的继承：例如，如果用户 A 登录系统并启动了一个程序，无论该程序是否由用户 A 创建，程序在运行时将采用用户 A 的身份。这意味着程序的进程将拥有用户 A 的用户 ID（UID）和组 ID（GID），这些分别被称为进程的 <strong>真实用户 ID</strong> 和 <strong>真实组 ID</strong>。</p>
<p>获取用户 ID 和组 ID：进程可以通过调用  <code>getuid()</code>  和  <code>getgid()</code>  函数来获取其 <strong>真实用户 ID</strong> 和 <strong>真实组 ID</strong>。这些函数是 UNIX 和类 UNIX 系统中的标准 API，用于获取当前进程的用户和组身份信息。</p>
<p>以下是一个简单的 C 语言示例，展示如何使用  <code>getuid()</code>  和  <code>getgid()</code>  函数：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">uid_t</span> uid <span class="token operator">=</span> <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取真实用户 ID</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">gid_t</span> gid <span class="token operator">=</span> <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取真实组 ID</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Real User ID: %d\n"</span><span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Real Group ID: %d\n"</span><span class="token punctuation">,</span> gid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个示例中，程序将打印出启动它的用户的真实用户 ID 和真实组 ID。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTYS1URGlSNXBKTGh1TEhZTmxzTHNNQmxibENYWUJTYkR0OUhuVEdGZ0pEaFE_ZT1JMVA4VzY.png" alt="" /></p>
<h3 id="进程的有效用户-id-和组-id"><a class="anchor" href="#进程的有效用户-id-和组-id">#</a> 进程的有效用户 ID 和组 ID</h3>
<p>除了进程的 <strong>真实用户 ID</strong>（Real User ID）和 <strong>真实组 ID</strong>（Real Group ID），操作系统还定义了 <strong>有效用户 ID</strong>（Effective User ID）和 <strong>有效组 ID</strong>（Effective Group ID）的概念。这些附加的身份标识符对权限控制和安全策略至关重要。</p>
<p>系统内核在对进程执行访问权限检查时，依据的是进程的 <strong>有效用户 ID</strong> 和 <strong>有效组 ID</strong>，而不是它们的 <strong>真实用户 ID</strong> 和 <strong>真实组 ID</strong>。这意味着进程的实际权限可能不同于启动它的用户的身份。</p>
<p>在默认情况下，进程的 <strong>有效用户 ID</strong> 通常与其 <strong>真实用户 ID</strong> 相同，<strong>有效组 ID</strong> 也与其 <strong>真实组 ID</strong> 相同。这种设置简化了权限管理，但在需要时，系统允许进行更复杂的权限设置。</p>
<p>进程可以通过调用  <code>geteuid()</code>  和  <code>getegid()</code>  函数来获取其 <strong>有效用户 ID</strong> 和 <strong>有效组 ID</strong>。这些函数提供了对进程当前权限状态的洞察，允许程序根据实际的权限执行相应的操作。</p>
<p><strong> <code>sudo</code>  命令的作用</strong>： <code>sudo</code>  是一种在 UNIX 和类 UNIX 系统中广泛使用的命令行工具，它允许授权的用户以另一个用户的身份，通常是超级用户（root），来执行命令。 <code>sudo</code>  的主要作用之一是通过提升执行命令的有效用户 ID 来临时提升执行权限。这使得普通用户能够执行一些需要更高权限的操作，而无需直接使用 root 账户，从而增强了系统的安全性。</p>
<p><strong>有效组 ID 的修改</strong>：与有效用户 ID 类似，有效组 ID 也可以通过系统调用来修改。然而，这种修改可能会引入安全隐患。如果一个进程的有效组 ID 被更改为具有更高权限的组，那么该进程可能会访问到它原本不应该访问的资源。因此，在修改有效组 ID 时需要格外小心，并确保这种权限提升是出于合法和安全的操作需求。</p>
<h3 id="文件权限"><a class="anchor" href="#文件权限">#</a> 文件权限</h3>
<p>Linux 文件系统提供了一套丰富的权限控制机制，除了基本的读（r）、写（w）、执行（x）权限外，还包含几个特殊的权限位，这些特殊权限位对文件和目录的访问控制提供了额外的灵活性。</p>
<h4 id="setuidset-user-id-upon-execution"><a class="anchor" href="#setuidset-user-id-upon-execution">#</a> SetUID（Set User ID upon execution）</h4>
<p><strong>SetUID</strong> 权限允许一个程序以文件所有者的权限来运行，而不是以执行该程序的用户权限运行。在文件权限的表示中，SetUID 通过在所有者的执行权限位旁添加一个's' 字符来标识。例如，如果一个可执行文件的权限设置为  <code>-rwsr-xr-x</code> ，这意味着无论哪个用户执行该文件，都将以文件所有者的权限来运行，同时该程序的有效用户 ID 也将设置为文件所有者的 ID。</p>
<h4 id="setgidset-group-id-upon-execution"><a class="anchor" href="#setgidset-group-id-upon-execution">#</a> SetGID（Set Group ID upon execution）</h4>
<p><strong>SetGID</strong> 权限与 SetUID 类似，但它应用于文件的组权限。当 SetGID 应用于一个目录时，新创建的文件或目录将继承该目录的组 ID，而不是默认的创建者所属组。在文件权限表示中，SetGID 通过在组的执行权限位旁添加一个's' 字符来标识，例如  <code>-rwxr-sr-x</code> 。</p>
<h4 id="sticky-位"><a class="anchor" href="#sticky-位">#</a> Sticky 位</h4>
<p><strong>Sticky 位</strong> 通常应用于目录，它允许只有文件所有者和超级用户可以删除或重命名目录中的文件。Sticky 位在文件权限表示中通过在其他权限位旁添加一个 't' 字符来标识。</p>
<h4 id="修改文件权限和所有权"><a class="anchor" href="#修改文件权限和所有权">#</a> 修改文件权限和所有权</h4>
<p>使用  <code>chown</code>  命令可以更改文件或目录的所有者和所属组，例如：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">chown</span> root:root 文件</pre></td></tr></table></figure><p>这将把指定文件的所有者和组更改为 root。</p>
<p>使用  <code>chmod</code>  命令可以修改文件或目录的权限，增加 SetUID 权限的示例命令为：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">chmod</span> u+s 文件</pre></td></tr></table></figure><p>这将为指定文件添加 SetUID 权限。</p>
<h3 id="进程组"><a class="anchor" href="#进程组">#</a> 进程组</h3>
<p><strong>进程组</strong> 是操作系统中的一种进程集合机制，它将一个或多个进程组织在一起进行管理。</p>
<p>进程组的定义和特性</p>
<ul>
<li>在操作系统中，每个进程不仅拥有唯一的进程 ID（PID），还属于一个特定的进程组，并拥有一个 <strong>进程组 ID</strong>（process group ID）。</li>
<li>进程组的组长是该组中第一个创建的进程，其 PID 与进程组 ID 相同。</li>
</ul>
<p>进程组的创建和管理</p>
<ul>
<li>当通过 shell 启动一个新进程时，该进程不仅被创建，而且会创建一个新的进程组，并成为该进程组的组长。</li>
<li>在使用  <code>fork()</code>  系统调用创建子进程时，子进程默认继承父进程的进程组 ID，即子进程和父进程处于同一个进程组。</li>
</ul>
<p>进程组的存在条件：一个进程组在至少包含一个进程的情况下才存在。即使该进程不是组长，进程组依然有效。</p>
<p>获取进程组 ID： <code>getpgrp()</code>  函数用于获取调用进程的进程组 ID。</p>
<p>以下是一个简单的 C 语言示例，展示如何使用  <code>getpgrp()</code>  函数：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">pid_t</span> pgrp <span class="token operator">=</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的进程组 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Process Group ID: %d\n"</span><span class="token punctuation">,</span> pgrp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个示例中，程序将打印出当前进程所属的进程组 ID。</p>
<h3 id="终端"><a class="anchor" href="#终端">#</a> 终端</h3>
<p>在 Linux 操作系统中，终端是用户与系统交互的界面，它可以是物理的本地终端，也可以是通过网络连接的远程终端。操作系统启动过程中， <code>init</code>  进程扮演着关键角色，负责初始化系统环境并启动必要的服务。</p>
<p>终端的启动和管理</p>
<ul>
<li>当 Linux 操作系统启动时， <code>init</code>  进程会创建子进程，并使用  <code>exec</code>  函数替换当前进程的映像，以执行  <code>getty</code>  程序。 <code>getty</code>  程序负责管理虚拟控制台，设置终端类型，并打开终端设备。</li>
<li>对于远程登录， <code>getty</code>  程序也会等待来自网络的连接请求。一旦连接建立， <code>getty</code>  程序同样会使用  <code>exec</code>  函数调用  <code>login</code>  程序。</li>
<li><code>login</code>  程序是用户身份验证的关键环节，它要求用户输入用户名和密码，并验证这些凭证以确认用户的身份。</li>
</ul>
<p>进程的创建和替换： <code>exec</code>  系列函数（如  <code>execl</code> ,  <code>execv</code> ,  <code>execle</code> ,  <code>execve</code>  等）用于替换当前进程的映像，启动新的程序。在  <code>init</code>  进程启动  <code>getty</code>  和  <code>login</code>  程序的过程中， <code>exec</code>  函数确保了当前进程资源的高效利用。</p>
<p>用户身份验证：一旦用户成功登录， <code>login</code>  程序将为用户创建一个新的会话，并启动用户的 shell 程序。这个过程涉及到多个系统调用，包括但不限于  <code>fork</code> ,  <code>exec</code> ,  <code>setuid</code> , 和  <code>setgid</code> 。</p>
<h3 id="会话"><a class="anchor" href="#会话">#</a> 会话</h3>
<h4 id="会话特点"><a class="anchor" href="#会话特点">#</a> 会话特点</h4>
<p><strong>会话</strong> 是指用户与操作系统之间进行的一系列交互操作或通信过程。每当用户打开一个新的终端窗口或启动一个新的终端会话时，系统就会创建一个新的会话实例。</p>
<p>会话的定义和特性：会话允许用户完成从登录到注销的整个过程。在这个过程中，用户与系统的所有交互，包括打开文件、运行程序等，都是会话的一部分。</p>
<p>会话与进程组的关系：在一个会话中，可以存在多个进程组。会话本身可以看作是一个或多个进程组的集合。</p>
<p>控制进程的角色：控制终端建立连接的会话首进程被称为 <strong>控制进程</strong>。它负责管理与终端相关的信号和输入输出操作。</p>
<p>前台进程组与后台进程组：一个会话包含 <strong>最多一个前台进程组</strong> 和 <strong>多个后台进程组</strong>。前台进程组接收用户直接输入的信号，而后台进程组则在没有用户直接交互的情况下运行。</p>
<p>信号的发送：当用户从终端输入中断信号时，这些信号会被发送到前台进程组中的所有进程。</p>
<p>终端断开连接的影响：当终端与会话的连接断开时，挂断信号（如 SIGHUP）会被发送给控制进程。控制进程的结束通常会导致会话中的前台进程组和后台进程组也随之结束。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZRTFyRFB1b2g1SG9RaDJEWVhDTGZrQjhQdzlHOTB5aFltdFJDUnRLak9yNUE_ZT10MkVycUY.png" alt="" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0ViRG9hbHEtdjFKR3NTekROQ1Y4NVpVQjR3MjEybElSTHF4UkFtNDQwVmx6aGc_ZT14NFBrMnY.png" alt="" /></p>
<h4 id="会话-id"><a class="anchor" href="#会话-id">#</a> 会话 ID</h4>
<p>在 Linux 操作系统中，每个会话都拥有一个唯一的会话 ID，该 ID 通常与最初创建该会话的进程的进程 ID（PID）相同。会话的概念是作业控制的核心部分，它允许用户和进程进行有效的管理和通信。</p>
<p>会话 ID 的获取与会话的创建：</p>
<ul>
<li><code>getsid()</code>  函数用于获取调用进程所在会话的会话 ID。这个系统调用是检查和管理系统会话的重要工具。</li>
<li><code>setsid()</code>  系统调用用于创建一个新的会话。调用此函数的进程将成为新会话的领导进程，即会话首进程。</li>
</ul>
<p>创建会话的条件：调用  <code>setsid()</code>  的进程不能是任何进程组的组长。这是为了确保新会话的独立性和新会话首进程的控制权。</p>
<p>会话的持续性：一旦创建了新会话，即使创建它的原始 shell 或终端会话被关闭，新会话及其子进程也会继续存在，不会受到影响。</p>
<h3 id="守护进程-2"><a class="anchor" href="#守护进程-2">#</a> 守护进程</h3>
<p><strong>守护进程</strong>（Daemon）是 Linux 操作系统中一种特殊的后台进程，它们用于执行系统或应用程序的特定任务。与需要用户交互的进程不同，守护进程独立于终端运行，通常长时间持续运行，直到系统关闭，而不是与用户会话绑定。守护进程的例子包括日志记录、系统监控、调度任务、邮件服务和服务器程序等。</p>
<p>守护进程的创建流程：</p>
<ol>
<li><strong>创建子进程</strong>：父进程首先创建一个子进程，然后父进程终止。这是为了确保守护进程在系统启动时能够独立于任何用户会话运行。</li>
<li><strong>创建新会话</strong>：子进程使用  <code>setsid()</code>  调用创建一个新的会话，并成为该会话的会话首进程。</li>
<li><strong>更改工作目录</strong>：子进程将当前工作目录更改为根目录（ <code>/</code> ）。这样做是为了防止守护进程对当前目录的依赖，因为如果当前目录所在的文件系统被卸载，守护进程可能会受到影响。</li>
<li><strong>重设文件权限掩码</strong>：子进程通过调用  <code>umask(0)</code>  将文件权限掩码设置为 0，以确保创建的文件具有最大的权限，避免权限受限。</li>
<li><strong>关闭文件描述符</strong>：子进程关闭所有不必要的文件描述符，特别是标准输入（0）、标准输出（1）和标准错误（2）。这通常通过重定向这些描述符到  <code>/dev/null</code>  来实现，从而避免守护进程与终端的交互。</li>
</ol>
<p>以下是一个简化的 C 语言示例，展示如何创建一个守护进程：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 创建子进程并终止父进程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 父进程终止</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 创建新的会话</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsid failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 更改工作目录</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"chdir failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 重设文件权限掩码</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 关闭标准文件描述符</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token function">close</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token function">close</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token function">close</span><span class="token punctuation">(</span>STDERR_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token comment">// 守护进程的代码逻辑</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个示例中，程序展示了守护进程创建的基本步骤，包括创建子进程、创建新会话、更改工作目录、重设文件权限掩码和关闭文件描述符。</p>
<h2 id="linux-shell-指令"><a class="anchor" href="#linux-shell-指令">#</a> Linux shell 指令</h2>
<h3 id="ps-指令"><a class="anchor" href="#ps-指令">#</a>  <code>ps</code>  指令</h3>
<p>在 Linux 系统中， <code>ps</code>  命令是一个强大的工具，用于显示系统中所有进程的信息。虽然  <code>ps</code>  命令提供了多种选项和复杂的功能，但在日常工作中，最常用的两种选项组合是  <code>ps -elf</code>  和  <code>ps aux</code> 。</p>
<h4 id="ps-elfunix-system-v-风格"><a class="anchor" href="#ps-elfunix-system-v-风格">#</a>  <code>ps -elf</code> （UNIX System V 风格）</h4>
<p>这个选项组合以长格式显示所有进程的信息，包括：</p>
<ul>
<li><strong>F</strong>（Flags）：显示进程的标志，这些标志反映了内核处理进程的不同属性。</li>
<li><strong>S</strong>（Status）：显示进程的状态，如运行中（R）、睡眠中（S）、不可中断的睡眠状态（D）、僵尸进程（Z）、停止或被跟踪（T）和空闲进程（I）。</li>
<li><strong>UID</strong>：显示启动进程的用户的用户 ID。</li>
<li><strong>PID</strong>：显示进程的 ID。</li>
<li><strong>PPID</strong>：显示创建当前进程的父进程的 ID。</li>
<li><strong>C</strong>（CPU Usage）：显示进程占用的 CPU 使用率的近似值。</li>
<li><strong>PRI</strong>（Priority）：显示进程的优先级。</li>
<li><strong>NI</strong>（Nice Value）：显示进程的 nice 值，这是一个影响进程调度优先级的值。</li>
<li><strong>ADDR</strong>：显示进程的内存地址。</li>
<li><strong>SZ</strong>（Size）：显示进程使用的内存大小。</li>
<li><strong>WCHAN</strong>：如果进程处于睡眠状态，这里显示它正在等待的资源。</li>
<li><strong>STIME</strong>：显示进程开始的时间。</li>
<li><strong>TTY</strong>：显示进程绑定的终端设备。</li>
<li><strong>TIME</strong>（CPU Time）：显示进程使用的 CPU 时间总计。</li>
<li><strong>CMD</strong>（Command）：显示启动进程的命令名或命令行。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTdWNrb1loejdKQXYyNHE1ZDhtODdjQk5Bd0JBekhtTEEyTmlkRjVsNG9zLUE_ZT12bFBaSmo.png" alt="" /></p>
<h4 id="ps-auxunix-bsd-风格"><a class="anchor" href="#ps-auxunix-bsd-风格">#</a>  <code>ps aux</code> （UNIX BSD 风格）</h4>
<p>这个选项组合以用户为中心的格式显示所有进程的信息，包括：</p>
<ul>
<li><strong>USER</strong>：进程的所有者。</li>
<li><strong>PID</strong>：进程 ID。</li>
<li><strong>%CPU</strong>：进程占用的 CPU 百分比。</li>
<li><strong>%MEM</strong>：进程占用的内存百分比。</li>
<li><strong>VSZ</strong>（Virtual Size）：进程使用的虚拟内存量（以 KB 为单位）。</li>
<li><strong>RSS</strong>（Resident Set Size）：进程占用的固定内存量（以 KB 为单位）。</li>
<li><strong>TTY</strong>：进程的终端类型。</li>
<li><strong>STAT</strong>（Status）：显示进程的状态，可能包括附加值，如高优先级进程（&lt;）、会话领导进程（s）、多线程（l）、位于后台的进程组（+）等。</li>
<li><strong>START</strong>：进程的启动时间。</li>
<li><strong>TIME</strong>：进程占用 CPU 的时间。</li>
<li><strong>COMMAND</strong>：启动进程的命令。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VVOW5ZR0R3OFoxQnBsc0VqQjFJZzdRQnY4X1Y5ZDFLTElnZkpxVFU5ZGh2R3c_ZT13WjMwZk8.png" alt="" /></p>
<h3 id="free-指令"><a class="anchor" href="#free-指令">#</a>  <code>free</code>  指令</h3>
<p><code>free</code>  命令是 Linux 系统中一个用于查看内存占用情况的重要工具。它提供了关于系统内存使用情况的即时快照，包括物理内存和交换空间的详细信息。</p>
<h4 id="物理内存mem"><a class="anchor" href="#物理内存mem">#</a> 物理内存（Mem）</h4>
<ul>
<li><strong>Total</strong>：显示系统安装的总内存量。</li>
<li><strong>Used</strong>：显示已被系统使用的内存量，包括被应用程序和系统进程占用的内存。</li>
<li><strong>Free</strong>：显示当前未被使用的内存量。</li>
<li><strong>Shared</strong>：显示被多个进程共享的内存量，通常用于存储临时文件。</li>
<li><strong>Buff/Cache</strong>：显示用于缓存的内存量，这部分内存用于存储文件系统的数据，以提高数据访问速度。</li>
<li><strong>Available</strong>：提供一个粗略估计，表示系统在不影响现有应用程序运行的情况下还能使用多少内存。</li>
</ul>
<h4 id="交换空间swap"><a class="anchor" href="#交换空间swap">#</a> 交换空间（Swap）</h4>
<p>交换空间是当物理内存不足时，系统用于存储不活跃或暂时不需要的数据的磁盘空间。 <code>free</code>  命令也显示了交换空间的使用情况：</p>
<ul>
<li><strong>Total</strong>：显示系统配置的总交换空间大小。</li>
<li><strong>Used</strong>：显示当前已使用的交换空间大小。</li>
<li><strong>Free</strong>：显示当前未使用的交换空间大小。</li>
</ul>
<p>交换空间主要用于存储因内存不足而被移出物理内存的数据，而新的数据加载通常直接从磁盘加载到内存中，而不是首先加载到交换空间。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0ViT3JFTWwwNDRCRGtDdHdHR0p1Y0ZjQklrc01DdlFEcGYzR2VRTWxBNFpIcHc_ZT1qZ3M3elk.png" alt="" /></p>
<h3 id="top-指令"><a class="anchor" href="#top-指令">#</a>  <code>top</code>  指令</h3>
<p><code>top</code>  命令是一个动态的系统监控工具，用于实时显示系统中运行进程的信息。以下是  <code>top</code>  命令的主要输出内容：</p>
<h4 id="系统情况"><a class="anchor" href="#系统情况">#</a> 系统情况</h4>
<ul>
<li><strong>当前时间</strong>：显示当前的系统时间。</li>
<li><strong>系统运行时间</strong>：自系统启动以来的运行时间。</li>
<li><strong>当前登录用户数</strong>：当前登录到系统的用户数量。</li>
<li><strong>系统负载</strong>：显示过去 1 分钟、5 分钟和 15 分钟的平均负载值。对于单个 CPU，负载在 0 到 1.00 之间通常表示正常；超过 1.00 可能表明系统过载。在多核 CPU 系统中，平均负载不应超过 CPU 核心的总数。</li>
</ul>
<h4 id="任务情况tasks"><a class="anchor" href="#任务情况tasks">#</a> 任务情况（Tasks）</h4>
<ul>
<li>显示系统中的进程总数、运行中的进程数、睡眠中的进程数、停止的进程数和僵尸进程数。</li>
</ul>
<h4 id="cpu-使用情况cpu"><a class="anchor" href="#cpu-使用情况cpu">#</a> CPU 使用情况（% CPU）</h4>
<ul>
<li><strong>us</strong>（用户态）：用户态运行占用的 CPU 百分比。</li>
<li><strong>sy</strong>（内核态）：内核态运行占用的 CPU 百分比。</li>
<li><strong>ni</strong>（nice）：改变优先级的进程占用的 CPU 百分比。</li>
<li><strong>id</strong>（空闲）：CPU 空闲的百分比。</li>
<li><strong>wa</strong>（iowait）：等待输入 / 输出操作完成的时间百分比。</li>
<li><strong>hi</strong>（硬件中断）：处理硬件中断的时间百分比。</li>
<li><strong>si</strong>（软件中断）：处理软件中断的时间百分比。</li>
<li><strong>st</strong>（steal time）：在虚拟化环境中，其他虚拟机占用的时间百分比。</li>
</ul>
<h4 id="内存使用情况"><a class="anchor" href="#内存使用情况">#</a> 内存使用情况</h4>
<ul>
<li>第四行和第五行的信息等同于  <code>free</code>  命令的输出，提供了内存使用的概览。</li>
</ul>
<h4 id="进程列表部分"><a class="anchor" href="#进程列表部分">#</a> 进程列表部分</h4>
<ul>
<li><strong>PID</strong>：进程的唯一标识号。</li>
<li><strong>USER</strong>：运行进程的用户。</li>
<li><strong>PR</strong>：进程的优先级。</li>
<li><strong>NI</strong>：进程的 nice 值，影响进程调度优先级。</li>
<li><strong>VIRT</strong>：进程使用的虚拟内存总量。</li>
<li><strong>RES</strong>：进程使用的、未被换出的物理内存大小。</li>
<li><strong>SHR</strong>：共享内存的大小，可能被多个进程共享。</li>
<li><strong>S</strong>：进程的状态。</li>
<li><strong>%CPU</strong>：在动态更新的时间段内，进程占用的 CPU 时间百分比。</li>
<li><strong>%MEM</strong>：进程使用的物理内存百分比。</li>
<li><strong>TIME+</strong>：进程自启动以来占用的总 CPU 时间。</li>
<li><strong>COMMAND</strong>：启动进程的命令名称或命令行。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VRR1hmcDdSLXVWQW14SmMyT3pXQXpJQlAyLVI4Ykh1ZDBhLXExdkY2dEtaS0E_ZT00T3B6bFM.png" alt="" /></p>
<h3 id="pid"><a class="anchor" href="#pid">#</a>  <code>PID</code></h3>
<p>操作系统为每个进程分配了一个唯一的正整数标识符，称为 <strong>进程 ID</strong>（<strong>PID</strong>）。PID 是进程间亲缘关系的关键标识，其中启动其他进程的称为 <strong>父进程</strong>，被启动的称为 <strong>子进程</strong>。在 Linux 系统中，PID 和进程控制块（PCB）之间存在一一对应关系，可以通过查看  <code>task_struct</code>  结构体来获取进程的 PID 及其父进程 ID。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYSlhQYnlRcnlWUG9MVXVnOW1TX0NnQmg0QmJvWnRCb1FGLXVJemMwbVdSUGc_ZT0yWTB2NzE.png" alt="" /></p>
<p>使用  <code>ps -l</code>  命令可以查看进程列表，其中包括 shell 进程和  <code>ps</code>  命令进程。通过 PPID 列可以确定  <code>ps</code>  进程的父进程是 bash shell。此外，通过系统调用  <code>getpid()</code>  和  <code>getppid()</code> ，可以在程序中获取当前进程的 PID 和父进程 ID，如下所示：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Current PID: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Current parent process PID: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当 Linux 系统启动时，首先执行的是 BIOS 程序，这是一段固件级别的初始化代码，负责初始化硬件并定位启动设备，如硬盘或 USB 等。接着，启动设备上的 Bootloader 代码被加载并执行，Bootloader 的任务是加载 Linux 内核。</p>
<p>一旦 Bootloader 将控制权交给内核，内核便开始初始化硬件设备、设置内存管理，并创建和启动关键的内核线程和服务。内核启动的第一个用户级进程通常是  <code>init</code>  进程，其 PID 通常是 1，负责启动系统上的所有其他进程和服务。 <code>init</code>  进程读取系统配置文件，如  <code>/etc/init.d/</code>  或  <code>/etc/rc2.d/</code>  等，初始化系统环境，并按顺序启动程序，使系统达到正常运行状态。</p>
<p>以 Bash shell 为例， <code>init</code>  进程通过读取配置文件  <code>/etc/rc2.d/</code>  中的  <code>/etc/init.d/ssh</code>  来加载 ssh 程序，随后 ssh 程序加载 Bash shell。通过 Bash shell 启动的任何程序都成为 Bash shell 的子进程。</p>
<h3 id="kill-命令"><a class="anchor" href="#kill-命令">#</a>  <code>Kill</code>  命令</h3>
<p><code>kill</code>  命令是一种在 Linux 和 UNIX 系统中用于向进程发送信号的工具。信号是一种软件中断，可以指示进程执行特定的操作，如终止或暂停。</p>
<h4 id="进程的前台与后台状态"><a class="anchor" href="#进程的前台与后台状态">#</a> 进程的前台与后台状态</h4>
<ul>
<li>当用户从终端启动一个进程时，该进程默认在前台运行，并能接收键盘发送的信号。例如， <code>Ctrl+C</code>  产生终止信号（SIGINT），而  <code>Ctrl+Z</code>  产生暂停信号（SIGTSTP）。</li>
<li>如果进程在后台运行，它不会接收键盘信号，而只能通过  <code>kill</code>  命令发送信号。</li>
</ul>
<h4 id="使用-kill-命令"><a class="anchor" href="#使用-kill-命令">#</a> 使用  <code>kill</code>  命令</h4>
<ul>
<li>
<p>要查看所有可用的信号列表，可以使用：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">kill</span> <span class="token parameter variable">-l</span></pre></td></tr></table></figure></li>
<li>
<p>发送信号以异常方式终止进程，可以使用：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">kill</span> <span class="token parameter variable">-9</span> pid</pre></td></tr></table></figure><p>其中  <code>-9</code>  对应于  <code>SIGKILL</code>  信号，这是一个强制终止进程的信号。</p>
</li>
</ul>
<h4 id="后台进程的启动与管理"><a class="anchor" href="#后台进程的启动与管理">#</a> 后台进程的启动与管理</h4>
<ul>
<li>
<p>通过在命令末尾添加  <code>&amp;</code>  符号，可以直接启动进程到后台。例如：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">vim</span> ./01_test <span class="token operator">&amp;</span></pre></td></tr></table></figure><p>这将启动  <code>vim</code>  并将其置于后台，允许用户继续在终端中执行其他命令。</p>
</li>
<li>
<p>使用  <code>Ctrl+Z</code>  可以暂停当前运行的前台进程，将其放到后台，并显示任务编号。例如：</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td data-command="[root@localhost] $"></td><td><pre><span class="token function">vim</span> ./01_test</pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token punctuation">[</span>Ctrl+Z<span class="token punctuation">]</span></pre></td></tr></table></figure><p>这将暂停  <code>vim</code>  并显示任务编号。</p>
</li>
</ul>
<h4 id="后台任务的管理"><a class="anchor" href="#后台任务的管理">#</a> 后台任务的管理</h4>
<ul>
<li>使用  <code>jobs</code>  命令可以查看当前所有的后台任务。</li>
<li>使用  <code>fg</code>  命令可以将后台任务带到前台继续运行。</li>
<li>使用  <code>bg</code>  命令可以继续在后台运行之前暂停的任务。</li>
</ul>
<h2 id="linux-c-函数"><a class="anchor" href="#linux-c-函数">#</a> Linux C 函数</h2>
<h3 id="system-执行-shell-命令"><a class="anchor" href="#system-执行-shell-命令">#</a>  <code>system</code>  执行 shell 命令</h3>
<p><code>system</code>  函数是 C 语言标准库中用于执行 shell 命令的函数。它允许你在 C 程序中启动一个新进程来运行一个 shell 命令，并等待该命令完成执行。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>command</code> ：一个指向以 null 结尾的字符串的指针，这个字符串包含了要执行的 shell 命令。</p>
<p>返回值：</p>
<ul>
<li>成功时， <code>system</code>  返回命令的退出状态。在大多数系统上，这通常是一个非负整数，表示命令的终止状态。</li>
<li>如果命令行参数是  <code>NULL</code> ，函数返回 0。</li>
<li>失败时，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><code>system</code>  函数实际上是调用了  <code>fork</code>  和  <code>exec</code>  函数族来创建一个新的进程，并在这个新进程中执行指定的命令。 <code>system</code>  调用的进程会等待由  <code>command</code>  指定的命令执行完成，然后返回。</p>
<p>以下是使用  <code>system</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> status<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 执行 shell 命令</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    status <span class="token operator">=</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"echo Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"命令执行的退出状态为： %d\n"</span><span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，使用了  <code>system</code>  函数执行了  <code>echo Hello, World!</code>  这个 shell 命令。如果  <code>system</code>  调用失败，打印错误信息并返回。否则打印出命令的退出状态。</p>
<p>使用  <code>system</code>  时需要注意的事项：</p>
<ul>
<li><code>system</code>  会启动一个 shell 来执行命令，这可能会导致安全风险，特别是如果命令字符串由不可信的输入构成时。</li>
<li><code>system</code>  函数的返回值通常需要通过  <code>WEXITSTATUS</code>  宏和  <code>wait</code>  函数族来解析，以确定子进程的确切退出状态。</li>
<li>在某些环境中，为了避免安全问题，推荐使用更具体的  <code>exec</code>  函数族，或者使用管道和  <code>popen</code> / <code>pclose</code>  对来执行外部命令。</li>
</ul>
<p>由于  <code>system</code>  函数的这些限制和潜在的安全问题，现代的 C 程序设计中倾向于使用其他方法来执行外部命令。</p>
<h3 id="fork-复制进程"><a class="anchor" href="#fork-复制进程">#</a>  <code>fork</code>  复制进程</h3>
<p><code>fork</code>  函数是 POSIX 标准中用于创建进程的系统调用，它在 UNIX 和类 UNIX 系统中广泛使用。 <code>fork</code>  函数通过复制调用它的进程来创建一个新的进程，这个新进程称为子进程（child process），而调用它的进程称为父进程（parent process）。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>fork</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>在父进程中， <code>fork</code>  返回新创建子进程的进程 ID（PID），这是一个正整数。</li>
<li>在子进程中， <code>fork</code>  返回 0。</li>
<li>如果函数调用失败，返回  <code>-1</code> ，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><code>pid_t</code>  是一个用来表示进程 ID 的数据类型，通常定义为  <code>int</code>  或  <code>long int</code> 。</p>
<p>以下是使用  <code>fork</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">//fork 调用失败</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 这是子进程（子进程的 PID 为 0）</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是 PID : %ld 的子进程 \n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 这是父进程</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我是 PID 为 %ld 的父进程，我的子进程 PID 为 %ld\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 父进程和子进程可以继续执行其他操作...</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，调用  <code>fork</code>  来创建一个新的子进程。如果  <code>fork</code>  调用失败打印错误信息并返回失败状态。如果  <code>fork</code>  成功，则根据返回值判断当前是父进程还是子进程，并打印相应的消息。</p>
<p><code>fork</code>  函数的行为特点：</p>
<ul>
<li>子进程继承父进程的许多属性，包括文件描述符、环境变量、当前工作目录等。</li>
<li>子进程获得父进程数据空间、堆和栈的副本，但对这些空间的修改不会影响父进程。</li>
<li><code>fork</code>  之后，子进程的返回地址会接着执行  <code>fork</code>  调用之后的代码，而父进程则继续执行  <code>fork</code>  调用之后的代码。</li>
<li>子进程的 PID 在系统中是唯一的。</li>
</ul>
<h4 id="内存复制"><a class="anchor" href="#内存复制">#</a> 内存复制</h4>
<p>当调用  <code>fork</code>  函数时，它会创建一个新的进程，这个新进程几乎完全复制了当前进程的用户态地址空间。这意味着在  <code>fork</code>  调用时，父进程的内存布局，包括进程上下文、变量、堆栈、程序代码等，都会被复制到子进程中。</p>
<p>子进程的独立性：尽管子进程开始时是父进程的一个副本，但为了确保两个进程的独立性，某些属性和资源需要在子进程中进行适当的修改。这些修改主要涉及进程控制块（PCB）。</p>
<p>进程标识符（PID）：<strong>子进程的 PID</strong>：子进程获得一个唯一的进程标识符（PID），这个 PID 与父进程的 PID 不同，确保了子进程在系统中的唯一性。</p>
<p>父进程标识符（PPID）：<strong>子进程的 PPID</strong>：子进程的父进程标识符（PPID）被设置为创建它的父进程的 PID，这建立了进程间的父子关系。</p>
<p>其他属性和资源：除了 PID 和 PPID 之外，子进程还会继承父进程的许多属性，如打开的文件描述符、信号处理设置、用户和组 ID 等。但是，子进程会拥有自己的独立堆栈和内存空间，以支持其独立执行。</p>
<p>子进程的创建： <code>fork</code>  函数在父进程中返回新创建子进程的 PID，而在子进程中返回 0。这个特性可以用于在代码中区分父进程和子进程的执行路径。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0Vjb05zN3lGQ0ZwSGstdnZpM3dTZk44QlBMYmdYRnlDc3ZoWTNvQTJNRDdZVnc_ZT1TMG9ISzc.png" alt="1413469471bcef7270cb0727d47e5682.png" /></p>
<h4 id="写时复制"><a class="anchor" href="#写时复制">#</a> 写时复制</h4>
<p>为了降低数据复制的开销并优化内存管理， <code>fork</code>  函数采用了写时复制（Copy-On-Write，简称 COW）策略。这种策略在  <code>fork</code>  执行时的行为如下：</p>
<ul>
<li>操作系统不会立即复制父进程的整个内存空间给子进程。相反，它允许父进程和子进程在初始阶段暂时共享相同的物理内存页。</li>
<li>这些共享的内存页在内存中被标记为只读。这意味着，只要父进程或子进程没有尝试修改这些页面，它们就可以继续共享这些内存页，而无需复制。</li>
<li>一旦父进程或子进程尝试写入这些共享的页面，操作系统会介入。它会为发起写操作的进程分配一个新的物理内存页，并执行数据的复制操作。这个新分配的页将只属于发起写操作的进程，而另一个进程仍然保留对原始只读页的访问。</li>
</ul>
<p>COW 机制确保了只有在进程实际需要修改数据时才进行内存页的复制，从而：</p>
<ul>
<li>减少了不必要的内存复制操作，降低了内存使用量。</li>
<li>提高了进程创建的效率，尤其是在父进程拥有大量内存页时。</li>
</ul>
<h4 id="文件打开和-fork"><a class="anchor" href="#文件打开和-fork">#</a> 文件打开和  <code>fork</code></h4>
<p>在使用  <code>fork()</code>  函数生成子进程之前，如果已经执行了文件打开操作，子进程将继承父进程的文件描述符集合。这些文件描述符实际上是指向操作系统中的文件表项的指针。重要的是，文件表项是由操作系统管理的，它们可以被多个进程共享。这导致了一个结果：父进程和子进程将共享对同一个文件表项的访问。</p>
<p>文件表项的共享特性：在文件表项中，除了包含了指向磁盘上文件 inode 的指针之外，还记录了文件的当前读写偏移量。这意味着父进程和子进程在对文件进行读写操作时，将共享这个偏移量，从而影响彼此的文件操作位置。</p>
<p>文件描述符的独立性：相对地，在  <code>fork()</code>  函数调用之后，如果父进程和子进程各自独立地打开了一个文件，操作系统将分别为它们创建独立的文件表项。即便这两个进程打开的是同一个文件系统中的对象，即 inode 相同，它们的文件表项和读写偏移量也将是独立的。</p>
<p>独立文件操作的意义：这种机制确保了父进程和子进程在文件操作中的独立性。即使它们可能访问相同的文件数据，它们的读写位置和状态是分开维护的，从而避免了相互之间的干扰。</p>
<p>假设父进程打开了一个文件并读取了一些数据，然后调用了  <code>fork()</code> 。子进程将继续从文件的当前位置开始读取，这个位置是父进程留下的位置。如果子进程继续读取或写入文件，那么父进程下次对文件的操作也会从这个新的位置开始。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"example.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 父进程打开文件</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建子进程</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 子进程</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子进程从父进程停止的地方继续读取</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 父进程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 父进程可以继续对文件进行操作，共享相同的文件读写位置</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上述示例中，如果子进程执行了读取操作，父进程在子进程读取后对文件的任何操作都将从子进程停止读取的地方开始。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYUlVKZXRZZHhWSGg4UTV4RmQ1emxnQjFWRU81RFpkaUlNMldqX1piT1FHamc_ZT1kdjA5S08.png" alt="fork_open_before.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaQVl4OVkteXhsRHJnUzF0akVVQXlZQmx2WWRoNWtId1R5RkxOd0ZJN2YxYlE_ZT02OXVYejU.png" alt="fork_open_after.png" /></p>
<h3 id="exec-函数替换进程映像"><a class="anchor" href="#exec-函数替换进程映像">#</a>  <code>exec</code>  函数替换进程映像</h3>
<h4 id="execl-函数"><a class="anchor" href="#execl-函数">#</a>  <code>execl</code>  函数</h4>
<p><code>execl</code>  函数是 POSIX 标准中用于执行一个新程序的系统调用，它替换当前进程的映像，而不是创建一个新进程。 <code>execl</code>  是  <code>exec</code>  函数族中的一员，它允许你指定程序的路径和参数列表。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/*, (char *)0 */</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ul>
<li><code>path</code> ：要执行的程序的路径。</li>
<li><code>arg0</code> ：程序的第一个命令行参数，通常为主函数  <code>main</code>  的  <code>argv[0]</code> 。</li>
<li>随后的参数：一系列以 null 结尾的字符串，表示程序的其余命令行参数。</li>
<li><code>((char *)0)</code> ：最后一个参数必须是  <code>NULL</code> ，以标记参数列表的结束。</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>execl</code>  函数不会返回，因为它会替换当前进程的映像。如果执行成功，当前进程将开始执行新的程序。</li>
<li>如果  <code>execl</code>  调用失败，它不会返回。通常，你会在调用  <code>execl</code>  之前设置一个跳板函数（trampoline），以便在  <code>execl</code>  失败时返回错误。</li>
</ul>
<p><code>execl</code>  函数的行为特点：</p>
<ul>
<li>它加载并运行指定路径的程序，替换当前进程的映像。</li>
<li>当前进程的内存空间、文件描述符、环境变量等都会被新程序的相应内容替换。</li>
<li><code>execl</code>  调用成功后，当前进程的代码和数据将被新程序的代码和数据替换，进程的 ID（PID）保持不变。</li>
</ul>
<p>以下是使用  <code>execl</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 使用 execl 执行 "ls -l" 命令</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">//execl 调用失败</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//execl 调用成功时不会返回</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTQWVrNHFtbDlGSmp6cWRLV0wteFNrQkZJR2piSkRkQlJWNGtTZDRBMHhjZUE_ZT1hbUFoTnY.png" alt="Code_lWqLJ2OrWt.png" /></p>
<p>在上面的例子中使用  <code>execl</code>  来执行  <code>/bin/ls -l</code>  命令。如果  <code>execl</code>  调用失败，打印错误信息并返回失败状态。然而，如果  <code>execl</code>  成功，当前进程将被  <code>ls -l</code>  命令替换，并且不会执行  <code>perror</code>  和  <code>return</code>  之后的代码。</p>
<p>使用  <code>execl</code>  时需要注意的事项：</p>
<ul>
<li>由于  <code>execl</code>  替换当前进程的映像，因此它不会返回。如果需要处理  <code>execl</code>  失败的情况，应该在调用  <code>execl</code>  之前进行错误处理。</li>
<li><code>execl</code>  只接受字符串参数，如果需要传递其他类型的数据，应该使用其他  <code>exec</code>  函数族成员，如  <code>execv</code>  或  <code>execvp</code> 。</li>
<li><code>execl</code>  调用时，程序的当前工作目录和环境变量等属性将被继承。</li>
<li>安全起见，如果路径或参数来自不可信的输入，应该使用  <code>execv</code>  或  <code>execvp</code>  并确保参数经过严格验证。</li>
</ul>
<h4 id="execv-函数"><a class="anchor" href="#execv-函数">#</a>  <code>execv</code>  函数</h4>
<p><code>execv</code>  函数是 POSIX 标准中用于执行一个新程序的系统调用，它替换当前进程的映像。与  <code>execl</code>  不同， <code>execv</code>  不需要将参数逐个列在函数调用中，而是接受一个参数数组。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>path</code> ：要执行的程序的路径，这是一个字符串，指定了可执行文件的路径。</li>
<li><code>argv</code> ：这是一个字符指针数组，包含了传递给新程序的参数列表。数组的最后一个元素必须是空指针（ <code>NULL</code> ），以标记参数列表的结束。</li>
</ol>
<p>返回值：</p>
<ul>
<li><code>execv</code>  函数在成功执行时不会返回，因为它将当前进程的映像替换为新程序的映像，进程将开始执行新程序。</li>
<li>如果  <code>execv</code>  调用失败，它将返回 -1 并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p><code>execv</code>  函数的行为特点：</p>
<ul>
<li>它加载并运行指定路径的程序，替换当前进程的映像。</li>
<li>当前进程的内存空间、文件描述符、环境变量等都会被新程序的相应内容替换。</li>
<li><code>execv</code>  调用成功后，当前进程的代码和数据将被新程序的代码和数据替换，进程的 ID（PID）保持不变。</li>
</ul>
<p>以下是使用  <code>execv</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 命令行参数数组</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path <span class="token operator">=</span> <span class="token string">"/bin/ls"</span><span class="token punctuation">;</span>           <span class="token comment">// 程序路径</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 使用 execv 执行 "ls -l" 命令</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execv</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">//execv 调用失败</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//execv 调用成功时不会返回</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTQWVrNHFtbDlGSmp6cWRLV0wteFNrQkZJR2piSkRkQlJWNGtTZDRBMHhjZUE_ZT1hbUFoTnY.png" alt="Code_lWqLJ2OrWt.png" /></p>
<p>在上面的例子中，我们定义了一个参数数组  <code>argv</code>  和程序路径  <code>path</code> 。使用  <code>execv</code>  执行  <code>/bin/ls -l</code>  命令。如果  <code>execv</code>  调用失败，打印错误信息并返回失败状态。如果  <code>execv</code>  成功，当前进程将被  <code>ls -l</code>  命令替换，并且不会执行  <code>perror</code>  和  <code>return</code>  之后的代码。</p>
<p>使用  <code>execv</code>  时需要注意的事项：</p>
<ul>
<li>由于  <code>execv</code>  替换当前进程的映像，因此它不会返回。如果需要处理  <code>execv</code>  失败的情况，应该在调用  <code>execv</code>  之前进行错误处理。</li>
<li><code>execv</code>  接受一个以空指针结束的参数数组，这使得它在处理来自外部源的参数时更加灵活和安全。</li>
<li><code>execv</code>  调用时，程序的当前工作目录和环境变量等属性将被继承。</li>
<li>安全起见，如果路径或参数来自不可信的输入，应该确保路径的有效性，并对参数进行严格验证。</li>
</ul>
<h3 id="退出进程"><a class="anchor" href="#退出进程">#</a> 退出进程</h3>
<p>在进程阶段，进程总共有 5 种终止方式，其中 3 种是正常终止，还有 2 种是异常终止：</p>
<table>
<thead>
<tr>
<th>终止方式</th>
<th>终止情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>main 函数中调用 return</td>
<td>正常</td>
</tr>
<tr>
<td>调用 exit 函数</td>
<td>正常</td>
</tr>
<tr>
<td>调用  <code>_Exit</code>  函数或者  <code>_exit</code>  函数</td>
<td>正常</td>
</tr>
<tr>
<td>调用 abort 函数</td>
<td>异常</td>
</tr>
<tr>
<td>接收到引起进程终止的信号</td>
<td>异常</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VkSWkxdzNwUUxaSXRPRlQxcUVwLVFRQl9ONUNQS3VtSUtiZzZsQ3FVUTBONFE_ZT1sVWM0czk.png" alt="46111f5db308a670df7920e2b0130265.png" /></p>
<p>当进程处于前台的时候，按下 ctrl+c 或者是 ctrl+\ 可以给整个进程组发送键盘中断信号 SIGINT 和 SIGQUIT。</p>
<h4 id="exit-终止当前进程"><a class="anchor" href="#exit-终止当前进程">#</a>  <code>exit</code>  终止当前进程</h4>
<p><code>exit</code>  函数是 C 语言标准库中用于终止当前进程的函数。当你希望正常或异常地结束程序的执行时，可以调用  <code>exit</code>  函数。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>status</code> ：一个整数，表示程序的退出状态。这个状态可以被父进程或操作系统捕获，用于了解程序是成功完成执行还是遇到了错误。</p>
<p>功能：当  <code>exit</code>  被调用时，它将终止当前进程，并返回给操作系统一个退出状态码。进程的所有资源将被释放，包括打开的文件描述符、内存、锁等。</p>
<p>返回值： <code>exit</code>  函数不返回。一旦调用，控制权将返回给操作系统，当前进程将终止。</p>
<p><code>status</code>  参数通常遵循以下约定：</p>
<ul>
<li>0：表示程序正常退出。</li>
<li>非零值：通常表示程序由于某种原因而异常退出，例如错误或异常条件。</li>
</ul>
<p>以下是使用  <code>exit</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 正常退出程序</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 以下代码将不会被执行</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中， <code>exit(0)</code>  被调用，导致程序立即以状态码 0 退出，表示成功完成。</p>
<p>使用  <code>exit</code>  时需要注意的事项：</p>
<ul>
<li>一旦调用  <code>exit</code> ，当前进程将终止，所有未处理的清理工作将不会被执行。因此，确保在调用  <code>exit</code>  之前完成所有必要的清理工作。</li>
<li>如果在多线程程序中调用  <code>exit</code> ，整个程序的所有线程都将被终止，而不仅仅是调用  <code>exit</code>  的线程。</li>
<li>在某些情况下，可以使用  <code>_exit</code>  或  <code>_Exit</code>  函数作为替代，这些函数不进行任何清理工作，直接终止进程。但通常推荐使用  <code>exit</code> ，因为它允许进行标准的退出前清理。</li>
</ul>
<p><code>exit</code>  是程序控制流程的基本部分，确保程序可以在完成工作或遇到错误时正确地终止。</p>
<h4 id="_exit-终止当前进程"><a class="anchor" href="#_exit-终止当前进程">#</a>  <code>_Exit</code>  终止当前进程</h4>
<p><code>_Exit</code>  函数是 C 语言标准库中的一个函数，用于立即终止当前进程，而不像  <code>exit</code>  函数那样执行标准 I/O 缓冲区的刷新或其他清理操作。 <code>_Exit</code>  提供了一种快速退出进程的方式，通常用于紧急情况或当确定不需要进行任何清理时。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">_Exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>status</code> ：一个整数，表示程序的退出状态码。这个状态码可以被父进程或操作系统捕获，用于了解程序是成功完成执行还是遇到了错误。</p>
<p>功能： <code>_Exit</code>  函数调用导致当前进程立即终止，并返回给操作系统一个退出状态码。与  <code>exit</code>  不同， <code>_Exit</code>  不会刷新标准 I/O 缓冲区，也不会调用任何退出处理程序（如  <code>exit</code>  函数注册的  <code>atexit</code>  函数）。它直接关闭所有文件描述符并终止进程。</p>
<p>返回值： <code>_Exit</code>  函数不返回。一旦调用，控制权将返回给操作系统，当前进程将终止。</p>
<p>以下是使用  <code>_Exit</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">terminate_process</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 立即退出进程，不进行任何清理</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">_Exit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 正常退出程序</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">terminate_process</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 以下代码将不会被执行</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中， <code>terminate_process</code>  函数使用  <code>_Exit</code>  立即退出进程。由于  <code>_Exit</code>  不返回，因此  <code>main</code>  函数中的后续代码不会被执行。</p>
<p>使用  <code>_Exit</code>  时需要注意的事项：</p>
<ul>
<li><code>_Exit</code>  用于紧急情况或当确定不需要进行任何清理时。如果你的程序需要在退出前进行一些清理工作（如释放资源、同步数据等），应该使用  <code>exit</code>  而不是  <code>_Exit</code> 。</li>
<li><code>_Exit</code>  不刷新标准 I/O 缓冲区，因此如果缓冲区中的数据需要被写入磁盘，使用  <code>_Exit</code>  可能导致数据丢失。</li>
<li><code>_Exit</code>  不调用任何退出处理程序，因此如果程序中有注册  <code>atexit</code>  函数或其他退出处理程序，使用  <code>_Exit</code>  将跳过这些处理程序。</li>
<li>在多线程程序中， <code>_Exit</code>  只终止调用它的线程所在的进程，而不是所有线程。</li>
</ul>
<p><code>_Exit</code>  提供了一种快速退出进程的方法，但应该谨慎使用，确保在退出前不需要进行其他任何操作。</p>
<h4 id="_exit-终止当前进程-2"><a class="anchor" href="#_exit-终止当前进程-2">#</a>  <code>_exit</code>   终止当前进程</h4>
<p><code>_exit</code>  函数是定义在  <code>unistd.h</code>  中的一个函数，其原型是：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>status</code> ：一个整数，表示程序退出时的状态码。这个状态码可以被操作系统或父进程用来确定程序是成功退出还是遇到了错误。</p>
<p>功能： <code>_exit</code>  函数用于立即终止当前进程，并退出到操作系统。与  <code>exit</code>  函数不同， <code>_exit</code>  不会执行任何清理操作，如刷新标准 I/O 缓冲区或调用注册的退出处理程序（例如通过  <code>atexit</code>  注册的函数）。</p>
<p>返回值： <code>_exit</code>  函数不返回。一旦调用，它将立即终止进程，并将指定的退出状态码返回给操作系统。</p>
<p>使用  <code>_exit</code>  的示例代码如下：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 正常退出，状态码为 0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 这行代码不会被执行，因为 _exit 不会返回</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的示例中， <code>_exit(0)</code>  被调用，程序将立即退出，状态码为 0，表示正常退出。</p>
<p>使用  <code>_exit</code>  时应注意的事项：</p>
<ul>
<li>由于  <code>_exit</code>  不执行任何清理操作，它比  <code>exit</code>  更适合于紧急情况下的退出，或者在确定不需要任何清理的情况下使用。</li>
<li>如果程序中有未保存的数据或需要执行其他清理工作，应使用  <code>exit</code>  而不是  <code>_exit</code> 。</li>
<li>在多线程程序中， <code>_exit</code>  只会导致当前线程终止，其他线程将继续运行。如果需要终止整个进程，应确保所有线程都正确同步。</li>
<li><code>_exit</code>  直接终止进程，不会进行标准的退出序列，因此使用时需要谨慎，确保不会丢失重要数据或资源。</li>
</ul>
<h4 id="abort-异常终止当前进程"><a class="anchor" href="#abort-异常终止当前进程">#</a>  <code>abort</code>   异常终止当前进程</h4>
<p><code>abort</code>  函数是 C 语言标准库中的一个函数，用于异常终止当前进程。当  <code>abort</code>  被调用时，它会导致进程立即停止执行，并返回一个退出状态码，表示进程是因为一个信号而终止的。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>abort</code>  函数不接受任何参数。</p>
<p>返回值： <code>abort</code>  函数不返回。一旦调用，它将立即终止当前进程。</p>
<p><code>abort</code>  函数的行为包括：</p>
<ul>
<li>向进程发送  <code>SIGABRT</code>  信号（在 POSIX 系统中）。</li>
<li>调用所有已注册的  <code> SIGABRT</code>  信号处理程序。</li>
<li>清理临时文件（如果进程使用的是标准 I/O 库）。</li>
<li>关闭所有打开的文件描述符。</li>
<li>将退出状态码设为  <code>SIGABRT</code>  的值加上 128，或者在某些系统中，可能直接设置为  <code>SIGABRT</code>  的值。</li>
</ul>
<p>以下是使用  <code>abort</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 触发异常终止</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 下面的代码将不会被执行</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，调用  <code>abort()</code>  将立即终止程序，程序不会执行  <code>abort()</code>  之后的任何代码。</p>
<p>使用  <code>abort</code>  时需要注意的事项：</p>
<ul>
<li><code>abort</code>  通常用于遇到无法恢复的错误时，需要立即停止程序的情况。</li>
<li>由于  <code>abort</code>  会发送  <code>SIGABRT</code>  信号，任何为  <code>SIGABRT</code>  信号注册的处理程序都将被调用。</li>
<li><code>abort</code>  会清理标准 I/O 库使用的临时文件，但不会刷新标准 I/O 缓冲区，这意味着可能存在数据丢失的风险。</li>
<li>在多线程程序中， <code>abort</code>  调用将终止整个进程，不仅仅是当前线程。</li>
</ul>
<p><code>abort</code>  是处理严重错误情况的一种方式，但开发者在使用时应该谨慎，确保所有重要的资源都得到了适当的管理，以避免资源泄露或其他副作用。</p>
<h3 id="wait-等待子进程状态"><a class="anchor" href="#wait-等待子进程状态">#</a>  <code>wait</code>  等待子进程状态</h3>
<p><code>wait</code>  函数是 POSIX 标准中用于等待子进程状态改变的系统调用。当一个父进程创建了一个或多个子进程后，它可能会调用  <code>wait</code>  函数来挂起执行，直到至少有一个子进程更改其状态，这通常是因为子进程已经终止。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>wstatus</code> ：一个指向整数的指针，用于接收子进程的退出状态。如果子进程是因为接收到信号而终止的，这个参数会提供有关退出原因的信息。</p>
<p>返回值：</p>
<ul>
<li>成功时， <code>wait</code>  返回被等待终止的子进程的进程 ID（PID）。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p><code>wait</code>  函数的行为特点：</p>
<ul>
<li>父进程调用  <code>wait</code>  将挂起，直到有一个子进程终止。</li>
<li><code>wait</code>  可以等待任何一个子进程的状态改变，而不管子进程的 PID。</li>
<li>一旦子进程终止， <code>wait</code>  将返回，并通过  <code>wstatus</code>  参数提供子进程的退出状态。</li>
</ul>
<p>退出状态可以通过宏  <code>WIFEXITED(status)</code>  检查子进程是否正常退出，如果是， <code>WEXITSTATUS(status)</code>  宏可以获取子进程的退出码。如果子进程是因为信号而终止的， <code>WIFSIGNALED(status)</code>  宏可以用来获取该信号的编号。</p>
<p>以下是使用  <code>wait</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建子进程</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">//fork 调用失败</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 这是子进程</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am the child process with PID: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子进程退出</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 这是父进程</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">int</span> wstatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">pid_t</span> terminated_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程终止</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process (PID: %d) terminated\n"</span><span class="token punctuation">,</span> terminated_pid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child exited with status: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，父进程调用  <code>fork</code>  创建了一个子进程。子进程打印自己的 PID 并正常退出。父进程调用  <code>wait</code>  等待子进程终止，并接收子进程的退出状态。然后，父进程检查子进程是否正常退出，并打印退出状态码。</p>
<p>使用  <code>wait</code>  时需要注意的事项：</p>
<ul>
<li><code>wait</code>  可以被多次调用，以等待多个子进程的终止。</li>
<li>如果有多个子进程， <code>wait</code>  将返回第一个终止的子进程的 PID。</li>
<li>如果不希望等待子进程，可以使用  <code>waitpid</code>  函数，它允许指定要等待的子进程的 PID，以及其他选项。</li>
</ul>
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WIFEXITED(wstatus)</code></td>
<td>子进程正常退出的时候返回真，此时可以使用  <code>WEXITSTATUS(wstatus)</code> ，获取子进程的返回情况</td>
</tr>
<tr>
<td><code>WIFSIGNALED(wstatus)</code></td>
<td>子进程异常退出的时候返回真，此时可以使用  <code>WTERMSIG(wstatus)</code>  获取信号编号，可以使用  <code>WCOREDUMP(wstatus)</code>  获取是否产生 core 文件</td>
</tr>
<tr>
<td><code>WIFSTOPPED(wstatus)</code></td>
<td>子进程暂停的时候返回真，此时可以使用  <code>WSTOPSIG(wstatus)</code>  获取信号编号</td>
</tr>
<tr>
<td>...</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="waitpid-检查子进程状态"><a class="anchor" href="#waitpid-检查子进程状态">#</a>  <code>waitpid</code>  检查子进程状态</h3>
<p><code>waitpid</code>  函数是 POSIX 标准中用于等待或检查一个子进程状态改变的系统调用。与  <code>wait</code>  函数相比， <code>waitpid</code>  提供了更多的灵活性，允许父进程指定要等待的子进程的 PID，以及其他选项来控制等待的行为。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li>
<p><code>pid</code> ：指定要等待的子进程的进程 ID（PID）。特殊值  <code>-1</code>  表示等待任何子进程。\</p>
<table>
<thead>
<tr>
<th>PID 数值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;  -1</td>
<td>等待进程 PID 和 pid 绝对值的进程</td>
</tr>
<tr>
<td>==  -1</td>
<td>等待任一个子进程，等价于 wait</td>
</tr>
<tr>
<td>== 0</td>
<td>等待同一进程组的任意子进程</td>
</tr>
<tr>
<td>&gt; 0</td>
<td>等待指定 PID 的进程</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>wstatus</code> ：一个指向整数的指针，用于接收子进程的退出状态。如果子进程是因为接收到信号而终止的，这个参数会提供有关退出原因的信息。</p>
</li>
<li>
<p><code>option</code> ：指定等待行为的选项，可以是以下宏的组合：</p>
<ul>
<li><code>WNOHANG</code> ：如果没有任何子进程状态改变， <code>waitpid</code>  不会阻塞，而是立即返回 0。</li>
<li><code>WUNTRACED</code> ：也会返回状态为  <code>STOPPED</code> （已停止）的子进程的信息。</li>
</ul>
</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时， <code>waitpid</code>  返回被等待状态改变的子进程的 PID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
<li>如果  <code>WNOHANG</code>  选项被设置，并且没有子进程状态改变，则返回 0。</li>
</ul>
<p>以下是使用  <code>waitpid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建子进程</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">//fork 调用失败</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 这是子进程</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am the child process with PID: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子进程休眠 2 秒</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子进程退出</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 这是父进程</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> wstatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token class-name">pid_t</span> terminated_pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wstatus<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待特定子进程终止</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>terminated_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"waitpid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process (PID: %d) terminated\n"</span><span class="token punctuation">,</span> terminated_pid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child exited with status: %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，父进程调用  <code>fork</code>  创建了一个子进程。子进程打印自己的 PID 并休眠 2 秒后正常退出。父进程调用  <code>waitpid</code>  等待特定 PID 的子进程终止，并接收子进程的退出状态。然后，父进程检查子进程是否正常退出，并打印退出状态码。</p>
<p>使用  <code>waitpid</code>  时需要注意的事项：</p>
<ul>
<li><code>waitpid</code>  可以用来等待特定的子进程或任何子进程的状态改变。</li>
<li>使用  <code>WNOHANG</code>  选项可以进行非阻塞等待，这在某些情况下很有用，例如在循环中检查子进程状态时。</li>
<li>使用  <code>WUNTRACED</code>  选项可以等待子进程停止（例如，因为收到  <code>SIGSTOP</code>  信号）。</li>
<li>父进程应该检查  <code>waitpid</code>  返回的 PID，以确定哪个子进程状态发生了改变，并适当地处理退出状态。</li>
</ul>
<h3 id="用户-id"><a class="anchor" href="#用户-id">#</a> 用户 ID</h3>
<h4 id="getuid-获取真实用户-id"><a class="anchor" href="#getuid-获取真实用户-id">#</a>  <code>getuid</code>   获取真实用户 ID</h4>
<p><code>getuid</code>  函数是 POSIX 标准中用于获取当前进程的真实用户 ID（UID）的系统调用。这个调用提供了进程启动时所使用的用户身份信息。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">uid_t</span> <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>getuid</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回当前进程的真实用户 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>真实用户 ID 是指进程启动时所具有的用户 ID。在 UNIX 和类 UNIX 系统中，这个 ID 用于权限控制和确定哪些资源可以被进程访问。</p>
<p>以下是使用  <code>getuid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">uid_t</span> uid <span class="token operator">=</span> <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的真实用户 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The real user ID of this process is: %d\n"</span><span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>getuid</code>  来获取当前进程的真实用户 ID，并将其打印出来。</p>
<p>使用  <code>getuid</code>  时需要注意的事项：</p>
<ul>
<li><code>getuid</code>  通常用于安全和权限管理，例如在确定哪些文件可以被访问或哪些操作可以被执行时。</li>
<li>如果程序需要改变其有效用户 ID 或组 ID，可以使用  <code>setuid</code>  和  <code>setgid</code>  函数，但这些操作需要管理员权限或特定的安全策略。</li>
<li>在多线程环境中， <code>getuid</code>  返回的是整个进程的真实用户 ID，而不是特定线程的 ID。</li>
</ul>
<p><code>getuid</code>  是一个简单但非常重要的系统调用，它为程序提供了识别和校验用户身份的能力。</p>
<h4 id="getgid-获取真实组-id"><a class="anchor" href="#getgid-获取真实组-id">#</a>  <code>getgid</code>  获取真实组 ID</h4>
<p><code>getgid</code>  函数是 POSIX 标准中用于获取当前进程的真实组 ID（GID）的系统调用。与  <code>getuid</code>  类似， <code>getgid</code>  提供了进程启动时所使用的用户组身份信息。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">gid_t</span> <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>getgid</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回当前进程的真实组 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>真实组 ID 是指进程启动时所具有的组 ID。在 UNIX 和类 UNIX 系统中，这个 ID 同样用于权限控制，与用户 ID 一起决定了进程可以访问的资源。</p>
<p>以下是使用  <code>getgid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">gid_t</span> gid <span class="token operator">=</span> <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的真实组 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The real group ID of this process is: %d\n"</span><span class="token punctuation">,</span> gid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>getgid</code>  来获取当前进程的真实组 ID，并将其打印出来。</p>
<p>使用  <code>getgid</code>  时需要注意的事项：</p>
<ul>
<li><code>getgid</code>  通常与  <code>getuid</code>  结合使用，以确定进程的完整用户和组权限。</li>
<li>与  <code>getuid</code>  一样，如果程序需要改变其有效用户 ID 或组 ID，可以使用  <code>setgid</code>  函数，但这通常需要管理员权限或特定的安全策略。</li>
<li>在多线程环境中， <code>getgid</code>  返回的是整个进程的真实组 ID，而不是特定线程的 ID。</li>
</ul>
<p><code>getgid</code>  是一个重要的系统调用，它允许程序识别和校验进程所属的用户组，从而进行适当的权限控制和资源访问管理。</p>
<h4 id="geteuid-获取有效用户-id"><a class="anchor" href="#geteuid-获取有效用户-id">#</a>  <code>geteuid</code>  获取有效用户 ID</h4>
<p><code>geteuid</code>  函数是 POSIX 标准中用于获取当前进程的有效用户 ID（EUID）的系统调用。有效用户 ID 是进程执行操作时用于权限检查的用户 ID。在某些情况下，有效用户 ID 可能与进程的真实用户 ID（由  <code>getuid</code>  获取）不同，例如，当进程使用了设置用户 ID 的文件或调用了  <code>setuid</code>  函数改变了其有效用户 ID。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">uid_t</span> <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>geteuid</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回当前进程的有效用户 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>有效用户 ID 常用于以下几种情况：</p>
<ul>
<li>执行文件时，如果文件具有设置用户 ID 的权限位（setuid 位），则进程的有效用户 ID 将设置为文件的所有者 ID。</li>
<li>进程使用  <code>setuid</code>  函数显式地改变了其有效用户 ID。</li>
</ul>
<p>以下是使用  <code>geteuid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">uid_t</span> euid <span class="token operator">=</span> <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的有效用户 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The effective user ID of this process is: %d\n"</span><span class="token punctuation">,</span> euid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>geteuid</code>  来获取当前进程的有效用户 ID，并将其打印出来。</p>
<p>使用  <code>geteuid</code>  时需要注意的事项：</p>
<ul>
<li>如果进程没有改变其有效用户 ID， <code>geteuid</code>  通常返回与  <code>getuid</code>  相同的值。</li>
<li>在权限管理中，有效用户 ID 通常用于确定进程是否可以执行需要特定权限的操作。</li>
<li>与  <code>getuid</code>  和  <code>getgid</code>  一样，在多线程环境中， <code>geteuid</code>  返回的是整个进程的有效用户 ID，而不是特定线程的 ID。</li>
</ul>
<p><code>geteuid</code>  是一个重要的系统调用，它为程序提供了识别当前权限上下文的能力，有助于进行安全检查和权限管理。</p>
<h4 id="getegid-获取有效组-id"><a class="anchor" href="#getegid-获取有效组-id">#</a>  <code>getegid</code>  获取有效组 ID</h4>
<p><code>getegid</code>  函数是 POSIX 标准中用于获取当前进程的有效组 ID（EGID）的系统调用。有效组 ID 是进程执行操作时用于权限检查的组 ID。类似于有效用户 ID，有效组 ID 可能与进程的真实组 ID（由  <code>getgid</code>  获取）不同，在某些情况下，例如当进程使用了设置组 ID 的文件或调用了  <code>setgid</code>  函数改变了其有效组 ID。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">gid_t</span> <span class="token function">getegid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>getegid</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回当前进程的有效组 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>有效组 ID 常用于以下几种情况：</p>
<ul>
<li>执行文件时，如果文件具有设置组 ID 的权限位（setgid 位），则进程的有效组 ID 将设置为文件的组所有者 ID。</li>
<li>进程使用  <code>setgid</code>  函数显式地改变了其有效组 ID。</li>
</ul>
<p>以下是使用  <code>getegid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">gid_t</span> egid <span class="token operator">=</span> <span class="token function">getegid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的有效组 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The effective group ID of this process is: %d\n"</span><span class="token punctuation">,</span> egid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>getegid</code>  来获取当前进程的有效组 ID，并将其打印出来。</p>
<p>使用  <code>getegid</code>  时需要注意的事项：</p>
<ul>
<li>如果进程没有改变其有效组 ID， <code>getegid</code>  通常返回与  <code>getgid</code>  相同的值。</li>
<li>在权限管理中，有效组 ID 通常用于确定进程是否可以访问需要特定组权限的资源。</li>
<li>与  <code>getuid</code>  和  <code>getgid</code>  一样，在多线程环境中， <code>getegid</code>  返回的是整个进程的有效组 ID，而不是特定线程的 ID。</li>
</ul>
<p><code>getegid</code>  是一个重要的系统调用，它允许程序识别当前的组权限上下文，有助于进行安全检查和权限管理。</p>
<h4 id="getpgrp-获取进程组-id"><a class="anchor" href="#getpgrp-获取进程组-id">#</a>  <code>getpgrp</code>  获取进程组 ID</h4>
<p><code>getpgrp</code>  函数是 POSIX 标准中用于获取调用进程的进程组 ID（Process Group ID，PGRP）的系统调用。进程组是一个或多个进程的集合，通常用于作业控制。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>getpgrp</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回调用进程的进程组 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>进程组 ID 是一个正整数，用于标识一个进程组。每个进程都属于一个进程组，通常进程组 ID 与进程的会话（session）ID 相同。进程组的概念在多用户环境中非常有用，特别是用于信号的发送和管理。</p>
<p>以下是使用  <code>getpgrp</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">pid_t</span> pgrp <span class="token operator">=</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的进程组 ID</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The process group ID of this process is: %d\n"</span><span class="token punctuation">,</span> pgrp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>getpgrp</code>  来获取当前进程的进程组 ID，并将其打印出来。</p>
<p>使用  <code>getpgrp</code>  时需要注意的事项：</p>
<ul>
<li>进程组 ID 通常用于在 shell 脚本和程序中管理作业。</li>
<li>可以通过  <code>setpgid</code>  函数改变进程的进程组 ID，这通常需要特定的权限。</li>
<li><code>getpgrp</code>  返回的进程组 ID 可以用于使用  <code>killpg</code>  函数向整个进程组发送信号。</li>
<li>在多线程环境中， <code>getpgrp</code>  返回的是当前线程所属进程的进程组 ID。</li>
</ul>
<p><code>getpgrp</code>  是一个有用的系统调用，它为程序提供了识别和管理系统进程组的能力，有助于进行有效的作业管理和信号处理。</p>
<h4 id="setpgid-设置进程组-id"><a class="anchor" href="#setpgid-设置进程组-id">#</a>  <code>setpgid</code>  设置进程组 ID</h4>
<p><code>setpgid</code>  函数是 POSIX 标准中用于设置一个进程的进程组 ID 的系统调用。使用  <code>setpgid</code>  可以创建新的进程组或将进程移动到现有的进程组。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> pgid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>pid</code> ：要设置进程组 ID 的进程的 PID。如果  <code>pid</code>  等于  <code>0</code> ，则使用调用进程的 PID。</li>
<li><code>pgid</code> ：新的进程组 ID。如果  <code>pgid</code>  等于  <code>pid</code> ，则创建一个新的进程组，并将  <code>pid</code>  指定的进程作为该组的领导进程。</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>如果调用失败，返回  <code>-1</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>以下是  <code>setpgid</code>  函数的一些关键点：</p>
<ul>
<li>只有进程的父进程或具有适当权限的进程才能改变进程的进程组 ID。</li>
<li>进程组 ID 一旦设置，除非是该进程组的领导进程，否则不能被改变。</li>
<li>进程组的领导进程可以是该组内任何进程，但一旦设置，就不能改变。</li>
<li>进程创建时，默认的进程组 ID 与父进程的进程组 ID 相同。</li>
</ul>
<p>使用  <code>setpgid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建子进程</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">//fork 调用失败</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 子进程中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">pid_t</span> new_pgid <span class="token operator">=</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程组 ID</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process with PID %d is in process group %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new_pgid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 尝试创建新的进程组并将自己设为领导进程</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setpgid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 再次获取新的进程组 ID</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        new_pgid <span class="token operator">=</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process with PID %d is now the leader of process group %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> new_pgid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 父进程中等待子进程结束</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmYzc2RDBrWjR4TmhGNWxybEFBbklNQnBDaXNfcjN2VEM2SV9HOVdDdDQ5ZkE_ZT1JTnFxVlM.png" alt="" /></p>
<p>在上面的例子中，父进程创建了一个子进程。子进程首先打印其当前的进程组 ID，然后尝试使用  <code>setpgid</code>  创建一个新的进程组，并将自身设为该组的领导进程。如果操作成功，子进程将再次打印其新的进程组 ID。</p>
<p>使用  <code>setpgid</code>  时需要注意的事项：</p>
<ul>
<li>使用  <code>setpgid</code>  可以影响进程接收信号的方式，因为信号可以按进程组发送。</li>
<li>在某些系统中，只有超级用户或具有  <code>CAP_SYS_NICE</code>  权限的用户才能将进程移动到其他进程组。</li>
<li>进程组的概念在多用户环境中非常有用，尤其是在 shell 脚本和作业控制中。</li>
</ul>
<h4 id="getsid-获取调用进程的会话-id"><a class="anchor" href="#getsid-获取调用进程的会话-id">#</a>  <code>getsid</code>  获取调用进程的会话 ID</h4>
<p><code>getsid</code>  函数是 POSIX 标准中用于获取调用进程的会话 ID（Session ID）的系统调用。每个进程都属于一个会话，会话是一个或多个进程的集合，通常由一个控制终端、作业控制和登录记录组成。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pid_t</span> <span class="token function">getsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>getsid</code>  函数不接受任何参数。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回调用进程的会话 ID。</li>
<li>如果调用失败，返回  <code>(-1)</code> ，并设置全局变量  <code>errno</code>  以指示错误。</li>
</ul>
<p>会话 ID 是一个正整数，用于标识一个会话。每个会话都有一个唯一的会话 ID，并且每个会话都有一个或多个进程组，其中至少有一个进程组是会话的 “领导” 进程组。</p>
<p>以下是使用  <code>getsid</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name">pid_t</span> sid <span class="token operator">=</span> <span class="token function">getsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程的会话 ID</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The session ID of this process is: %d\n"</span><span class="token punctuation">,</span> sid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们调用  <code>getsid</code>  来获取当前进程的会话 ID，并将其打印出来。</p>
<p>使用  <code>getsid</code>  时需要注意的事项：</p>
<ul>
<li>会话的概念在多用户环境中非常有用，尤其是在终端会话和作业控制中。</li>
<li>一个会话通常由一个登录 shell 创建，并且该 shell 进程是会话的领导进程。</li>
<li>会话的领导进程可以创建新的进程组，并且这些进程组都属于同一个会话。</li>
<li><code>getsid</code>  返回的会话 ID 可以用于使用  <code>killpg</code>  函数向整个会话发送信号。</li>
</ul>
<p><code>getsid</code>  是一个有用的系统调用，它为程序提供了识别和管理系统会话的能力，有助于进行有效的作业管理和信号处理。</p>
<h3 id="syslog-系统日志"><a class="anchor" href="#syslog-系统日志">#</a>  <code>syslog</code>  系统日志</h3>
<p><code>syslog</code>  函数是 UNIX 和类 UNIX 系统中用于发送消息到系统日志守护进程  <code>syslogd</code>  的标准 API 函数。这个函数允许程序将日志消息记录到系统日志中，与其他日志记录方式相比， <code>syslog</code>  提供了一种集中式、可配置的日志记录解决方案。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">syslog</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>priority</code> ：一个整数，表示日志消息的优先级。优先级是两个部分的组合 ——&quot;等级&quot; 和 &quot;设施&quot;。等级（如 LOG_EMERG, LOG_ALERT, LOG_CRIT 等）表示消息的紧急程度，设施（如 LOG_USER, LOG_DAEMON 等）表示消息的来源类型。</li>
<li><code>message</code> ：一个格式字符串，遵循  <code>printf</code>  风格，指定了要记录的消息格式。</li>
<li><code>...</code> ：一系列可选参数，提供给  <code>message</code>  字符串的格式说明符。</li>
</ol>
<p>功能： <code>syslog</code>  函数将程序的输出消息发送到系统日志，通常由  <code>syslogd</code>  守护进程处理。这些消息可以被配置为记录到不同的目的地，如控制台、文件或其他地方。</p>
<p>返回值： <code>syslog</code>  函数不返回任何值（ <code>void</code>  类型）。</p>
<p>以下是使用  <code>syslog</code>  函数的一个例子：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 打开 syslog，标识为当前程序名</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">openlog</span><span class="token punctuation">(</span><span class="token string">"my_program"</span><span class="token punctuation">,</span> LOG_PID<span class="token punctuation">,</span> LOG_USER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 记录一条信息性消息</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">syslog</span><span class="token punctuation">(</span>LOG_INFO<span class="token punctuation">,</span> <span class="token string">"This is an informational message."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 记录一条错误消息</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">syslog</span><span class="token punctuation">(</span>LOG_ERR<span class="token punctuation">,</span> <span class="token string">"This is an error message."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 关闭 syslog</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">closelog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中，我们首先使用  <code>openlog</code>  函数初始化  <code>syslog</code> ，指定了程序名、进程 ID 记录选项和消息设施。然后，我们使用  <code>syslog</code>  函数记录了两条消息，一条是信息性消息，另一条是错误消息。最后，我们使用  <code>closelog</code>  函数关闭了  <code>syslog</code> 。</p>
<p>使用  <code>syslog</code>  时需要注意的事项：</p>
<ul>
<li>通常在程序开始时调用  <code>openlog</code>  并设置适当的参数，程序结束时调用  <code>closelog</code> 。</li>
<li><code>syslog</code>  可以处理不同级别的日志消息，根据配置，这些消息可以被发送到不同的地方。</li>
<li>消息的优先级可以根据需要设置，以确定消息的重要性。</li>
<li>系统日志的配置通常在  <code>/etc/syslog.conf</code>  或  <code>/etc/rsyslog.conf</code>  等配置文件中设置。</li>
</ul>
<p><code>syslog</code>  是一种灵活的日志记录方式，适用于需要将日志消息集中管理和配置的应用程序。</p>
<div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i>C</a><a href="/tags/linux/" rel="tag"><i class="ic i-tag"></i>Linux</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-12-14 20:06:51" itemprop="dateModified" datetime="2024-12-14T20:06:51+08:00">2024-12-14</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="https://cwlrin.wiki/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Linux 进程（下）">https://cwlrin.wiki/c-cpp/linux-c/Linux 进程（下）/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="prev" itemprop="url" title="Linux 进程（上）" style="background-image: linear-gradient(to bottom right, #fda18d, #aaa09f);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Linux C</span><h3>Linux 进程（上）</h3></a></div><div class="item right"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="next" itemprop="url" title="Linux 进程间通信" style="background-image: linear-gradient(to bottom right, #dcfec2, #9cc3b0);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>Linux C</span><h3>Linux 进程间通信</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text"> 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text"> 孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 僵尸进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%A8%E6%88%B7-id-%E5%92%8C%E7%BB%84-id"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程的用户 ID 和组 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7-id-%E5%92%8C%E7%BB%84-id"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程的有效用户 ID 和组 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">2.3.</span> <span class="toc-text"> 文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setuidset-user-id-upon-execution"><span class="toc-number">2.3.1.</span> <span class="toc-text"> SetUID（Set User ID upon execution）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setgidset-group-id-upon-execution"><span class="toc-number">2.3.2.</span> <span class="toc-text"> SetGID（Set Group ID upon execution）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sticky-%E4%BD%8D"><span class="toc-number">2.3.3.</span> <span class="toc-text"> Sticky 位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 修改文件权限和所有权</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-number">2.5.</span> <span class="toc-text"> 终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">2.6.</span> <span class="toc-text"> 会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%89%B9%E7%82%B9"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 会话特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D-id"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 会话 ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-2"><span class="toc-number">2.7.</span> <span class="toc-text"> 守护进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-shell-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text"> Linux shell 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">  ps  指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-elfunix-system-v-%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.1.</span> <span class="toc-text">  ps -elf （UNIX System V 风格）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-auxunix-bsd-%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.2.</span> <span class="toc-text">  ps aux （UNIX BSD 风格）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">  free  指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98mem"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 物理内存（Mem）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4swap"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 交换空间（Swap）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">  top  指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%83%85%E5%86%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 系统情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%83%85%E5%86%B5tasks"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 任务情况（Tasks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5cpu"><span class="toc-number">3.3.3.</span> <span class="toc-text"> CPU 使用情况（% CPU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 内存使用情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8%E9%83%A8%E5%88%86"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 进程列表部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pid"><span class="toc-number">3.4.</span> <span class="toc-text">  PID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.</span> <span class="toc-text">  Kill  命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E5%8F%B0%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 进程的前台与后台状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-kill-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 使用  kill  命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 后台进程的启动与管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.4.</span> <span class="toc-text"> 后台任务的管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-c-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text"> Linux C 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-%E6%89%A7%E8%A1%8C-shell-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">  system  执行 shell 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-%E5%A4%8D%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">  fork  复制进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 内存复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 写时复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%92%8C-fork"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 文件打开和  fork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="toc-number">4.3.</span> <span class="toc-text">  exec  函数替换进程映像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execl-%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">  execl  函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execv-%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">  execv  函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text"> 退出进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exit-%E7%BB%88%E6%AD%A2%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">  exit  终止当前进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#_exit-%E7%BB%88%E6%AD%A2%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">  _Exit  终止当前进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#_exit-%E7%BB%88%E6%AD%A2%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B-2"><span class="toc-number">4.4.3.</span> <span class="toc-text">  _exit   终止当前进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort-%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.4.</span> <span class="toc-text">  abort   异常终止当前进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.</span> <span class="toc-text">  wait  等待子进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitpid-%E6%A3%80%E6%9F%A5%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.6.</span> <span class="toc-text">  waitpid  检查子进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7-id"><span class="toc-number">4.7.</span> <span class="toc-text"> 用户 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getuid-%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E7%94%A8%E6%88%B7-id"><span class="toc-number">4.7.1.</span> <span class="toc-text">  getuid   获取真实用户 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getgid-%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E7%BB%84-id"><span class="toc-number">4.7.2.</span> <span class="toc-text">  getgid  获取真实组 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#geteuid-%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E7%94%A8%E6%88%B7-id"><span class="toc-number">4.7.3.</span> <span class="toc-text">  geteuid  获取有效用户 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getegid-%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E7%BB%84-id"><span class="toc-number">4.7.4.</span> <span class="toc-text">  getegid  获取有效组 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getpgrp-%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%BB%84-id"><span class="toc-number">4.7.5.</span> <span class="toc-text">  getpgrp  获取进程组 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setpgid-%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E7%BB%84-id"><span class="toc-number">4.7.6.</span> <span class="toc-text">  setpgid  设置进程组 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getsid-%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%9A%E8%AF%9D-id"><span class="toc-number">4.7.7.</span> <span class="toc-text">  getsid  获取调用进程的会话 ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syslog-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">4.8.</span> <span class="toc-text">  syslog  系统日志</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/linux-c/Linux%20C%20%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Linux C 基础">Linux C 基础</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E6%9D%82%E9%A1%B9/" rel="bookmark" title="Linux 杂项">Linux 杂项</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%9B%AE%E5%BD%95%E6%B5%81/" rel="bookmark" title="Linux 目录流">Linux 目录流</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E6%96%87%E4%BB%B6%E6%B5%81/" rel="bookmark" title="Linux 文件流">Linux 文件流</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%AE%A1%E9%81%93%E5%92%8C%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="bookmark" title="Linux 管道和 IO 多路复用">Linux 管道和 IO 多路复用</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="bookmark" title="Linux 进程（上）">Linux 进程（上）</a></li><li  class="active"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="bookmark" title="Linux 进程（下）">Linux 进程（下）</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="bookmark" title="Linux 进程间通信">Linux 进程间通信</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E4%BF%A1%E5%8F%B7/" rel="bookmark" title="Linux 信号">Linux 信号</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="Linux 线程">Linux 线程</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/" rel="bookmark" title="Linux 线程的同步和互斥.md">Linux 线程的同步和互斥.md</a></li><li ><a href="/c-cpp/linux-c/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="bookmark" title="网络协议">网络协议</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Linux 网络编程">Linux 网络编程</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E6%B1%A0/" rel="bookmark" title="Linux 进程池">Linux 进程池</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">97</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">14</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.5m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">22:27</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `c-cpp/linux-c/Linux 进程（下）/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.20" type="module" fetchpriority="high" defer></script></body></html>