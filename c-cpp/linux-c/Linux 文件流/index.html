<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="http://cwlrin.wiki/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.20"><link rel="modulepreload" href="/js/chunk-NPDU2HRQ.js"></link><link rel="modulepreload" href="/js/chunk-R2ID445Y.js"></link><link rel="modulepreload" href="/js/chunk-YHPSMGA6.js"></link><link rel="modulepreload" href="/js/copy-tex-2AKW2INC.js"></link><link rel="modulepreload" href="/js/index.esm-TLZT3I4E.js"></link><link rel="modulepreload" href="/js/post-AWU7OAKV.js"></link><link rel="modulepreload" href="/js/quicklink-3TNKEFE4.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWQ0VqZGFJSVk5SnBPSFFMaFNXWm1vQmNuVWx1VFNWQmZQUndmdzZFc05YS0E_ZT1kTW84QnA.jpg" as="image" fetchpriority="high"><meta name="keywords" content="C,"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="http://cwlrin.wiki/c-cpp/linux-c/Linux%20%E6%96%87%E4%BB%B6%E6%B5%81/"><title>Linux 文件流</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Linux 文件流</h1><div class="meta"><span class="item" title="创建时间：2020-08-18 22:50:27"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-08-18T22:50:27+08:00">2020-08-18</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>19k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWQ0VqZGFJSVk5SnBPSFFMaFNXWm1vQmNuVWx1VFNWQmZQUndmdzZFc05YS0E_ZT1kTW84QnA.jpg" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/linux-c/" itemprop="item" rel="index" title="分类于Linux C"><span itemprop="name">Linux C<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://cwlrin.wiki/c-cpp/linux-c/Linux%20%E6%96%87%E4%BB%B6%E6%B5%81/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="无缓冲文件流"><a class="anchor" href="#无缓冲文件流">#</a> 无缓冲文件流</h2>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYMG0tNk93QmtGT2tyb1gwVjZmb0djQkFRZnFrSENBOHZEUzJKZTBoQVlKb2c_ZT1tVW5xanM.png" alt="202403111946151.png" /></p>
<p><strong>带用户态缓冲区的文件流</strong>：</p>
<ul>
<li>这类文件流属于语言的库函数，是对系统调用的封装。</li>
<li>它们使用用户态缓冲区来减少系统调用的次数，提高 I/O 操作的效率。</li>
<li>用户程序通过缓冲区与文件进行交互，而不需要直接进行系统调用。</li>
</ul>
<p><strong>用户态缓冲区的作用</strong>：</p>
<ul>
<li>用户态缓冲区作为数据传输的中间层，由语言的标准库管理。</li>
<li>它的存在简化了用户程序的 I/O 操作，因为用户程序不需要关心缓冲区的内部管理。</li>
</ul>
<p><strong>无缓冲的文件 I/O</strong>：</p>
<ul>
<li>在某些情况下，应用程序可能需要直接与内核进行数据交互，而不是通过用户态缓冲区。</li>
<li>无缓冲的 I/O 通常使用系统调用直接进行，这种 I/O 操作方式可以提供更直接的控制，但可能牺牲一些性能。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTd0VEblZsWXVGRHFVSkMzNENMUHNnQmdNTERJS2FwWWlRaTVQOGJEWkJjdnc_ZT00aGZMREg.png" alt="202403112033127.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0Vac2VyRDZ4LS1OQWhLVkg2anRFUC1VQmV3ZWFWRFN3RkZxZUNRcXFibHVSVUE_ZT1OOHZQeFk.png" alt="202403111946151.png" /></p>
<p>在传统的文件 I/O 操作中，通常使用带用户态缓冲区的文件流，如通过  <code>fopen</code>  等 C 语言库函数实现。这些函数对系统调用进行了封装，引入了用户态缓冲区，使得用户进程与内核之间的数据交互更加高效和方便。</p>
<p>用户态缓冲区由 C 语言标准库创建和管理，它的大小通常为 4KB 或 8KB。这种缓冲区起到了数据的 “中间商” 作用，内核中的数据首先流入这个缓冲区，然后再传输到用户自己申请的内存中。通过这种方式，一次系统调用可以交换大量数据，从而减少了系统调用的次数，提升了 I/O 操作的性能。</p>
<p>然而，在某些场景下，我们可能不希望有这个中间商的存在。例如，在需要直接与内核进行数据交互的场合，或者在对性能要求极高的应用中，用户进程希望能够绕过用户态缓冲区，直接进行系统调用。这时，就需要使用不带用户态缓冲区的文件流，也就是无缓冲 I/O。</p>
<p>无缓冲 I/O，或称为直接 I/O，是一种不通过用户态缓冲区进行数据交互的 I/O 操作方式。在这种方式下，用户进程直接与内核态缓冲区进行交互，绕过了用户态缓冲区。这种方式可以减少数据复制的开销，提高数据传输效率，但也要求用户进程更加谨慎地管理数据的读取和写入。</p>
<p>在无缓冲 I/O 中，用户进程需要自己申请内存空间用于存储从磁盘读取的数据或待写入磁盘的数据。然后，通过系统调用直接与内核态缓冲区进行数据交换，实现纯粹的内存数据交互。</p>
<p>带用户态缓冲区的文件流和无缓冲 I/O 各有适用场景。前者通过用户态缓冲区简化了 I/O 操作，提高了性能；后者则提供了更直接、更高效的数据交互方式，适用于对性能要求极高的应用。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWMVBPS293V0xSQ2pKd2UydWtSa2owQmFvcVk5Q05jZk1oZ3NNNGZWVHFpT2c_ZT1BWDNuU0s.png" alt="202403112227975.png" /></p>
<p>在操作系统中，内核区域负责管理文件系统和磁盘设备。为了实现高效的数据交互，内核区域使用了一系列关键概念和数据结构。每个文件在内核中都由一个 “文件对象” 来表示，它是一个临时存储文件数据的数据结构。文件对象内部包含一个 “内核缓冲区”，用于暂存从磁盘读取的数据或待写入磁盘的数据，并通过一个指针来跟踪当前的读写位置。</p>
<p>由于安全和设计的原因，内核缓冲区不能直接暴露给用户进程。因此，内核维护了一个 “索引指针数组”，用于间接地管理文件对象。索引指针数组中的每个元素都是指向一个文件对象的指针，而数组元素的下标，即 “文件描述符”，作为文件的唯一标识符，用于用户进程与内核之间的交互。</p>
<p>文件描述符是一个非常重要的概念，它允许用户进程通过一个整数来引用特定的文件对象。用户进程通过文件描述符与内核进行系统调用交互，实现无缓冲 I/O 操作。例如，当用户进程需要读取文件数据时，它会通过文件描述符请求内核从磁盘读取数据到内核缓冲区，然后再从内核缓冲区复制到用户空间的缓冲区。</p>
<p>在用户空间，应用程序通常会分配一个缓冲区用于存储与文件交互的数据。通过这种方式，用户进程可以避免直接与内核缓冲区交互，从而简化了编程模型并提高了安全性。</p>
<p>内核区域通过文件对象、内核缓冲区、索引指针数组和文件描述符等机制，实现了对文件的高效管理和用户进程的安全交互。用户进程通过文件描述符与内核进行无缓冲 I/O 操作，这种方式在某些场景下可以提高数据交换的效率，尤其是在对性能要求极高的应用中。</p>
<p><strong>关于文件描述符：</strong></p>
<p>当用户在 Linux 系统中打开一个文件时，内核会创建一个对应的文件对象。这个文件对象是内核用来临时存储和操作文件数据的数据结构。为了安全和组织的原因，内核并不直接将文件对象返回给用户进程，而是为每个文件对象分配一个唯一的编号，即文件描述符。</p>
<p>文件描述符的分配是通过一个索引指针数组来管理的。数组中的每个元素都是一个指针，指向一个文件对象。当用户打开文件时，内核会返回数组中新分配的元素的下标，这个下标就是文件描述符。用户进程随后使用这个文件描述符来执行系统调用级别的文件操作，如读取、写入和关闭文件。</p>
<p><strong>安全性</strong>： 使用文件描述符的方式提高了安全性，因为在整个过程中，用户进程没有获得内核的任何地址信息，也没有与内核区域进行直接的数据交互。这种间接的交互方式限制了用户进程对内核的操作，从而减少了潜在的安全风险。</p>
<p><strong>系统调用</strong>： 用户进程通过文件描述符与内核进行系统调用级别的交互。例如， <code>read()</code>  和  <code>write()</code>  系统调用使用文件描述符来确定要操作的文件，而  <code>close()</code>  系统调用使用文件描述符来关闭文件。</p>
<p><strong>文件描述符的限制</strong>： 文件描述符的数量是有限的，通常由系统设置的最大文件描述符数量决定。这意味着一个进程能够同时打开的文件数量是有限的。</p>
<p>文件描述符是用户进程与操作系统内核交互的桥梁，它提供了一种安全、间接的方式来访问和管理文件。通过使用文件描述符，用户进程可以在不同的系统调用中指定要操作的文件，而无需直接与内核缓冲区交互。</p>
<h2 id="文件流相关函数"><a class="anchor" href="#文件流相关函数">#</a> 文件流相关函数</h2>
<h3 id="open-打开文件系统调用"><a class="anchor" href="#open-打开文件系统调用">#</a>  <code>open</code>  打开文件系统调用</h3>
<p><code>open</code>  函数是 POSIX 标准中用于打开文件的系统调用，其原型在  <code>fcntl.h</code>  头文件中声明。 <code>open</code>  函数提供了两种重载形式，一种接受两个参数，另一种接受三个参数。</p>
<p>第一种形式：接受两个参数</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li>
<p><code>pathname</code> ：一个指向以 null 结尾的字符串的指针，指定了要打开的文件的路径。</p>
</li>
<li>
<p><code>flags</code> ：一个或多个标志的组合，用来指定文件打开的方式。这些标志包括：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th style="text-align:left">描述 / 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>O_RDONLY</strong></td>
<td style="text-align:left">以只读的方式打开</td>
</tr>
<tr>
<td><strong>O_WRONLY</strong></td>
<td style="text-align:left">以只写的方式打开</td>
</tr>
<tr>
<td><strong>O_RDWR</strong></td>
<td style="text-align:left">以可读可写的方式打开</td>
</tr>
<tr>
<td><strong>O_CREAT</strong></td>
<td style="text-align:left">如果文件不存在，则创建文件。<strong>如果不添加此标志，那么文件不存在时，将打开失败</strong></td>
</tr>
<tr>
<td><strong>O_EXCL</strong></td>
<td style="text-align:left"><strong>仅与 O_CREAT 连用</strong>，单独使用无意义。<strong>如果文件已存在，则 open 失败</strong></td>
</tr>
<tr>
<td><strong>O_TRUNC</strong></td>
<td style="text-align:left">如果文件已存在且成功以写入模式打开，则将其长度截断为 0，即删除文件内容。</td>
</tr>
<tr>
<td><strong>O_APPEND</strong></td>
<td style="text-align:left">以追加模式打开文件，不能和 <strong>O_RDONLY</strong> 或者 <strong>O_TRUNC</strong> 连用。</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时，返回一个非负的文件描述符（FD），用于在后续操作中引用该文件。</li>
<li>失败时，返回  <code>-1</code> ，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p>第二种形式：接受三个参数</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>除了包含第一种形式的所有参数外，还增加了：</p>
<p><code>mode</code> ：当创建新文件时，此参数指定文件的权限模式。 <code>mode_t</code>  类型通常定义在  <code>&lt;sys/types.h&gt;</code>  头文件中。这个模式通常由文件系统上的 umask 值修改。</p>
<p>这个形式的  <code>open</code>  函数在指定要创建新文件的情况下非常有用，它允许你设置新文件的权限。</p>
<p>关于  <code>flags</code>  的宏标志：</p>
<p>当用户打开文件时，Linux 系统内核会根据提供的  <code>flags</code>  参数创建相应的文件对象。 <code>flags</code>  参数是一个 32 位的整数，每一位的设置代表不同的文件打开行为。</p>
<p>在设置文件打开模式时，需要使用位运算符按位或（ <code>|</code> ）来组合多个宏标志。然而，并非所有宏标志都可以组合使用。例如， <code>O_RDONLY</code> 、 <code>O_WRONLY</code>  和  <code>O_RDWR</code>  这三个访问模式标志是互斥的，只能选择其中一个来确定文件的访问方式。它们通常使用 32 位整数的低 2 位来表示，确保了它们的互斥性。</p>
<p>另外，某些宏标志的组合有特定的限制。 <code>O_APPEND</code>  标志只能与允许写入的模式（ <code>O_WRONLY</code>  或  <code>O_RDWR</code> ）一起使用，因为它用于将数据追加到文件末尾。同时， <code>O_APPEND</code>  与  <code>O_TRUNC</code>  是冲突的，因为  <code>O_TRUNC</code>  用于截断文件，而  <code>O_APPEND</code>  用于在文件末尾追加数据。</p>
<p><code>fopen</code>  函数是 C 语言中用于打开文件的标准库函数，它的行为依赖于传入的模式参数。这些模式实际上是通过组合不同的宏标志来控制文件的打开方式：</p>
<ul>
<li><code>&quot;r&quot;</code> ：以只读方式打开文件，等同于  <code>O_RDONLY</code> 。</li>
<li><code>&quot;r+&quot;</code> ：以读写方式打开文件，等同于  <code>O_RDWR</code> 。</li>
<li><code>&quot;w&quot;</code> ：以只写方式打开文件，如果文件存在则截断文件，等同于  <code>O_WRONLY | O_CREAT | O_TRUNC</code> 。</li>
<li><code>&quot;w+&quot;</code> ：以读写方式打开文件，如果文件存在则截断文件，等同于  <code>O_RDWR | O_CREAT | O_TRUNC</code> 。</li>
<li><code>&quot;a&quot;</code> ：以追加模式打开文件，等同于  <code>O_WRONLY | O_CREAT | O_APPEND</code> 。</li>
<li><code>&quot;a+&quot;</code> ：以读写追加模式打开文件，等同于  <code>O_RDWR | O_CREAT | O_APPEND</code> 。</li>
</ul>
<h3 id="close-关闭文件系统调用"><a class="anchor" href="#close-关闭文件系统调用">#</a>  <code>close</code>  关闭文件系统调用</h3>
<p><code>close</code>  函数是 POSIX 标准中用于关闭文件描述符（file descriptor，FD）的系统调用，其原型在  <code>unistd.h</code>  头文件中声明。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>fd</code> ：文件描述符，是一个非负整数，表示要关闭的文件或设备。</p>
<p>功能： <code>close</code>  函数关闭指定的文件描述符，释放与该文件描述符相关的所有资源。</p>
<p>返回值：</p>
<ul>
<li>如果函数成功执行，返回 0。</li>
<li>如果函数执行失败，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p>使用  <code>close</code>  函数时，应当总是在文件操作完成后调用它，以确保及时释放系统资源。文件描述符是操作系统用来跟踪打开文件和网络连接等资源的整数。当程序不再需要这些资源时，使用  <code>close</code>  函数可以防止资源泄露。</p>
<h3 id="read-读取文件系统调用"><a class="anchor" href="#read-读取文件系统调用">#</a>  <code>read</code>  读取文件系统调用</h3>
<p><code>read</code>  函数是 POSIX 标准中用于从指定的文件描述符（file descriptor，FD）读取数据的系统调用，其原型在  <code>unistd.h</code>  头文件中声明。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>fd</code> ：文件描述符，是一个非负整数，表示要读取数据的文件或设备。</li>
<li><code>buf</code> ：指向一个内存缓冲区的指针， <code>read</code>  函数会将读取的数据存储在这个缓冲区中。缓冲区的大小应该足够大，以容纳  <code>count</code>  参数指定的字节数。</li>
<li><code>count</code> ：要读取的字节数。</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时， <code>read</code>  函数返回实际读取的字节数，这个值通常小于或等于  <code>count</code> 。如果已到达文件末尾（end-of-file，EOF），并且没有更多数据可读，它将返回 0。</li>
<li>如果函数执行失败，返回  <code>-1</code> ，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><code>ssize_t</code>  是一个可签名的整数类型，用于表示有符号的大小，它可以表示负数，这在出现错误时很有用。</p>
<p><code>read</code>  和  <code>fread</code>  函数的差异：</p>
<p><code>read</code>  和  <code>fread</code>  函数是两种不同的文件读取方法，它们在读取数据时的计量单位和行为上存在以下差异</p>
<ol>
<li><strong>计量单位</strong>： <code>read</code>  函数读取的是字节数量，它只接受一个表示数量的参数，即  <code>count</code> ，表示一次性读取多少个字节的数据。</li>
<li><strong>参数差异</strong>： <code>fread</code>  函数读取的是元素的数量，它接受两个表示数量的参数： <code>size</code>  和  <code>count</code> 。其中  <code>size</code>  表示每个元素的大小，而  <code>count</code>  表示一次性读取的元素个数。</li>
<li><strong>返回值类型</strong>： <code>fread</code>  函数返回的是  <code>size_t</code>  类型，即无符号整数，表示一次性读取到的元素个数。当函数读到文件末尾或调用出错时，返回 0。</li>
<li><strong> <code>read</code>  函数的返回值</strong>： <code>read</code>  函数返回的是  <code>ssize_t</code>  类型，即有符号整数，表示一次性读取到的字节数量。当函数读到文件末尾时返回 0，表示已经读取完毕；函数出错时返回 - 1。</li>
<li><strong>写入函数的差异性</strong>：类似地， <code>write</code>  和  <code>fwrite</code>  函数在写入数据时也存在类似的差异。 <code>write</code>  函数写入字节，而  <code>fwrite</code>  函数写入元素，它们的行为和返回值类型与  <code>read</code>  和  <code>fread</code>  相对应。</li>
</ol>
<h3 id="write-写入文件系统调用"><a class="anchor" href="#write-写入文件系统调用">#</a>  <code>write</code>  写入文件系统调用</h3>
<p><code>write</code>  函数是 POSIX 标准中用于向指定的文件描述符（file descriptor，FD）写入数据的系统调用，其原型同样在  <code>unistd.h</code>  头文件中声明。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>fd</code> ：文件描述符，是一个非负整数，表示要写入数据的文件或设备。</li>
<li><code>buf</code> ：指向要写入的数据缓冲区的指针，该区域包含了要写入的数据。</li>
<li><code>count</code> ：要写入的字节数。</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时， <code>write</code>  函数返回实际写入的字节数，这个值通常小于或等于  <code>count</code> 。</li>
<li>如果函数执行失败，返回  <code>-1</code> ，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><code>ssize_t</code>  是一个可签名的整数类型，它用于表示写入操作的结果，可以是正数、零或负数。负数表示出现了错误。</p>
<h3 id="ftruncate-改变打开文件的长度"><a class="anchor" href="#ftruncate-改变打开文件的长度">#</a>  <code>ftruncate</code>  改变打开文件的长度</h3>
<p><code>ftruncate</code>  函数是 POSIX 标准中用于截断或扩展文件长度的系统调用，其原型在  <code>unistd.h</code>  头文件中声明。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">ftruncate</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>fd</code> ：文件描述符，是一个非负整数，表示要操作的文件。</li>
<li><code>length</code> ：新的文件长度， <code>off_t</code>  类型，是一个可签名的整数类型，表示文件应该被截断或扩展到的长度（字节为单位）。</li>
</ol>
<p>功能：</p>
<ul>
<li><code>ftruncate</code>  函数将指定文件描述符  <code>fd</code>  引用的文件截断到  <code>length</code>  参数指定的长度。如果文件当前的长度大于  <code>length</code> ，则文件将被截断，超出部分将丢失。如果文件当前的长度小于  <code>length</code> ，则文件将被扩展，新的空间将被分配，但文件内容不确定（通常是零）。</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果函数成功执行，返回 0。</li>
<li>如果函数执行失败，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<h4 id="ftruncate-函数扩展文件大小的注意事项"><a class="anchor" href="#ftruncate-函数扩展文件大小的注意事项">#</a>  <code>ftruncate()</code>  函数扩展文件大小的注意事项</h4>
<p>两个关键概念：文件大小和块的数量。文件大小是指文件中实际数据的总和，通常以字节计量。而块的数量则表示文件在磁盘上占用的块的总数，这与文件系统使用的块大小密切相关。通常情况下，文件占用的磁盘块数量所表示的大小应该大于或等于文件的实际大小，因为文件系统按照固定大小的块来分配存储空间。</p>
<p>当使用  <code>ftruncate()</code>  函数来扩展文件大小时，如果新增加的空间仅填充了空字符，那么这部分空间实际上并没有被真实数据占用。这意味着，尽管文件的大小在逻辑上增加了，但在物理存储上并没有额外占用磁盘空间。</p>
<p>以一个具体的例子来说明，如果一个文件原本大小为 0 字节，通过  <code>ftruncate()</code>  函数将其大小扩展到 10000 字节，但文件的实际内容仍然是空的，那么这个文件在磁盘上的占用可能仍然是 0 字节。这是因为新增的字节都是空字符，文件系统可能不会为这些空字符分配实际的存储空间。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token function">ARGS_CHECK</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">ERROR_CHECK</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> len<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">sscanf</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">ftruncate</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">ERROR_CHECK</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"ftruncate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSUWxwbjlYV2hsTGdtNFdqQVR5ckk0QnY2dHNwNGVzVWdwUmlVNUl6M3NfZ0E_ZT1lMUxvY3c.png" alt="" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmbWwteG84cjlaQWtONnRmRW8zRW5RQmJPYTF5OG42OVlrQl8wVmw1ekhnNkE_ZT1hWmJ3a0w.png" alt="" /></p>
<p>如上图，使用 vim 编辑 file 文件后，块的数量增加到 24，也就是三个磁盘块。</p>
<h4 id="文件空洞"><a class="anchor" href="#文件空洞">#</a> 文件空洞</h4>
<p>利用  <code>ftruncate()</code>  函数，可以在文件系统中为文件预分配空间，这个过程称为 “文件空洞”。文件空洞允许文件在逻辑上具有特定的大小，而实际上磁盘上可能还没有存储全部的数据信息。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VlbXoyTmtIUjRCSm1BV2RvMDRmYWh3Qkc1QTF6YkRRZVVnNW42QndtQmpVVmc_ZT1CZkt6R0Y.png" alt="" /></p>
<p><strong>文件空洞现象的作用</strong>：</p>
<ul>
<li>文件空洞可以显著提高磁盘操作的性能。在 VFS 中提前占位是一个非常迅速的过程，而物理磁盘上的数据分配则相对缓慢。</li>
<li>这种技术在处理大文件下载时特别有用。例如，在下载大文件的过程中，由于网络和硬盘性能的限制，整个下载过程可能非常漫长。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VacnJCVWtaX1lwS3Rqb21pWWdyZ0ZFQk9UaTVxUFJSOHJNNFVNN1RmckRVTVE_ZT04TmRJSVM.png" alt="" /></p>
<p><strong>在下载任务中的应用</strong>：</p>
<ul>
<li>在下载任务开始时，使用  <code>ftruncate()</code>  函数预分配文件所需的空间。这样，即使磁盘空间分配速度较慢，文件的逻辑大小已经确定，可以避免因磁盘空间不足导致下载失败的情况。</li>
<li>一旦预分配完成，下载任务可以逐步将数据写入磁盘，而不必担心空间不足的问题。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ol>
<li>在下载开始前，使用  <code>ftruncate()</code>  为文件分配所需的全部空间。</li>
<li>随后，下载的数据可以逐步写入已经预留的空间中。</li>
</ol>
<h2 id="无缓冲文件-io-写操作"><a class="anchor" href="#无缓冲文件-io-写操作">#</a> 无缓冲文件 IO 写操作</h2>
<p><strong>文件写入和读取的原则</strong>：</p>
<ol>
<li><strong>数据一致性</strong>：数据应当以写入时的相同形式被读取。如果以字符串的形式写入，那么在读取时也应当以字符串的形式处理。</li>
<li><strong>类型匹配</strong>：写入文件时的数据类型应当与读取时的数据类型一致。这意味着，如果以整数形式写入，也应当以整数形式读取。</li>
</ol>
<p><strong>文本文件与二进制文件的比较</strong>：</p>
<ul>
<li><strong>文本文件</strong>：
<ul>
<li>存储字符的编码值，遵循特定的编码规则（如 UTF-8、ASCII 等）。</li>
<li>文本编辑器可以根据编码规则解码，使得文本文件可以被人类直接阅读。</li>
<li>缺点是同等大小的文件存储的数据量较少，且读取时通常需要进行类型转换。</li>
</ul>
</li>
<li><strong>二进制文件</strong>：
<ul>
<li>直接存储字节序列，不遵循字符编码规则，而是遵循特定的编码规则。</li>
<li>这些规则通常是为了效率和存储特定类型的数据，而不是为了人类阅读。</li>
<li>优点是同等大小的文件可以存储更多的数据，且读取时不需要进行类型转换，因为数据的类型在写入和读取时保持一致。</li>
</ul>
</li>
</ul>
<p>文本文件更适合人类可读性和便携性，而二进制文件则更适合高效的数据存储和传输。</p>
<h2 id="文件复制"><a class="anchor" href="#文件复制">#</a> 文件复制</h2>
<h3 id="有缓冲-io-的文件复制"><a class="anchor" href="#有缓冲-io-的文件复制">#</a> 有缓冲 I/O 的文件复制</h3>
<p>在有缓冲 I/O 操作中，用户进程与用户缓冲区直接进行数据交互。用户缓冲区充当数据的中间存储，然后再由用户缓冲区与内核态缓冲区进行系统调用级别的数据交互。</p>
<ol>
<li><strong>用户缓冲区的作用</strong>： 用户缓冲区通常大小固定，不会很小（一般为 4KB 或 8KB）。它的存在可以在很多情况下有效减少系统调用的次数，尤其是在进程自身的缓冲数组较小时。</li>
<li><strong>性能提升</strong>： 通过减少系统调用次数，用户缓冲区可以显著提升 I/O 操作的整体性能。这种设计确保了 I/O 操作性能的基本下限，避免了因频繁大量的系统调用而导致的性能下降。</li>
<li><strong>系统调用</strong>： 系统调用是用户缓冲区与内核态缓冲区之间数据交互的桥梁。用户缓冲区的引入，使得 I/O 操作性能不会因为无意义的系统调用而降低太多。</li>
<li><strong>性能瓶颈</strong>： 如果使用不带用户缓冲区的 I/O 流，在很多情况下，I/O 操作的性能可能不如带缓冲区的情况。用户缓冲区的设计机制在一定程度上防止了性能瓶颈的出现。</li>
<li><strong>用户空间与内核区域</strong>： 用户进程在用户空间内操作，通过 FILE* 指针和 char buff [] 等数据结构与内核区域进行交互。磁盘数据通过内核态缓冲区与用户缓冲区进行数据传输。</li>
</ol>
<p>有缓冲 I/O 通过引入用户缓冲区，提高了文件操作的性能，减少了系统调用的频率，并且提供了一种有效的数据交换机制。这种设计对于大多数应用场景来说是有益的，尤其是在处理大量数据时，可以显著提高效率。</p>
<h3 id="无缓冲区的-io-流"><a class="anchor" href="#无缓冲区的-io-流">#</a> 无缓冲区的 I/O 流</h3>
<p>在不带用户缓冲区的 I/O 操作中，用户进程的缓冲数组  <code>buf</code>  直接与内核系统调用进行交互。这种直接交互方式意味着数据在用户空间和内核空间之间的传输没有中间的用户态缓冲区作为中介。</p>
<ol>
<li><strong>内核缓冲区的作用</strong>： 内核缓冲区是内核区域中用于临时存储文件数据的缓冲区。它通过指针来追踪当前的读写位置。</li>
<li><strong>系统调用的交互</strong>： 用户进程通过系统调用直接与内核进行数据交互，这种方式在处理大量数据时可能涉及到多次系统调用。</li>
<li><strong>性能影响</strong>： 如果用户进程的缓冲数组  <code>buf</code>  较小，那么在进行文件 I/O 操作时，可能会因为系统调用次数过多而导致整体 I/O 操作性能急剧下降。</li>
<li><strong>文件对象的操作</strong>： 在无缓冲 I/O 中，用户进程可能需要直接处理文件对象，如  <code>src</code>  和  <code>dest</code>  文件对象，用于从源文件读取数据并写入目标文件。</li>
<li><strong>磁盘 I/O</strong>： 无缓冲 I/O 直接涉及到磁盘 I/O 操作。用户进程的缓冲数组  <code>buf</code>  直接与磁盘进行数据交换，这在某些场景下可以减少数据复制的开销。</li>
</ol>
<p>不带用户缓冲区的 I/O 流提供了一种直接与内核系统调用交互的方式，这种方式在某些特定场景下可以提高性能，尤其是在缓冲区较小且需要频繁进行系统调用的情况下。然而，这种方式也可能导致性能下降，因为每次系统调用都可能涉及磁盘 I/O，增加了系统的负载。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VUN25DVmtJZm1WTmhQa3lGT2NXY2Z3QnJhNHpfV25pZFJSakswODdiSGZ0aGc_ZT1GVHR6Rnk.png" alt="202403122305927.png" /></p>
<h3 id="有缓冲-io-和无缓冲-io-的比较"><a class="anchor" href="#有缓冲-io-和无缓冲-io-的比较">#</a> 有缓冲 I/O 和无缓冲 I/O 的比较</h3>
<p>有缓冲 I/O 和无缓冲 I/O 文件复制各有其适用场景和优缺点。在许多情况下，使用无缓冲文件流可能不如使用带用户缓冲区的普通文件流效率高，特别是在没有设置合理缓冲区的情况下。</p>
<p>无缓冲 I/O 主要适用于以下场景：</p>
<ol>
<li>实时性要求高的场景： <code>read()</code>  和  <code>write()</code>  提供了更直接的磁盘访问，允许更精确地控制数据读写时机。在需要即时处理数据的实时系统中，使用带缓冲的读写可能不合适。</li>
<li>系统编程：在 Linux 系统编程中，有些操作只支持  <code>read</code>  和  <code>write</code> 。例如，读写某些设备文件、管道的进程间通信、网络通信等，这些场景通常只能使用无缓冲 I/O。</li>
</ol>
<p>然而，在大多数普通文件操作场景中，使用带缓冲的文件流是更优选择，特别是：</p>
<ol>
<li>需要跨平台的文件操作时，带缓冲的文件流可以提供更好的兼容性和便利性。</li>
<li>处理文本文件的操作时，可以使用  <code>fgets</code> / <code>fputs</code>  这样的函数读写整行数据，这更符合人类的阅读习惯。</li>
</ol>
<p>选择有缓冲 I/O 还是无缓冲 I/O 取决于具体的应用场景和性能需求。在需要高实时性和直接控制磁盘访问的场合，无缓冲 I/O 可能是更好的选择。而在大多数其他情况下，带缓冲的文件流因其便利性和效率优势，通常是首选。</p>
<h2 id="文件映射"><a class="anchor" href="#文件映射">#</a> 文件映射</h2>
<h3 id="mmap-内存映射函数"><a class="anchor" href="#mmap-内存映射函数">#</a>  <code>mmap</code>  内存映射函数</h3>
<p><code>mmap</code>  函数是一种在 POSIX 系统上将文件或其他对象映射到内存的机制。使用  <code>mmap</code> ，你可以将一个文件的内容映射到进程的地址空间，实现文件与内存之间的高效数据交换。这个函数定义在  <code>sys/mman.h</code>  头文件中。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>addr</code> ：内存映射的起始地址，通常设置为  <code>NULL</code> ，由系统选择映射区域的地址。</li>
<li><code>length</code> ：映射区域的长度（字节为单位）。注意  <code>length</code>  必须是大于 0 的整数值，不能等于 0，更不能是负数。</li>
<li><code>prot</code> ：期望的内存保护选项，可以是以下一个或多个标志的组合：
<ul>
<li><code>PROT_EXEC</code> ：允许执行内存内容。</li>
<li><code>PROT_READ</code> ：允许读取内存内容。</li>
<li><code>PROT_WRITE</code> ：允许写入内存内容。</li>
<li><code>PROT_NONE</code> ：页面不可访问。</li>
</ul>
</li>
<li><code>flags</code> ：控制映射特性的标志，常用的标志包括：
<ul>
<li><code>MAP_SHARED</code> ：对映射区域的修改会反映到文件上。</li>
<li><code>MAP_PRIVATE</code> ：私有的 copy-on-write 映射，对映射区域的修改不会反映到文件上。</li>
<li><code>MAP_ANONYMOUS</code> ：匿名映射，不与任何文件关联。</li>
<li><code>MAP_FIXED</code> ：将映射区域固定在  <code>addr</code>  指定的地址。</li>
</ul>
</li>
<li><code>fd</code> ：被映射文件的文件描述符，如果是匿名映射则设置为  <code>-1</code> 。</li>
<li><code>offset</code> ：文件映射的起始位置，通常为文件大小的整数倍。</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时，返回指向映射区域的指针。</li>
<li>失败时，返回  <code>MAP_FAILED</code> （通常是  <code>(void *)-1</code> ），并设置  <code>errno</code>  以指示错误。</li>
</ul>
<h4 id="总线错误"><a class="anchor" href="#总线错误">#</a> 总线错误</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token function">ARGS_CHECK</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">ERROR_CHECK</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 从文件的开头映射 5 个字节的数据到内存中</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 假如文件是一个文本文件</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">ERROR_CHECK</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> MAP_FAILED<span class="token punctuation">,</span> <span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 修改一下文件数据</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>（file 为空文件）</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VRRUVzQTNTckNCR2puczVLMHY1S2NVQl9LVWhtZjlZanhranRRY0tzUGVDcGc_ZT00NVhWMWY.png" alt="" /></p>
<p>当 CPU 尝试访问不存在或不正确的物理地址时，可能会遇到一种称为总线错误（bus error）的硬件异常。在使用  <code>mmap</code>  函数进行内存映射时，这种情况尤其值得注意。因为  <code>mmap</code>  可能会映射一个比实际文件数据更大的区域，这就导致映射区域可能包含一些未初始化或不存在的空间。如果程序在映射完成后访问或修改这些不存在的区域，就可能触发总线错误。</p>
<p>为了避免这种情况，程序员在使用  <code>mmap</code>  函数时需要格外小心，确保对映射区域的所有操作都是正确和合理的。这包括避免映射过多的区域，以及不操作那些实际上不存在的区域。此外，还应该在程序中实现错误处理机制，以便在发生总线错误时能够妥善应对。</p>
<h4 id="mmap-和-open-的关系"><a class="anchor" href="#mmap-和-open-的关系">#</a>  <code>mmap</code>  和  <code>open</code>  的关系</h4>
<p><code>mmap()</code>  函数和  <code>open()</code>  函数都涉及文件的读写权限，它们之间的关系很重要。</p>
<ol>
<li><strong> <code>mmap()</code>  的  <code>prot</code>  参数</strong>：这个参数定义了映射区域的读写权限。它可以设置为  <code>PROT_READ</code> （只读）、 <code>PROT_WRITE</code> （只写）或  <code>PROT_RDWR</code> （读写）。</li>
<li><strong> <code>open()</code>  的  <code>flags</code>  参数</strong>：这个参数定义了文件的打开模式，可以是  <code>O_RDONLY</code> （只读）、 <code>O_WRONLY</code> （只写）或  <code>O_RDWR</code> （读写）。</li>
</ol>
<p><strong>它们之间的关系</strong>：</p>
<ul>
<li>如果  <code>mmap()</code>  的  <code>prot</code>  参数设置为只读，那么  <code>open()</code>  可以以只读模式打开文件。</li>
<li>如果  <code>mmap()</code>  的  <code>prot</code>  参数设置为可写（无论是单独可写还是读写），那么  <code>open()</code>  必须以读写模式打开文件。这是因为映射操作需要读取文件内容，如果文件无法读取，映射将无法完成。</li>
</ul>
<p>使用  <code>mmap()</code>  函数时， <code>open()</code>  获得的文件描述符必须具有足够的权限来满足映射区域的读写需求。基本权限是读取权限，这是必须具备的，以确保映射操作可以成功执行。</p>
<h3 id="munmap-撤销内存映射"><a class="anchor" href="#munmap-撤销内存映射">#</a>  <code>munmap</code>  撤销内存映射</h3>
<p><code>munmap</code>  函数用于撤销之前通过  <code>mmap</code>  函数建立的内存映射。这个函数也是 POSIX 标准的一部分，其原型定义在  <code>sys/mman.h</code>  头文件中。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>addr</code> ：要撤销映射的内存区域的起始地址。这应该是之前  <code>mmap</code>  函数返回的地址。</li>
<li><code>length</code> ：要撤销映射的内存区域的长度（字节为单位）。这应该与创建映射时指定的长度相同。</li>
</ol>
<p>功能： <code>munmap</code>  函数通知操作系统，应用程序不再需要从  <code>addr</code>  开始、长度为  <code>length</code>  的内存区域的映射。操作系统随后可以释放相关资源，并将内存区域恢复到未映射状态。</p>
<p>返回值：</p>
<ul>
<li>如果函数成功执行，返回 0。</li>
<li>如果函数执行失败，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<h3 id="mmap-系统调用的原理"><a class="anchor" href="#mmap-系统调用的原理">#</a>  <code>mmap</code>  系统调用的原理</h3>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VlaEp2QTRhNjdGQnZzZTJkcVAzUE1rQnBuU0ZIWlhQNGdtdWg2U2NwM2pUTHc_ZT1neTczb2M.png" alt="202403141704859.png" /></p>
<p>在文件 I/O 操作中，文件映射（mmap）提供了一种与常规的 read/write 系统调用不同的数据交互方式。</p>
<ol>
<li><strong>页缓存（Page Cache）</strong>： 页缓存是内核空间中的一片内存区域，用于存储文件数据的缓存。它在文件 I/O 操作时，直接与磁盘上的文件交互数据。</li>
<li><strong>数据交互时机</strong>： 页缓存决定了内存和磁盘之间数据交换的时机。这个时机由内核中的一系列算法和硬件（如 DMA）共同决定和管理，程序员不需要直接考虑这些细节。</li>
<li><strong>mmap 系统调用过程</strong>： mmap 允许用户空间的程序直接在内存中映射文件。通过 mmap 申请开辟映射区域后，用户空间的程序可以直接操作映射的内存区域，而无需通过 read/write 系统调用。</li>
<li><strong>文件映射的优势</strong>： 使用 mmap 进行文件映射可以提高性能，因为它减少了系统调用的开销，并且允许内核优化数据的读取和存储过程。</li>
<li><strong>用户空间的 buf 和映射操作</strong>： 在用户空间，程序可以使用指针直接操作映射的内存区域（如 buf），对这些区域的修改可能直接影响到磁盘上的文件内容。</li>
</ol>
<p>文件映射通过 mmap 系统调用，在用户空间创建了文件的内存映射，允许程序以更直接的方式访问和修改文件数据。页缓存机制使得数据交互更加高效，同时减轻了程序员管理内存和磁盘交互的负担。</p>
<h3 id="mmap-函数和-readwrite-函数的比较"><a class="anchor" href="#mmap-函数和-readwrite-函数的比较">#</a>  <code>mmap</code>  函数和  <code>read/write</code>  函数的比较</h3>
<p><code>mmap</code>  和  <code>read/write</code>  是两种不同的文件 I/O 操作方式，它们各自适用于不同的应用场景。</p>
<ol>
<li><strong>read/write</strong>：适用于顺序读写文件。数据流向是从硬盘上的文件，经过页缓存，再到文件对象，最后到达用户进程。这种方式在处理大量数据时，可能需要多次系统调用和数据复制，但在顺序访问时性能较好。</li>
<li><strong>mmap</strong>：适用于随机访问文件。数据流向是从硬盘上的文件到页缓存，然后直接映射到用户空间的内存区域。使用  <code>mmap</code>  时，用户可以直接操作这个内存区域来访问文件，减少了数据从内核空间到用户空间的复制步骤。</li>
</ol>
<p><code>mmap</code>  的优势在于减少了数据转移的过程，这在处理大型文件时尤为明显。在进行极大文件的复制操作时使用  <code>mmap</code>  可以提高效率，因为它允许程序以更接近硬件的方式直接访问文件数据。</p>
<p>然而  <code>mmap</code>  并不总是性能上优于  <code>read/write</code> 。由于顺序访问的性能通常远高于随机访问，所以在顺序读写场景下， <code>read/write</code>  可能仍然是更好的选择。</p>
<p>选择  <code>mmap</code>  还是  <code>read/write</code>  取决于具体的应用需求和场景。如果需要高效的随机访问或处理大型文件， <code>mmap</code>  可能是更合适的选择。而在顺序读写或对性能要求不是特别高的场景下， <code>read/write</code>  可能更加方便和高效。</p>
<h3 id="lseek-移动文件读写位置"><a class="anchor" href="#lseek-移动文件读写位置">#</a>  <code>lseek</code>  移动文件读写位置</h3>
<p><code>lseek</code>  函数是 POSIX 标准中用于设置文件描述符  <code>fd</code>  的文件位置指针的系统调用。这个函数允许你移动文件的读写位置，而不影响文件的任何其他状态。 <code>lseek</code>  函数原型定义在  <code>unistd.h</code>  头文件中。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>fd</code> ：文件描述符，是一个非负整数，表示要操作的文件。</li>
<li><code>offset</code> ：偏移量，表示从  <code>whence</code>  指定的位置开始移动的字节数。这个值可以是正数或负数。
<ul>
<li>如果是 0 表示不偏移</li>
<li>如果是负数表示向文件开头偏移</li>
<li>如果是正数表示向文件末尾偏移</li>
</ul>
</li>
<li><code>whence</code> ：指定  <code>offset</code>  参数的解释方式，可以是以下宏之一：
<ul>
<li><code>SEEK_SET</code> ：设置文件位置指针到  <code>offset</code>  字节的位置（从文件开头开始计数）。</li>
<li><code>SEEK_CUR</code> ：将文件位置指针向前（正数）或向后（负数）移动  <code>offset</code>  字节。</li>
<li><code>SEEK_END</code> ：设置文件位置指针到文件末尾前  <code>offset</code>  字节的位置（如果  <code>offset</code>  为正，则从文件末尾开始计数；如果为负，则从文件开头开始计数）。</li>
</ul>
</li>
</ol>
<p>返回值：</p>
<ul>
<li>成功时， <code>lseek</code>  返回新的文件位置偏移量，从文件开头到当前位置的字节数。</li>
<li>如果函数执行失败，返回  <code>(off_t)-1</code> ，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><code>off_t</code>  是一个可签名的整数类型，用于表示文件位置的偏移量。</p>
<h3 id="fstat-文件描述符获取文件信息"><a class="anchor" href="#fstat-文件描述符获取文件信息">#</a>  <code>fstat</code>   文件描述符获取文件信息</h3>
<p><code>fstat</code>  函数是 POSIX 标准中用于获取文件状态信息的系统调用，它类似于  <code>stat</code>  函数，但是专门用于通过文件描述符获取信息，而不是通过文件名。 <code>fstat</code>  函数原型定义在  <code>sys/stat.h</code>  头文件中。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>fd</code> ：文件描述符，是一个非负整数，表示要获取信息的文件或文件描述符。</li>
<li><code>buf</code> ：指向  <code>struct stat</code>  结构的指针，该结构用于接收关于文件的状态信息。</li>
</ol>
<p><code>struct stat</code>  结构包含了文件的各种属性，如文件大小、块大小、总块数、访问权限、所有者、组、访问时间、修改时间、状态改变时间等。</p>
<p>返回值：</p>
<ul>
<li>如果函数成功执行，返回 0。</li>
<li>如果函数执行失败，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<h3 id="memcpy-复制字节"><a class="anchor" href="#memcpy-复制字节">#</a>  <code>memcpy</code>  复制字节</h3>
<p><code>memcpy</code>  函数是 C 语言标准库中的一个函数，用于从源内存地址复制  <code>n</code>  个字节到目标内存地址。这个函数定义在  <code>string.h</code>  头文件中。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ol>
<li><code>dest</code> ：指向目标内存的指针， <code>memcpy</code>  会将数据复制到这个位置。</li>
<li><code>src</code> ：指向源内存的指针， <code>memcpy</code>  会从这个位置复制数据。</li>
<li><code>n</code> ：要复制的字节数。</li>
</ol>
<p>功能： <code>memcpy</code>  函数将  <code>n</code>  个字节的数据从  <code>src</code>  指向的源内存复制到  <code>dest</code>  指向的目标内存。</p>
<p>返回值： <code>memcpy</code>  返回一个指向目标内存的指针，即  <code>dest</code> 。</p>
<p>注意：</p>
<ul>
<li><code>memcpy</code>  函数不检查源和目标内存区域是否重叠。如果它们重叠，函数的行为是未定义的。如果需要在重叠的内存区域进行复制，应使用  <code>memmove</code>  函数，后者可以正确处理重叠情况。</li>
<li><code>memcpy</code>  通常比  <code>memmove</code>  快，因为它假设内存区域不重叠，并且可以实现更高效的优化。</li>
</ul>
<h2 id="重定向"><a class="anchor" href="#重定向">#</a> 重定向</h2>
<h3 id="标准流和重定向"><a class="anchor" href="#标准流和重定向">#</a> 标准流和重定向</h3>
<p>在每个进程启动伊始，都会自动打开三个文件流，就是标准输入流  <code>stdin</code> 、标准输出流  <code>stdout</code> 、标准错误输出流  <code>stderr</code> 。</p>
<p>我们已经知道文件流的底层是文件描述符，那么这些标准流也是一样的，它们的底层分别对应文件描述符：</p>
<ol>
<li><strong>标准输入流  <code>stdin</code> ：宏 STDIN_FILENO，对应整数值 0</strong></li>
<li><strong>标准输出流  <code>stdout</code> ：宏 STDOUT_FILENO，对应整数值 1</strong></li>
<li><strong>标准错误流  <code>stderr</code> ：宏 STDERR_FILENO，对应整数值 2</strong></li>
</ol>
<p>我们已经知道文件流的底层结构体对象中会存储文件描述符，所以每次程序启动，这三个标准流的内存空间都固定存储这三个文件描述符。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0Vla3cxb0t6bXVOUHZ0RXozcDJncDc4QjVkUjB3cXN5Y3FzdnJtTVRMQVEtUWc_ZT1iY2hSOVU.png" alt="image-20240426233328421.png" /></p>
<p>这三个标准流由 C 标准库来管理维护，程序员只需要使用它们就可以，不需要考虑它们的内存管理问题。</p>
<h3 id="close-和重定向"><a class="anchor" href="#close-和重定向">#</a>  <code>close</code>  和重定向</h3>
<p><strong>文件描述符的分配</strong>： 当调用  <code>open</code>  函数打开一个文件时，系统会为该文件分配一个文件描述符。文件描述符是一个整数，用作文件的唯一标识符。通常情况下， <code>open</code>  会分配当前可用的最小文件描述符。由于标准输入（0）、标准输出（1）和标准错误（2）已经被占用，所以  <code>open</code>  通常从文件描述符 3 开始分配。</p>
<p><strong> <code>close</code>  函数的作用</strong>：  <code>close</code>  函数用于关闭一个打开的文件描述符。它实际上不是直接关闭文件，而是断开索引指针数组和文件对象之间的关系。这意味着，当  <code>close</code>  被调用时，相应的索引指针不再指向目标文件对象，从而断开了它们之间的链接。</p>
<p><strong>资源释放</strong>： 当所有的索引指针都不再指向某个文件对象时，该文件对象就变得无用。在这种情况下，系统会通过引用计数机制来释放与该文件对象相关的资源。这个过程是自动的，确保了系统资源的有效管理。</p>
<h3 id="dup-复制文件描述符"><a class="anchor" href="#dup-复制文件描述符">#</a>  <code>dup</code>  复制文件描述符</h3>
<p><code>dup</code>  函数是 POSIX 标准中用于复制文件描述符的系统调用。当你想要保留一个文件描述符的副本以便在不同的执行流程中使用，或者需要为现有的文件描述符创建一个新的独立引用时，这个函数就非常有用。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数： <code>oldfd</code> ：要复制的原始文件描述符。</p>
<p>功能： <code>dup</code>  函数创建一个新的文件描述符，它与  <code>oldfd</code>  引用相同的文件，并具有相同的文件状态标志。</p>
<p>返回值：</p>
<ul>
<li>成功时，返回新的文件描述符，这个值大于或等于 0。</li>
<li>失败时，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VacXhjZE1DUlZaSW5wZG8tTVZBclV3Qklxb1hXekhEMmVEYTI3bU9MemlFM3c_ZT1iM1BjUlc.png" alt="202403132226325.png" /></p>
<h3 id="dup2-复制文件描述符"><a class="anchor" href="#dup2-复制文件描述符">#</a>  <code>dup2</code>  复制文件描述符</h3>
<p><code>dup2</code>  函数是 POSIX 标准中提供的用于复制文件描述符的系统调用，与  <code>dup</code>  类似，但它允许你指定新文件描述符的值。如果指定的新文件描述符已经打开，它将被关闭并重新用于复制的文件描述符。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword">int</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ul>
<li><code>oldfd</code> ：要复制的原始文件描述符。</li>
<li><code>newfd</code> ：新文件描述符的期望值。</li>
</ul>
<p>功能：</p>
<ul>
<li><code>dup2</code>  函数将  <code>oldfd</code>  复制到文件描述符  <code>newfd</code> 。如果  <code>newfd</code>  已经打开，它将被关闭，然后复制  <code>oldfd</code>  的属性到  <code>newfd</code> 。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时，返回新的文件描述符，即  <code>newfd</code> 。</li>
<li>失败时，返回 -1，并设置全局变量  <code>errno</code>  以指示错误类型。</li>
</ul>
<div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i>C</a><a href="/tags/linux/" rel="tag"><i class="ic i-tag"></i>Linux</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-12-13 15:38:31" itemprop="dateModified" datetime="2024-12-13T15:38:31+08:00">2024-12-13</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="http://cwlrin.wiki/c-cpp/linux-c/Linux%20%E6%96%87%E4%BB%B6%E6%B5%81/" title="Linux 文件流">http://cwlrin.wiki/c-cpp/linux-c/Linux 文件流/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/linux-c/Linux%20%E7%9B%AE%E5%BD%95%E6%B5%81/" rel="prev" itemprop="url" title="Linux 目录流" style="background-image: linear-gradient(to bottom right, #8ecbdf, #dcccde);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Linux C</span><h3>Linux 目录流</h3></a></div><div class="item right"><a href="/c-cpp/linux-c/Linux%20%E7%AE%A1%E9%81%93%E5%92%8C%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="next" itemprop="url" title="Linux 管道和 IO 多路复用" style="background-image: linear-gradient(to bottom right, #bcf7f2, #8b82a9);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>Linux C</span><h3>Linux 管道和 IO 多路复用</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text"> 无缓冲文件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text"> 文件流相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">  open  打开文件系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">  close  关闭文件系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">  read  读取文件系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">  write  写入文件系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ftruncate-%E6%94%B9%E5%8F%98%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text">  ftruncate  改变打开文件的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ftruncate-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.5.1.</span> <span class="toc-text">  ftruncate()  函数扩展文件大小的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A9%BA%E6%B4%9E"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 文件空洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6-io-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text"> 无缓冲文件 IO 写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text"> 文件复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2-io-%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text"> 有缓冲 I&#x2F;O 的文件复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84-io-%E6%B5%81"><span class="toc-number">4.2.</span> <span class="toc-text"> 无缓冲区的 I&#x2F;O 流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2-io-%E5%92%8C%E6%97%A0%E7%BC%93%E5%86%B2-io-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.</span> <span class="toc-text"> 有缓冲 I&#x2F;O 和无缓冲 I&#x2F;O 的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text"> 文件映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">  mmap  内存映射函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E9%94%99%E8%AF%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 总线错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap-%E5%92%8C-open-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text">  mmap  和  open  的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#munmap-%E6%92%A4%E9%94%80%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">5.2.</span> <span class="toc-text">  munmap  撤销内存映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">  mmap  系统调用的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E5%87%BD%E6%95%B0%E5%92%8C-readwrite-%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.4.</span> <span class="toc-text">  mmap  函数和  read&#x2F;write  函数的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lseek-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.5.</span> <span class="toc-text">  lseek  移动文件读写位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fstat-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">5.6.</span> <span class="toc-text">  fstat   文件描述符获取文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memcpy-%E5%A4%8D%E5%88%B6%E5%AD%97%E8%8A%82"><span class="toc-number">5.7.</span> <span class="toc-text">  memcpy  复制字节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text"> 重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%B5%81%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.1.</span> <span class="toc-text"> 标准流和重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.2.</span> <span class="toc-text">  close  和重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">  dup  复制文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup2-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">6.4.</span> <span class="toc-text">  dup2  复制文件描述符</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/linux-c/Linux%20C%20%E5%9F%BA%E7%A1%80/" rel="bookmark" title="Linux C 基础">Linux C 基础</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E6%9D%82%E9%A1%B9/" rel="bookmark" title="Linux 杂项">Linux 杂项</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%9B%AE%E5%BD%95%E6%B5%81/" rel="bookmark" title="Linux 目录流">Linux 目录流</a></li><li  class="active"><a href="/c-cpp/linux-c/Linux%20%E6%96%87%E4%BB%B6%E6%B5%81/" rel="bookmark" title="Linux 文件流">Linux 文件流</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%AE%A1%E9%81%93%E5%92%8C%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="bookmark" title="Linux 管道和 IO 多路复用">Linux 管道和 IO 多路复用</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="bookmark" title="Linux 进程（上）">Linux 进程（上）</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="bookmark" title="Linux 进程（下）">Linux 进程（下）</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="bookmark" title="Linux 进程间通信">Linux 进程间通信</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E4%BF%A1%E5%8F%B7/" rel="bookmark" title="Linux 信号">Linux 信号</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="Linux 线程">Linux 线程</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/" rel="bookmark" title="Linux 线程的同步和互斥.md">Linux 线程的同步和互斥.md</a></li><li ><a href="/c-cpp/linux-c/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="bookmark" title="网络协议">网络协议</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Linux 网络编程">Linux 网络编程</a></li><li ><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E6%B1%A0/" rel="bookmark" title="Linux 进程池">Linux 进程池</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/linux-c/Linux%20%E7%AE%A1%E9%81%93%E5%92%8C%20IO%20%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/linux-c/Linux%20%E7%9B%AE%E5%BD%95%E6%B5%81/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.4m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">21:46</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `c-cpp/linux-c/Linux 文件流/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.20" type="module" fetchpriority="high" defer></script></body></html>