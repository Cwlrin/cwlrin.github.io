<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="http://cwlrin.github.io/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.17"><link rel="modulepreload" href="/js/chunk-3QGRG5LW.js"></link><link rel="modulepreload" href="/js/chunk-7LBLERAB.js"></link><link rel="modulepreload" href="/js/chunk-CDMLOMPO.js"></link><link rel="modulepreload" href="/js/copy-tex-NI6UDW37.js"></link><link rel="modulepreload" href="/js/index.esm-LMM4SZN2.js"></link><link rel="modulepreload" href="/js/post-DKVG6ABI.js"></link><link rel="modulepreload" href="/js/quicklink-PZJIXTPA.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="s" as="image" fetchpriority="high"><link rel="preload" href=":" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="i" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="." as="image" fetchpriority="high"><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="o" as="image" fetchpriority="high"><link rel="preload" href="s" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="r" as="image" fetchpriority="high"><link rel="preload" href="v" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="a" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="R" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="c" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="6" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="y" as="image" fetchpriority="high"><link rel="preload" href="8" as="image" fetchpriority="high"><link rel="preload" href="x" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="J" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="z" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="v" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="y" as="image" fetchpriority="high"><link rel="preload" href="9" as="image" fetchpriority="high"><link rel="preload" href="i" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="G" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="j" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="j" as="image" fetchpriority="high"><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="D" as="image" fetchpriority="high"><link rel="preload" href="F" as="image" fetchpriority="high"><link rel="preload" href="o" as="image" fetchpriority="high"><link rel="preload" href="N" as="image" fetchpriority="high"><link rel="preload" href="C" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="c" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="3" as="image" fetchpriority="high"><link rel="preload" href="B" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="N" as="image" fetchpriority="high"><link rel="preload" href="4" as="image" fetchpriority="high"><link rel="preload" href="O" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="X" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="J" as="image" fetchpriority="high"><link rel="preload" href="F" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="j" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="q" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="9" as="image" fetchpriority="high"><link rel="preload" href="6" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="E" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="E" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="G" as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="w" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="D" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="a" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="w" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="E" as="image" fetchpriority="high"><link rel="preload" href="_" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="q" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="J" as="image" fetchpriority="high"><link rel="preload" href="5" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="g" as="image" fetchpriority="high"><link rel="preload" href="." as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="g" as="image" fetchpriority="high"><meta name="keywords" content="C,"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><title>C 语言数据结构——二叉搜索树</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C 语言数据结构——二叉搜索树</h1><div class="meta"><span class="item" title="创建时间：2020-03-15 12:01:12"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-03-15T12:01:12+08:00">2020-03-15</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>14k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmdDFoNC1pclVWT3BkMmN4OWZXMHJFQjdqWl96VEdEdGpUTVkwdDdQaUYwUkE_ZT1qdUJ5WTg.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/c-basic/" itemprop="item" rel="index" title="分类于C 语言基础"><span itemprop="name">C 语言基础<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="二叉搜索树的定义"><a class="anchor" href="#二叉搜索树的定义">#</a> 二叉搜索树的定义</h2>
<p><strong>二叉树的定义：</strong> 二叉树是一种分层的数据结构，其中每个节点最多有两个子节点。这种结构允许每个节点有两个分支，分别指向其左子树和右子树。</p>
<p><strong>二叉树的特殊形态：</strong></p>
<ul>
<li><strong>完全二叉树（Complete Binary Tree）</strong>：如果二叉树的高度为 h，除了第 h 层之外，所有层的节点数都达到最大，且第 h 层的节点从左到右连续排列，这样的树被称为完全二叉树。</li>
<li><strong>满二叉树（Full Binary Tree）</strong>：如果二叉树的每一层的节点数都达到最大，包括最底层，这样的树被称为满二叉树。</li>
</ul>
<p><strong>二叉搜索树（Binary Search Tree, BST）：</strong> 二叉搜索树是一种特殊的二叉树，具有以下性质：</p>
<ul>
<li>每个节点的左子树只包含小于该节点值的节点。</li>
<li>每个节点的右子树只包含大于该节点值的节点。</li>
</ul>
<p><strong>概念区分：</strong></p>
<ul>
<li>二叉搜索树的定义侧重于节点值的大小关系。</li>
<li>满二叉树和完全二叉树的定义侧重于二叉树的结构和形态。</li>
</ul>
<h2 id="二叉搜索树的实现"><a class="anchor" href="#二叉搜索树的实现">#</a> 二叉搜索树的实现</h2>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSWU5DMzhiMFcxRXF0WmRnRHViZWZvQjNwUVlmbEw4OFpwak45Wm1DbDlXdlE_ZT1nMmVUcW4.png" alt="" /></p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">BST_H</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BST_H</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdbool.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	KeyType key<span class="token punctuation">;</span>        <span class="token comment">///&lt; 结点 key 值，具有唯一性</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment">///&lt; 左子树</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">///&lt; 右子树</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> TreeNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 推荐定义一个二叉搜索树的结构体，这样更便于扩展</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	TreeNode <span class="token operator">*</span>root<span class="token punctuation">;</span> <span class="token comment">///&lt; 根结点指针</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span> BST<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="20"></td><td><pre> * @brief 创建一棵空的 BST</pre></td></tr><tr><td data-num="21"></td><td><pre> * @return BST</pre></td></tr><tr><td data-num="22"></td><td><pre> */</span></pre></td></tr><tr><td data-num="23"></td><td><pre>BST <span class="token operator">*</span><span class="token function">bst_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="25"></td><td><pre> * @brief 销毁一棵 BST</pre></td></tr><tr><td data-num="26"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="27"></td><td><pre> */</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_destroy</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="31"></td><td><pre> * @brief 根据 Key 插入一个新结点</pre></td></tr><tr><td data-num="32"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="33"></td><td><pre> * @param key 键值</pre></td></tr><tr><td data-num="34"></td><td><pre> * @return bool</pre></td></tr><tr><td data-num="35"></td><td><pre> */</span></pre></td></tr><tr><td data-num="36"></td><td><pre>bool <span class="token function">bst_insert</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="39"></td><td><pre> * @brief 根据 Key 搜索某个结点并返回</pre></td></tr><tr><td data-num="40"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="41"></td><td><pre> * @param key 键值</pre></td></tr><tr><td data-num="42"></td><td><pre> * @return BST 结点指针</pre></td></tr><tr><td data-num="43"></td><td><pre> */</span></pre></td></tr><tr><td data-num="44"></td><td><pre>TreeNode <span class="token operator">*</span><span class="token function">bst_search</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="47"></td><td><pre> * @brief 根据 Key 删除一个结点</pre></td></tr><tr><td data-num="48"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="49"></td><td><pre> * @param key 键值</pre></td></tr><tr><td data-num="50"></td><td><pre> * @return bool</pre></td></tr><tr><td data-num="51"></td><td><pre> */</span></pre></td></tr><tr><td data-num="52"></td><td><pre>bool <span class="token function">bst_delete</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="55"></td><td><pre> * @brief DFS 先序遍历</pre></td></tr><tr><td data-num="56"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="57"></td><td><pre> */</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_preorder</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre></pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="61"></td><td><pre> * @brief DFS 中序遍历</pre></td></tr><tr><td data-num="62"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="63"></td><td><pre> */</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_inorder</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre></pre></td></tr><tr><td data-num="66"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="67"></td><td><pre> * @brief DFS 后序遍历</pre></td></tr><tr><td data-num="68"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="69"></td><td><pre> */</span></pre></td></tr><tr><td data-num="70"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_postorder</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre></pre></td></tr><tr><td data-num="72"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="73"></td><td><pre> * @brief BFS 层次遍历</pre></td></tr><tr><td data-num="74"></td><td><pre> * @param tree BST</pre></td></tr><tr><td data-num="75"></td><td><pre> */</span></pre></td></tr><tr><td data-num="76"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_levelorder</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre></pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !BST_H</span></span></pre></td></tr></table></figure><h3 id="二叉搜索树的创建"><a class="anchor" href="#二叉搜索树的创建">#</a> 二叉搜索树的创建</h3>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>BST <span class="token operator">*</span><span class="token function">bst_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">return</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>BST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="二叉搜索树的插入操作"><a class="anchor" href="#二叉搜索树的插入操作">#</a> 二叉搜索树的插入操作</h3>
<ol>
<li><strong>初始化指针</strong>：设置两个指针，一个用于寻找插入位置（通常称为  <code>current</code>  或  <code>node</code> ），另一个用于指向插入位置的父节点（称为  <code>parent</code> ）。</li>
<li><strong>遍历 BST</strong>：从根节点开始，沿着树进行深度优先搜索，以确定新节点的插入位置。搜索路径类似于一条带有判断条件的单链表。</li>
<li><strong>确定插入位置</strong>：在遍历过程中，如果新节点的键值小于当前节点的键值，则移至左子树；如果新节点的键值大于当前节点的键值，则移至右子树。这一过程一直持续到找到一个空位（即  <code>NULL</code>  指针）。</li>
<li><strong>处理键值重复</strong>：如果在遍历过程中发现新节点的键值与现有节点的键值相同，则插入操作失败。</li>
<li><strong>执行插入</strong>：一旦找到插入位置， <code>parent</code>  指针将指向新节点的父节点，而  <code>NULL</code>  指针的位置将被新节点所取代。在 BST 中，插入操作不是通过  <code>parent-&gt;next = newnode</code>  这样的链表操作，而是根据新节点的键值与父节点键值的比较结果，决定将新节点链接到  <code>parent</code>  的左子树或右子树。</li>
<li><strong>特殊情况处理</strong>：如果 BST 在插入操作前是空的，即根节点指针为  <code>NULL</code> ，则新节点将成为根节点，需要更新根节点指针以指向新节点。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>bool <span class="token function">bst_insert</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 初始化两个指针 parent 和 curr</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    TreeNode <span class="token operator">*</span>curr <span class="token operator">=</span> tree<span class="token operator">-></span>root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    TreeNode <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 遍历这课 BST 树，根据 key 值的大小关系，决定向左向右</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> diff <span class="token operator">=</span> key <span class="token operator">-</span> curr<span class="token operator">-></span>key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 待插入结点的 key 值比当前结点 key 值大，向右走</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            parent <span class="token operator">=</span> curr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            curr <span class="token operator">=</span> curr<span class="token operator">-></span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 待插入结点的 key 值比当前结点 key 值小，向左走</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            parent <span class="token operator">=</span> curr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            curr <span class="token operator">=</span> curr<span class="token operator">-></span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 待插入结点的 key 值和当前结点 key 值相等，插入失败</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">//while 循环结束且函数并没有返回，说明找到了插入位置</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 说明 key 值没有重复</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">//curr 指针就是 NULL, parent 指向插入位置的父结点</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">// 分配一个新结点，初始化它，建议使用 calloc 避免左右子树有野指针</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    TreeNode <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error: calloc failed in bst_insert.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    new_node<span class="token operator">-></span>key <span class="token operator">=</span> key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token comment">// 在执行插入左右子树判断之前，要先判树是否为空</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">// 注意不能使用 curr 指针来进行判断，因为当 curr 指向 NULL 时</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token comment">// 有两种可能性:</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">// 1.BST 插入前是空树 2. 找到插入位置</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token comment">// 插入之前，BST 是空树，只需要更新根节点指针即可</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        tree<span class="token operator">-></span>root <span class="token operator">=</span> new_node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">return</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token comment">// 插入之前树非空，那就根据 key 值大小关系决定插入左子树还是右子树</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">int</span> diff <span class="token operator">=</span> key <span class="token operator">-</span> parent<span class="token operator">-></span>key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token comment">// 插入右子树</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        parent<span class="token operator">-></span>right <span class="token operator">=</span> new_node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token comment">// 插入左子树</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        parent<span class="token operator">-></span>left <span class="token operator">=</span> new_node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token comment">// 插入成功</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token keyword">return</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="二叉搜索树的搜索操作"><a class="anchor" href="#二叉搜索树的搜索操作">#</a> 二叉搜索树的搜索操作</h3>
<ol>
<li><strong>初始化当前结点</strong>：使用一个指针  <code>curr</code>  初始化为根结点  <code>tree-&gt;root</code> ，用于遍历树。</li>
<li><strong>遍历树</strong>：使用  <code>while</code>  循环遍历树，根据键值  <code>key</code>  与当前结点键值的比较结果，决定遍历的方向。</li>
<li><strong>搜索逻辑</strong>：
<ul>
<li>如果  <code>key</code>  大于当前结点的键值，移动到右子结点。</li>
<li>如果  <code>key</code>  小于当前结点的键值，移动到左子结点。</li>
<li>如果  <code>key</code>  等于当前结点的键值，返回当前结点，表示找到了目标结点。</li>
</ul>
</li>
<li><strong>搜索失败</strong>：如果遍历结束且未返回，说明目标键值的结点不存在，返回  <code>NULL</code> 。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>TreeNode <span class="token operator">*</span><span class="token function">bst_search</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 初始化 curr 指针用于遍历寻找目标结点</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  TreeNode <span class="token operator">*</span>curr <span class="token operator">=</span> tree<span class="token operator">-></span>root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 遍历这课 BST 树，根据 key 值的大小关系，决定向左向右</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> diff <span class="token operator">=</span> key <span class="token operator">-</span> curr<span class="token operator">-></span>key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值比当前结点 key 值大，向右走</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      curr <span class="token operator">=</span> curr<span class="token operator">-></span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值比当前结点 key 值小，向左走</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      curr <span class="token operator">=</span> curr<span class="token operator">-></span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值和当前结点 key 值相等，找到了目标结点，直接返回它</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token keyword">return</span> curr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token comment">//while 循环结束且函数未返回，说明目标 key 结点不存在，此时 curr</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token comment">// 找到插入位置，curr 是一个空指针</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 查找失败</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="二叉树的删除操作"><a class="anchor" href="#二叉树的删除操作">#</a> 二叉树的删除操作</h3>
<p>在数据结构中，“度”（Degree）指的是一个节点拥有的子节点数量。在二叉搜索树（BST）中，节点的度有三种可能：</p>
<ol>
<li><strong>度为 0</strong>：节点没有子节点，这种节点称为 “叶子节点”（Leaf Node）。</li>
<li><strong>度为 1</strong>：节点有一个子节点，可能是左子树或右子树。</li>
<li><strong>度为 2</strong>：节点有两个子节点，即既有左子树也有右子树。</li>
</ol>
<p>BST 的删除操作需要特别注意，不能因为删除某个节点而导致树结构断裂，必须保持 BST 的性质。删除操作的复杂度与节点的度有关，度越高，删除操作越复杂。以下是 BST 删除节点的一般步骤：</p>
<ol>
<li><strong>初始化指针</strong>：设置两个指针， <code>curr</code>  用于遍历寻找目标节点， <code>parent</code>  用于指向  <code>curr</code>  的父节点。</li>
<li><strong>查找目标节点</strong>：从根节点开始遍历 BST，如果目标节点不存在，则删除失败。</li>
<li><strong>执行删除操作</strong>：根据节点的度执行不同的删除操作，确保 BST 的性质不被破坏。</li>
<li><strong>释放内存</strong>：删除操作完成后，释放相应节点的内存。</li>
</ol>
<p>对于度为 0 或 1 的节点，删除操作相对简单，因为它们没有或只有一个子节点，可以直接将父节点的对应子树指针指向子节点的子树（如果有的话）。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZM2w4V183UHJ4SWdxRnkzY1BpdE93QlJHZ1R6c1h6RXdWcUtzWE9yb1lyYmc_ZT1nN0RTcVQ.png" alt="202312011508149.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VidG9ENnN6cjVwQmxDZ3A0VDloMERJQlJBclVjdGhjdllJOU1SeUlPMDJiZ2c_ZT1OWWZ3b0U.png" alt="202401120754463.png" /></p>
<p>对于度为 2 的节点，删除操作更复杂。一种常见的方法是找到一个 “替死鬼” 节点，即左子树中的最大节点或右子树中的最小节点，这个节点的度一定是 0 或 1。然后将这个 “替死鬼” 节点的值替换到度为 2 的节点中，再删除原来的 “替死鬼” 节点。这样，度为 2 的节点的删除就被 “降级” 为度为 0 或 1 的节点的删除。</p>
<p>这个过程可以通过以下步骤实现：</p>
<ol>
<li><strong>找到 “替死鬼” 节点</strong>：从待删除节点的右子树中找到最小值节点，或者从左子树中找到最大值节点。</li>
<li><strong>替换值</strong>：将 “替死鬼” 节点的值复制到待删除节点中。</li>
<li><strong>删除 “替死鬼” 节点</strong>：由于 “替死鬼” 节点的度为 0 或 1，可以按照相应的删除操作进行删除。</li>
</ol>
<p>这种方法确保了 BST 的性质得以保持，并且简化了删除操作。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VUX1l1X0pMR3E5RG14T1ZlV09LQUJNQjA4c01Ddmo3MUJhbkdCWmljRnF5Z3c_ZT1zaENKVkg.png" alt="202312011726391.png" /></p>
<p>具体步骤如下：</p>
<ol>
<li><strong>查找待删除结点</strong>：使用两个指针  <code>curr</code>  和  <code>parent</code>  分别指向当前遍历的结点和其父结点。</li>
<li><strong>搜索逻辑</strong>：根据键值  <code>key</code>  与当前结点键值的比较结果，决定遍历的方向。</li>
<li><strong>处理度为 2 的结点</strong>：如果待删除结点有两个子结点，找到其右子树中的最小值结点，将其替换到待删除结点的位置，并更新  <code>curr</code>  指向该最小值结点。</li>
<li><strong>处理度为 0 或 1 的结点</strong>：确定待删除结点的子结点（如果有的话），并将其链接到待删除结点的父结点。</li>
<li><strong>更新根结点</strong>：如果待删除结点是根结点，更新根结点指针。</li>
<li><strong>释放内存</strong>：释放待删除结点的内存。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 根据 key 删除一个结点</span></pre></td></tr><tr><td data-num="2"></td><td><pre>bool <span class="token function">bst_delete</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">,</span> KeyType key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 初始化两个指针用于查找及删除目标结点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  TreeNode <span class="token operator">*</span>curr <span class="token operator">=</span> tree<span class="token operator">-></span>root<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  TreeNode <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 遍历 BST, 根据 key 值的大小关系，决定向左向右</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> diff <span class="token operator">=</span> key <span class="token operator">-</span> curr<span class="token operator">-></span>key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值比当前结点 key 值大，向右走</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      parent <span class="token operator">=</span> curr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      curr <span class="token operator">=</span> curr<span class="token operator">-></span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值比当前结点 key 值小，向左走</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      parent <span class="token operator">=</span> curr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      curr <span class="token operator">=</span> curr<span class="token operator">-></span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token comment">// 待插入结点的 key 值和当前结点 key 值相等，说明找到目标待删除结点</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token comment">// 结束循环，以开始删除操作</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token comment">// 若结点不存在，直接返回 false 表示删除失败</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token comment">//while 循环结束时，程序运行是什么状态呢？</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token comment">//while 循环结束有两种可能性:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token comment">// 1. 依靠 break 结束循环，说明找到待删除结点</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token comment">// 	curr 指针指向待删除结点，parent 指向待删除结点的父结点</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token comment">// 2. 依靠 curr 指向 NULL 结束循环，说明没有找到待删除结点</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token comment">//	此时 curr 指向 NULL, 而 parent 指向插入位置的父结点</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token comment">//	此时程序不应当继续执行了，应当结束返回函数，删除失败</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>  <span class="token comment">// 删除失败</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token comment">// 根据结点度的不同，做不同的处理</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token comment">// 这一步主要目的是让待删除结点从 BST 结构中移除，执行一系列指针的操作</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token comment">// 将度为 2 结点的删除，降级为度为 0 或 1 结点的删除</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">// 待删除结点度为 2</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    TreeNode <span class="token operator">*</span>min_node <span class="token operator">=</span> curr<span class="token operator">-></span>right<span class="token punctuation">;</span>  <span class="token comment">// 用于寻找右子树最小值结点的指针</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    parent <span class="token operator">=</span> curr<span class="token punctuation">;</span>  <span class="token comment">//parent 需要最终指向右子树最小值结点的父结点</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>min_node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>      parent <span class="token operator">=</span> min_node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>      min_node <span class="token operator">=</span> min_node<span class="token operator">-></span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#125;</span>  <span class="token comment">//while 循环结束时，min_node 指向右子树最小值结点，parent 指向它的父结点</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    curr<span class="token operator">-></span>key <span class="token operator">=</span> min_node<span class="token operator">-></span>key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    curr <span class="token operator">=</span> min_node<span class="token punctuation">;</span>  <span class="token comment">//curr 指向最终要指向待删除结点</span></pre></td></tr><tr><td data-num="50"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>  <span class="token comment">// 代码执行到这里</span></pre></td></tr><tr><td data-num="52"></td><td><pre>  <span class="token comment">//curr 指向待删除结点</span></pre></td></tr><tr><td data-num="53"></td><td><pre>  <span class="token comment">//parent 指向待删除结点的父结点</span></pre></td></tr><tr><td data-num="54"></td><td><pre>  <span class="token comment">// 而且 curr 指向的待删除结点，度一定为 0 或 1</span></pre></td></tr><tr><td data-num="55"></td><td><pre>  <span class="token comment">// 绝不可能是度为 2 的</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre>  <span class="token comment">// 统一处理度为 0 或 1 结点的删除</span></pre></td></tr><tr><td data-num="58"></td><td><pre>  <span class="token comment">// 先确定待删除结点的父结点究竟指向待删除结点的左子树还是右子树</span></pre></td></tr><tr><td data-num="59"></td><td><pre>  TreeNode <span class="token operator">*</span>child <span class="token operator">=</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>  <span class="token comment">// 考虑一种特殊情况:</span></pre></td></tr><tr><td data-num="61"></td><td><pre>  <span class="token comment">// 假如删除的结点是根结点，此时需要更新根结点指针</span></pre></td></tr><tr><td data-num="62"></td><td><pre>  <span class="token comment">// 但是要注意，此时的根节点一定是度为 1 或 0 的</span></pre></td></tr><tr><td data-num="63"></td><td><pre></pre></td></tr><tr><td data-num="64"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    <span class="token comment">// 删除的结点是根结点</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    tree<span class="token operator">-></span>root <span class="token operator">=</span> child<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token comment">// 删除的结点不是根结点</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-></span>left <span class="token operator">==</span> curr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>      <span class="token comment">// 待删除结点是父结点的左子树，于是让父结点的左子树指向 child</span></pre></td></tr><tr><td data-num="71"></td><td><pre>      parent<span class="token operator">-></span>left <span class="token operator">=</span> child<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>      <span class="token comment">// 待删除结点是父结点的右子树，于是让父结点的右子树指向 child</span></pre></td></tr><tr><td data-num="74"></td><td><pre>      parent<span class="token operator">-></span>right <span class="token operator">=</span> child<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>  <span class="token comment">//free 结点，删除成功，返回 true</span></pre></td></tr><tr><td data-num="78"></td><td><pre>  <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>  <span class="token keyword">return</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="二叉树的遍历操作"><a class="anchor" href="#二叉树的遍历操作">#</a> 二叉树的遍历操作</h3>
<h4 id="深度优先遍历"><a class="anchor" href="#深度优先遍历">#</a> 深度优先遍历</h4>
<h5 id="前序遍历"><a class="anchor" href="#前序遍历">#</a> 前序遍历</h5>
<ol>
<li><strong>开始遍历</strong>：从 BST 的根节点开始。根节点是树的入口点，也是遍历的起始点。</li>
<li><strong>访问根节点</strong>：首先访问根节点，这通常意味着读取或打印根节点中的值。在先序遍历中，根节点是最先被访问的。</li>
<li><strong>遍历左子树</strong>：接下来，对根节点的左子树进行递归的先序遍历。如果存在左子节点，递归调用先序遍历函数，然后该子节点成为新的 &quot;根&quot;，重复步骤 2 和 3。</li>
<li><strong>遍历右子树</strong>：左子树的所有节点都被访问后，再对根节点的右子树进行递归的先序遍历。同样，如果存在右子节点，递归调用先序遍历函数。</li>
<li><strong>递归结束条件</strong>：当当前节点没有左子节点或右子节点时（即当前节点为叶子节点），或者当前节点为  <code>NULL</code> ，递归调用结束。</li>
<li><strong>返回到上一级节点</strong>：每次递归调用结束后，控制权返回到上一级节点的下一个操作，即上一级节点的右子树遍历（如果有的话）。</li>
<li><strong>遍历完成</strong>：当所有节点都被访问且递归调用完全结束后，整个 BST 的先序遍历完成。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 1. 递归的出口</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 2. 递归体</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_preorder</span><span class="token punctuation">(</span>BST<span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 树为空直接返回</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 利用辅助函数递归实现 BST 的先序遍历</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">preorder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="中序遍历"><a class="anchor" href="#中序遍历">#</a> 中序遍历</h5>
<ol>
<li><strong>递归出口</strong>：遍历从根节点开始，但递归出口是当节点为  <code>NULL</code>  时。如果当前节点为空，即没有更多的子节点可以遍历，递归调用结束。</li>
<li><strong>遍历左子树</strong>：首先，递归调用中序遍历函数遍历当前节点的左子树。由于中序遍历先访问左子树，这确保了所有比当前节点值小的节点都会先被访问。</li>
<li><strong>访问根节点</strong>：左子树遍历完成后，访问当前节点本身。这通常意味着读取或打印当前节点中的值。在中序遍历中，根节点在左子树之后被访问。</li>
<li><strong>遍历右子树</strong>：然后，递归调用中序遍历函数遍历当前节点的右子树。由于中序遍历最后访问右子树，这确保了所有比当前节点值大的节点都会在根节点之后被访问。</li>
<li><strong>递归体</strong>：中序遍历的递归体由三部分组成：首先是对左子节点的递归调用，然后是根节点的访问，最后是对右子节点的递归调用。</li>
<li><strong>遍历结束</strong>：当所有节点都被访问且递归调用完全结束后，整个 BST 的中序遍历完成。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 1. 递归的出口</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 2. 递归体</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_inorder</span><span class="token punctuation">(</span>BST<span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 树为空直接返回</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 利用辅助函数递归实现 BST 的中序遍历</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">inorder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="后序遍历"><a class="anchor" href="#后序遍历">#</a> 后序遍历</h5>
<ol>
<li><strong>递归出口</strong>：遍历从根节点开始，但递归出口是当节点为  <code>NULL</code>  时。如果当前节点为空，即没有更多的子节点可以遍历，递归调用结束。</li>
<li><strong>遍历左子树</strong>：首先，递归调用后序遍历函数遍历当前节点的左子树。这确保了所有比当前节点值小的节点都会先被访问。</li>
<li><strong>遍历右子树</strong>：左子树遍历完成后，递归调用后序遍历函数遍历当前节点的右子树。这确保了所有比当前节点值大的节点都会在左子树之后被访问。</li>
<li><strong>访问根节点</strong>：在左子树和右子树的所有节点都被访问之后，访问当前节点本身。这通常意味着读取或打印当前节点中的值。在后序遍历中，根节点是最后被访问的。</li>
<li><strong>递归体</strong>：后序遍历的递归体由三部分组成：首先是对左子节点的递归调用，然后是对右子节点的递归调用，最后是根节点的访问。</li>
<li><strong>遍历结束</strong>：当所有节点都被访问且递归调用完全结束后，整个 BST 的后序遍历完成。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 1. 递归的出口</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 2. 递归体</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_postorder</span><span class="token punctuation">(</span>BST<span class="token operator">*</span> tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 树为空直接返回</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 利用辅助函数递归实现 BST 的后序遍历</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">postorder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="广度优先遍历"><a class="anchor" href="#广度优先遍历">#</a> 广度优先遍历</h4>
<p>广度优先搜索（Breadth-First Search, BFS）是一种遍历树或图的算法，其按照层级顺序访问每个节点，因此也称为层次遍历。以下是层次遍历的实现过程：</p>
<ol>
<li><strong>初始化队列</strong>：首先，定义一个队列，其元素类型为二叉树节点的指针。</li>
<li><strong>根节点入队</strong>：将二叉树的根节点（如果存在）添加到队列中。</li>
<li><strong>开始循环</strong>：当队列非空时，执行以下步骤：
<ul>
<li>从队列中取出（出队）一个节点，这将是当前正在访问的节点。</li>
<li>打印当前节点的值或执行其他所需的操作。</li>
</ul>
</li>
<li><strong>子节点入队</strong>：对于当前出队的节点，按照从左到右的顺序，如果存在左子节点，则将其添加到队列中。接着，如果存在右子节点，也将它添加到队列中。</li>
<li><strong>继续循环</strong>：重复步骤 3 和 4，直到队列中的所有节点都被出队，这意味着所有节点已经被按照层次顺序访问。</li>
<li><strong>遍历结束</strong>：当队列为空时，层次遍历结束，此时树中的所有节点都已被访问。</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_levelorder</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    LinkedListQueue <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token function">create_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个队列</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 首先让根结点入队</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">enqueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> tree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 当队列不为空时，执行循环</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 在这个循环中，我们将会逐个访问每一层的节点，并将它们的子节点加入队列</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 刚进入 while 循环时，队列的 size 属性就是这一层结点的个数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> level_size <span class="token operator">=</span> q<span class="token operator">-></span>size<span class="token punctuation">;</span>   <span class="token comment">// 当前层次结点的个数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 于是下面循环出队列 n 次，就是出队打印完所有本层结点，并将所有下一层结点都入队</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            TreeNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队获取当前结点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> node<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印当前节点的键值</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token comment">// 如果当前节点的左子节点存在，将左子节点加入队列</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token function">enqueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 如果当前节点的右子节点存在，将右子节点加入队列</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token function">enqueue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 出队打印完一层，换行</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token function">destroy_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成遍历后，销毁队列释放资源</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>层次遍历的特点是它能够保证按照节点的物理结构顺序访问，即先访问上层节点，然后按从左到右的顺序逐层向下访问。这种遍历方式在需要按层处理节点或寻找特定层级上的节点时非常有用，例如在网络通信、操作系统的调度和树结构的可视化表示中。</p>
<h3 id="二叉树的销毁操作"><a class="anchor" href="#二叉树的销毁操作">#</a> 二叉树的销毁操作</h3>
<p>在进行二叉搜索树的销毁操作时的目标是确保释放所有分配的内存，以避免内存泄漏。为了实现这一点，选择后序遍历作为销毁节点的遍历方式，因为它首先访问子节点，最后访问根节点。</p>
<p><strong>销毁操作的步骤如下：</strong></p>
<ol>
<li><strong>选择遍历方式</strong>：后序遍历是销毁操作的理想选择，因为它保证了在释放父节点之前，其所有子节点都已经被访问和释放。</li>
<li><strong>递归释放节点</strong>：通过递归调用，我们首先遍历并释放左子树的所有节点，然后是右子树的所有节点。</li>
<li><strong>释放根节点</strong>：在所有子节点被释放之后，释放当前根节点的内存。</li>
<li><strong>递归出口</strong>：当递归到达一个空节点（ <code>NULL</code> ）时，递归结束。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 递归释放 BST 的结点，总是最后释放根结点，所以采用后序遍历的方式实现</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destory</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 后序，先访问左右子树，再 free 根结点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">bst_destroy</span><span class="token punctuation">(</span>BST <span class="token operator">*</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 递归释放树结点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">destory</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="二叉搜索树的性能分析"><a class="anchor" href="#二叉搜索树的性能分析">#</a> 二叉搜索树的性能分析</h2>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaVmtQaldfZFNwSHV4LU9kUHBIV1RNQmFYTHVlTWJucXpxa0Z6eGZ5azNkUkE_ZT16YnZycHo.png" alt="" /></p>
<p>对于一个二叉搜索树（BST），其插入、查询和删除操作的效率确实依赖于树的高度 h。时间复杂度可以表示为 O (h)。</p>
<p>对于一个含有 n 个节点的二叉搜索树，其高度的确定如下：</p>
<ol>
<li><strong>最佳情况</strong>：当 BST 是一个完全二叉树时，其高度最小。完全二叉树的定义是每一层都被完全填满，除了可能的最后一层，且最后一层的节点尽可能地向左填充。在这种情况下，树的高度 h 可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h = ⌊\log⁡2(n)⌋+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡2</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 来估算，其中 ⌊⌋ 表示向下取整。</li>
<li><strong>最差情况</strong>：当 BST 退化为一个链表时，其高度最大，即树的高度等于节点数 n。</li>
</ol>
<p>因此，对于一个含有 n 个节点的二叉搜索树，其操作的时间复杂度为：</p>
<ul>
<li>最佳情况：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">⌊</mo><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(⌊\log⁡2(n)⌋+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(⌊</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡2</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，简化为 O (log ⁡n)。</li>
<li>最差情况：O (n)。</li>
</ul>
<p>为了确保 BST 的操作时间复杂度保持在 O (log⁡ n)，我们需要在插入和删除节点后进行一些调整，以确保树的高度保持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>⁡</mtext><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊log⁡ 2 (n)⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">⁡2</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)⌋</span></span></span></span> 左右。这种能够自我调整以保持平衡的二叉搜索树被称为自平衡二叉搜索树或平衡二叉树。常见的平衡二叉搜索树有 AVL 树和红黑树等，它们通过特定的旋转操作或其他机制来维持树的平衡。</p>
<div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i>C</a><a href="/tags/ds/" rel="tag"><i class="ic i-tag"></i>数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-12-11 16:21:33" itemprop="dateModified" datetime="2024-12-11T16:21:33+08:00">2024-12-11</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="C 语言数据结构——二叉搜索树">http://cwlrin.github.io/c-cpp/c-base/C 语言数据结构——二叉搜索树/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="prev" itemprop="url" title="C 语言数据结构——哈希表" style="background-image: linear-gradient(to bottom right, #ef80db, #c9e1f1);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言数据结构——哈希表</h3></a></div><div class="item right"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" rel="next" itemprop="url" title="C 语言排序" style="background-image: linear-gradient(to bottom right, #b9fe8d, #b8ffb3);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言排序</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text"> 二叉搜索树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text"> 二叉搜索树的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text"> 二叉搜索树的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> 二叉搜索树的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text"> 二叉搜索树的搜索操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text"> 二叉树的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text"> 二叉树的遍历操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.1.</span> <span class="toc-text"> 前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.2.</span> <span class="toc-text"> 中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.3.</span> <span class="toc-text"> 后序遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.</span> <span class="toc-text"> 二叉树的销毁操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text"> 二叉搜索树的性能分析</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C 语言数据类型">C 语言数据类型</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5/" rel="bookmark" title="C 语言语句">C 语言语句</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/" rel="bookmark" title="C 语言函数">C 语言函数</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6/" rel="bookmark" title="C 语言头文件">C 语言头文件</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/" rel="bookmark" title="C 语言数组">C 语言数组</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="bookmark" title="C 语言字符串">C 语言字符串</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/" rel="bookmark" title="C 语言结构体">C 语言结构体</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" rel="bookmark" title="C语言指针">C语言指针</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——链表">C 语言数据结构——链表</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" rel="bookmark" title="C 语言数据结构——栈">C 语言数据结构——栈</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/" rel="bookmark" title="C 语言数据结构——队列">C 语言数据结构——队列</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——哈希表">C 语言数据结构——哈希表</a></li><li  class="active"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="bookmark" title="C 语言数据结构——二叉搜索树">C 语言数据结构——二叉搜索树</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" rel="bookmark" title="C 语言排序">C 语言排序</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81/" rel="bookmark" title="C 语言文件流">C 语言文件流</a></li><li ><a href="/c-cpp/c-base/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="bookmark" title="进程虚拟内存空间">进程虚拟内存空间</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">88</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.4m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">21:47</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `c-cpp/c-base/C 语言数据结构——二叉搜索树/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.17" type="module" fetchpriority="high" defer></script></body></html>