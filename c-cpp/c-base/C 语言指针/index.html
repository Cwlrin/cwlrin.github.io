<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="http://cwlrin.github.io/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.20"><link rel="modulepreload" href="/js/chunk-6DIGO3JQ.js"></link><link rel="modulepreload" href="/js/chunk-IFD4QV2W.js"></link><link rel="modulepreload" href="/js/chunk-R2ID445Y.js"></link><link rel="modulepreload" href="/js/copy-tex-UHZMXXHX.js"></link><link rel="modulepreload" href="/js/index.esm-KG24JL53.js"></link><link rel="modulepreload" href="/js/post-2KWM56NA.js"></link><link rel="modulepreload" href="/js/quicklink-5WTBH6Z4.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0Vkb2pZX2FoaDhkRWlWMXpLNzFxRno0QkI2M0F3TmZPVUtaejlTV2Nhd0dIcmc_ZT03aUx4aVA.png" as="image" fetchpriority="high"><meta name="keywords" content="C"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"><title>C语言指针</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C语言指针</h1><div class="meta"><span class="item" title="创建时间：2020-03-03 12:57:17"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-03-03T12:57:17+08:00">2020-03-03</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>36k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>33 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0Vkb2pZX2FoaDhkRWlWMXpLNzFxRno0QkI2M0F3TmZPVUtaejlTV2Nhd0dIcmc_ZT03aUx4aVA.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/c-basic/" itemprop="item" rel="index" title="分类于C 语言基础"><span itemprop="name">C 语言基础<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="指针基础"><a class="anchor" href="#指针基础">#</a> 指针基础</h2>
<p>在 C 语言中，指针和指针变量通常被视为相同的概念，但在严格意义上，它们有细微的区别：</p>
<ul>
<li><strong>指针</strong> 指的是内存中的一个地址，它是虚拟内存空间中某字节的唯一标识。</li>
<li><strong>指针变量</strong> 则是专门用来存储这个地址的变量。指针变量本身也具有自己的内存地址，并且内部存储的数据是它所指向的内存地址。</li>
</ul>
<h3 id="指针的初始化"><a class="anchor" href="#指针的初始化">#</a> 指针的初始化</h3>
<ol>
<li><strong>直接地址赋值</strong>：最常见的初始化方法是将一个变量的地址赋值给指针变量。这允许指针直接指向该变量的内存位置。</li>
<li><strong>使用 NULL 进行初始化</strong>：指针变量可以被初始化为 NULL，这是一个特殊的字面值常量，表示指针不指向任何有效的内存地址。在大多数平台上，NULL 实际上等同于地址值 0。尝试操作 NULL 指针将导致未定义行为，通常会引发空指针异常，可能导致程序崩溃。</li>
<li><strong>指针之间的赋值</strong>：一个指针变量可以被初始化为另一个指针变量的值。这样，两个指针变量将存储相同的地址，并且都指向相同的内存对象。</li>
<li><strong>使用数组名初始化</strong>：数组名在 C 语言中代表数组首元素的地址。因此，当用数组名初始化指针变量时，该指针将指向数组的第一个元素。</li>
</ol>
<h3 id="示例"><a class="anchor" href="#示例">#</a> 示例</h3>
<ol>
<li>
<p>打印变量的地址，以 16 进制显示</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%#x"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x1bdffc04</span></pre></td></tr></table></figure></li>
<li>
<p>打印出指针类型的空间大小</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// MSVC 64 位编译器是 8 个字节大小，32 位编译器是 4 个字节大小</span></pre></td></tr></table></figure></li>
<li>
<p>多层次的指针，通常称为 “指针套娃”，需要仔细管理。</p>
<p>例如，当你有一个整型变量  <code>a</code>  和一个指向它的指针  <code>p</code> ，随后创建一个指向  <code>p</code>  的指针  <code>pp</code> ，这就形成了一个双层指针结构。在这个结构中， <code>pp</code>  存储的是  <code>p</code>  的地址。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>    <span class="token comment">// 指针变量的地址存入到另一个指针变量中</span></pre></td></tr></table></figure><p>逻辑流程如下：</p>
<ol>
<li>
<p>声明并初始化一个整型变量 a，然后获取它的地址： <code>int a = 1; int *p = &amp;a;</code></p>
</li>
<li>
<p>声明一个二级指针  <code>pp</code> ，并将其初始化为  <code>p</code>  的地址：  <code>int **pp = &amp;p;</code></p>
</li>
<li>
<p>通过解引用  <code>pp</code> ，我们可以访问  <code>p</code> ，然后再通过  <code>p</code>  访问  <code>a</code>  的值。这个过程可以表示为：  <code>int value = *((*pp));int value = *((*pp));</code></p>
<p>这里  <code>*(*pp)</code>  首先解引用  <code>pp</code>  得到  <code>p</code>  的值，即  <code>a</code>  的地址，然后再次解引用得到  <code>a</code>  的值。</p>
</li>
<li>
<p><code>&amp;pp</code>  表示  <code>pp</code>  本身的地址，这与通过  <code>pp</code>  访问的  <code>p</code>  的地址是不同的。在实际编程中，通常不需要使用  <code>&amp;pp</code> ，除非在某些特定的上下文中需要获取一个指针变量本身的地址。</p>
</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWTUVCV1VjeXIxSWo5VkxnTmhJejdzQjliZ3J6QllES2c4SUJCRlpESFZFR3c_ZT16RGhoWTI.png" alt="" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYSHNMaWRRT2s5RnI5QjJnd253aDdrQnhQQkY4OVVPS2xPT2VON1BlazhwVnc_ZT1Gb1VjSDE.png" alt="QQ20240710-183822.png" /></p>
<p>在 C 语言中，指针变量的声明应该遵循明确的语法规则，以确保代码的清晰性和正确性：</p>
<ul>
<li>使用  <code>数据类型 *指针名;</code>  的格式来声明指针变量。</li>
<li>确保指针声明的数据类型与其指向的目标类型一致，避免未定义行为。</li>
<li>在命名指针变量时，推荐使用  <code>p</code>  或  <code>ptr</code>  等前缀，以明确表示其为指针类型。</li>
</ul>
</li>
</ol>
<h2 id="只读指针变量和指向只读变量的指针"><a class="anchor" href="#只读指针变量和指向只读变量的指针">#</a> 只读指针变量和（指向）只读变量（的）指针</h2>
<p>当  <code>const</code>  用于指针时，它的位置决定了它修饰的数据类型。 <code>const</code>  位于星号 * 的左侧时，修饰的是指针指向的数据；位于星号右侧时，修饰的是指针本身。</p>
<p>理解  <code>const</code>  修饰指针的规则，可以采用 “从后向前看” 的方法。即从变量名开始，向前找到最近的  <code>const</code>  关键字，它就修饰紧挨着它的数据类型。</p>
<ul>
<li><code>int *const</code> ： <code>const</code>  修饰  <code>int *</code> ，即指针本身是常量。</li>
<li><code>const int *</code> ： <code>const</code>  修饰  <code>int</code> ，即指针指向的数据是常量。</li>
</ul>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 此时 const 修饰的是指针，所以指针变量不可更改，但指针指向的变量值可以修改</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// *p = 3; OK</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// p = &amp;b; ERROR</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 此时 const 修饰的是指针变量指向的值，所以指针变量可以更改，但指针指向的变量值不可以修改</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// *p = 3; ERROR</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// p = &amp;b; OK</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span><span class="token keyword">const</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 这里第一个 const 修饰的是指针，所以指针变量的值不可改变；第二个 const 修饰的是指针变量指向的值，也不可改变</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// *pp = 3; ERROR</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// pp = &amp;b; ERROR</span></pre></td></tr></table></figure><h2 id="特殊指针"><a class="anchor" href="#特殊指针">#</a> 特殊指针</h2>
<h3 id="指针指向自己"><a class="anchor" href="#指针指向自己">#</a> 指针指向自己</h3>
<p>在 C 语言中，一个指针可以被赋值为自己的地址，这种指针被称为自引用指针。这种情况下，指针的值就是它自己的内存地址。例如，如果我们有一个指针  <code>p</code> ，并且执行  <code>p = &amp;p</code> ，那么  <code>p</code>  就指向了自己的内存地址。</p>
<p>逻辑如下：</p>
<ol>
<li>
<p>首先获取指针  <code>p</code>  的地址，使用  <code>&amp;p</code> 。</p>
</li>
<li>
<p>然后将这个地址赋值给  <code>p</code>  本身，即  <code>p = &amp;p</code> 。</p>
</li>
</ol>
<p>在这种情况下， <code>p</code>  的值是它自己的地址，所以  <code>p</code>  和  <code>&amp;p</code>  实际上是相等的。但是， <code>*p</code>  应该是  <code>p</code>  所指向的地址的值，而不是  <code>p</code>  本身的地址。如果我们声明了一个指针  <code>p</code>  并让它指向自己，那么  <code>*p</code>  的值应该是一个未定义的或者是一个随机的值，因为  <code>p</code>  的地址可能没有被初始化为一个有效的内存地址。</p>
<p>因此，表达式  <code>p == &amp;p</code>  是正确的，因为  <code>p</code>  被赋值为它自己的地址。但是， <code>*p == p</code>  通常是不正确的，因为  <code>*p</code>  应该是  <code>p</code>  所指向地址的值，而不是地址本身。</p>
<p>另外，如果  <code>p</code>  指向一个变量  <code>a</code> ，即  <code>p = &amp;a</code> ，那么  <code>*p</code>  将等于  <code>a</code>  的值，这是指针解引用的常规用法。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//int *p = (int *) 0x98f2fc28;  直接硬编码指针变量的值  </span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 定义一个指针，指针的值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>p <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%#x"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 0x98f2fc28</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%#x"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 0x98f2fc28</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%#x"</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 0x98f2fc28</span></pre></td></tr></table></figure><h3 id="野指针"><a class="anchor" href="#野指针">#</a> 野指针</h3>
<p>在 C 语言中，一个 “野指针” 是指一个指针变量，它可能没有被正确初始化，或者它指向的内存地址已经不再有效。这种情况可能发生在多种场景下，比如一个全局指针变量被赋值为一个局部变量的地址。当局部变量的生命周期结束，它所占用的内存可能被系统回收或重新分配给其他变量，此时全局指针变量就变成了 “野指针”，因为它指向的内存内容是不确定的。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>dangerous_pointer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">DangeousPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  dangerous_pointer <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="空指针"><a class="anchor" href="#空指针">#</a> 空指针</h3>
<p>在 C 语言中， <code>NULL</code>  是一个特殊的宏定义，它被用来表示一个空指针。空指针不指向任何有效的内存地址，常用于初始化指针变量，表示它们尚未指向一个具体的数据对象。</p>
<p><code>NULL</code>  通常被定义为  <code>(void *)0</code> ，这意味着它是一个指向  <code>void</code>  类型的指针，并且其值为 0。它可以用来初始化任何类型的指针变量，因为 C 语言允许指针类型之间的隐式转换。</p>
<p>当一个指针变量被赋值为  <code>NULL</code> ，它的值就是 0。在内存中，这表示它没有指向任何有效的内存地址。</p>
<p>由于  <code>NULL</code>  指针没有指向任何内存地址，所以它指向的值是未定义的，尝试解引用  <code>NULL</code>  指针（即访问它所指向的内存位置）将导致未定义行为，通常是程序崩溃。</p>
<p><code>NULL</code>  本身不是一个变量，它没有地址。 <code>NULL</code>  是一个常量，它代表了一个指针的值，即 0。当你尝试获取  <code>NULL</code>  的地址，即  <code>&amp;NULL</code> ，这是不合法的，因为  <code>NULL</code>  不是一个对象，没有存储在内存中的地址。</p>
<p>在 3.2 的例子中，可以在函数  <code>DangeousPointer()</code>  中加一句  <code>dangerous_pointer = NULL;</code>  避免产生野指针。</p>
<h3 id="悬空指针"><a class="anchor" href="#悬空指针">#</a> 悬空指针</h3>
<p>悬空指针是一种特殊类型的野指针，它最初指向一个有效的、已定义的内存区域。然而，在程序执行过程中，如果该内存区域被释放或重用，而指针未被适当更新，它就会变成指向一个随机、未定义区域的指针。</p>
<p>悬空指针通常在内存管理不当的情况下产生。例如，当动态分配的内存被释放后，如果指针没有被设置为  <code>NULL</code>  或更新为指向其他有效的内存区域，它就会变成悬空指针。</p>
<p>使用悬空指针是非常危险的，因为它可能导致程序访问无效的内存区域，从而引发程序崩溃或不可预测的行为。</p>
<p>一个典型的悬空指针例子是函数返回其局部变量的指针。如果函数的局部变量位于栈上，当函数返回后，这些局部变量的生命周期结束，栈帧被销毁，此时返回的指针就变成了悬空指针。</p>
<h3 id="通用指针"><a class="anchor" href="#通用指针">#</a> 通用指针</h3>
<p>通用指针类型  <code>void*</code>  在 C 语言中具有独特的地位和用途</p>
<p><strong> <code>void *</code>  类型的特点</strong>：</p>
<ol>
<li><strong>类型无关性</strong>： <code>void *</code>  类型是一个通用指针类型，可以存储任意类型的指针，包括任意地址。</li>
<li><strong>解引用限制</strong>：由于  <code>void *</code>  是一个不明确的指针类型，直接解引用它会导致编译错误。</li>
<li><strong>类型转换</strong>：在解引用  <code>void *</code>  类型之前，需要先将其转换为具体的指针类型。类型转换必须正确，否则可能导致未定义行为。</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ol>
<li><strong>类型转换</strong>：在 C 语言中， <code>void *</code>  到其他指针类型的转换可以隐式进行，而在 C++ 中则需要显式转换。</li>
<li><strong>NULL 宏定义</strong>：在 C 语言中， <code>NULL</code>  通常被定义为  <code>(void *)0</code> ，表示空指针。</li>
<li><strong>通用性</strong>： <code>void *</code>  类型的灵活性使其成为函数返回值和参数的良好选择，尤其是在处理不同类型的数据时。</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>函数返回值</strong>：当函数需要返回不同类型的指针时，可以使用  <code>void *</code>  类型作为返回值，然后由调用者将其转换为适当的类型。</li>
<li><strong>函数参数</strong>：使用  <code>void *</code>  作为函数参数可以增加函数的通用性，例如  <code>qsort</code>  函数可以对任何类型的数组进行排序。</li>
</ol>
<p><strong>扩展</strong>：带有  <code>void *</code>  类型参数的函数通常会有一个额外的参数，如  <code>size</code>  或  <code>len</code> ，表示数据的长度或大小。</p>
<h2 id="指针的运算"><a class="anchor" href="#指针的运算">#</a> 指针的运算</h2>
<h3 id="指针的加法"><a class="anchor" href="#指针的加法">#</a> 指针的加法</h3>
<p>在 C 语言中，指针加法是一种基本操作，它允许我们将指针向前或向后移动特定的字节数。这种移动的步长取决于指针指向的数据类型的大小。例如，如果我们有一个指向  <code>int</code>  的指针并对其执行加法操作（如  <code>int *ptr; ptr++;</code> ），指针  <code>ptr</code>  将移动到下一个  <code>int</code>  变量的地址，这通常意味着向前移动了四个字节（在 32 位系统中）。同样，如果指针是指向  <code>double</code>  的（如  <code>double *dp; dp++;</code> ），执行加法操作将使指针向前移动八个字节，因为  <code>double</code>  类型通常占用八个字节。</p>
<p>指针减法同理，当两个指针相减时，它们必须指向同一个数组或连续的内存块。如果指针不是指向同一内存块，那么结果将是未定义的。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 250607300</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 250607304</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 4</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">double</span> <span class="token operator">*</span>po <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">double</span> <span class="token operator">*</span><span class="token operator">*</span>poi <span class="token operator">=</span> <span class="token operator">&amp;</span>po<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> poi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 250607368</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> poi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 250607376</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 8</span></pre></td></tr></table></figure><h3 id="指针变量比大小"><a class="anchor" href="#指针变量比大小">#</a> 指针变量比大小</h3>
<p>在 C 语言中，指针变量之间的比较操作是基于它们所指向的内存地址进行的。当我们比较两个指针变量时，实际上是在比较它们各自存储的内存地址值。这意味着，如果指针  <code>p1</code>  和  <code>p2</code>  分别存储了不同的地址， <code>p1 &gt; p2</code>  的比较结果将取决于  <code>p1</code>  的地址值是否大于  <code>p2</code>  的地址值。</p>
<p>只有当指针指向相同的数组或内存区域时，它们的比较才有意义。比较指向不同内存区域的指针（如不同的数组或动态分配的内存块）可能会导致未定义的结果或错误。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> result2 <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%d"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%d"</span><span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1</span></pre></td></tr></table></figure><h2 id="数组和指针"><a class="anchor" href="#数组和指针">#</a> 数组和指针</h2>
<h3 id="数组名和指针的关系"><a class="anchor" href="#数组名和指针的关系">#</a> 数组名和指针的关系</h3>
<p>在 C 语言中，数组名是一个在内存中代表数组结构起始位置（基地址，也就是首元素的地址）的标识符。在大多数上下文中，数组名可以视为数组首元素的指针。</p>
<ol>
<li><strong>功能上</strong>：数组名的行为类似于一个固定指向数组首元素的指针，其指向不可改变。数组名不能被重新赋值，但是数组中的元素值是可以修改的。</li>
<li><strong>语法和语义上</strong>：数组名始终代表整个数组，不应在所有场景中直接视为首元素指针。</li>
</ol>
<p><strong>数组名表示整个数组的场景</strong>：</p>
<ol>
<li><strong> <code>&amp;</code>  运算符</strong>：使用  <code>&amp;</code>  运算符时，得到的是指向整个数组的指针，也就是数组指针。</li>
<li><strong> <code>sizeof</code>  运算符</strong>：当使用  <code>sizeof</code>  运算符时，得到的是整个数组变量所占内存空间的大小。注意，这适用于数组定义时的数组名，而不是作为参数传递的数组名。</li>
</ol>
<p><strong>数组名视为首元素指针的场景</strong>：</p>
<ol>
<li><strong>指针初始化</strong>：可以用数组名给指针变量初始化，此时数组名被视为数组首元素的指针。</li>
<li><strong>函数参数传递</strong>：将数组名作为实参传递给函数时，函数得到的是数组的首元素指针。</li>
<li><strong>指针算术运算</strong>：直接用数组名进行指针算术运算（如  <code>++</code> 、 <code>--</code> 、 <code>+</code> 、 <code>-</code> ）时，数组名也被视为首元素指针。</li>
</ol>
<p>数组在传递给函数时退化为指针，这一设计选择带来了以下好处：</p>
<ol>
<li><strong>传递效率</strong>：传递指针给函数比复制整个数组更加高效。无论数组的大小如何，传递的始终是一个固定大小的指针值。</li>
<li><strong>空间效率</strong>：避免了复制整个数组到函数中，节省了大量内存空间。指针传递仅需要一个较小的存储空间。</li>
<li><strong>修改原始数据</strong>：通过指针传递，函数能够直接修改原始数组的数据，而不是仅操作其副本，这为数组操作提供了更大的灵活性。</li>
<li><strong>灵活性</strong>：数组类型包含其长度信息，不同长度的数组类型是不同的。退化为指针后，函数可以接受任何大小的数组，增强了函数的通用性。</li>
</ol>
<p>然而，这种设计也带来了一些挑战，例如 <strong>在函数内部无法直接获取数组的长度</strong>，<strong>需要额外传递长度信息</strong>。此外，指针操作需要谨慎，以避免潜在的风险。</p>
<h3 id="数组作为参数传递"><a class="anchor" href="#数组作为参数传递">#</a> 数组作为参数传递</h3>
<ol>
<li>
<p><strong>数组参数传递</strong>： 在 C 语言中，将数组作为参数传递给函数时，数组名会 “退化” 为指向数组首元素的指针。这意味着函数接收到的只是数组首元素的地址。</p>
</li>
<li>
<p><strong>数组长度信息的丢失</strong>： 由于数组退化为指针，原始数组的长度信息在传递过程中丢失。因此，在函数声明中包含数组长度是不必要的，即使包含，也不会有任何效果。</p>
</li>
<li>
<p><strong>获取数组长度</strong>： 在函数内部，不能通过  <code>sizeof(arr)</code>  获取数组的长度，因为  <code>sizeof</code>  将返回指针的大小，而不是数组的大小。正确的做法是将数组的长度作为额外的参数传递给函数。</p>
</li>
<li>
<p><strong>函数声明示例</strong>： 在 C 语言中，操作数组的函数通常需要声明为：  <code>void test(int arr[], int len);</code></p>
<p>或者，当数组名退化为指针时：  <code>void test(int *arr, int len);</code></p>
<p>这两种声明方式是等价的，都表示函数接收一个指向整数的指针和一个表示数组长度的整数。</p>
</li>
<li>
<p><strong>函数内部对数组的操作</strong>： 在函数内部，可以自由地操作数组名，因为它是指针的副本。由于这个副本指向原始数组的首元素，所以对数组元素的修改会影响到原始数组。</p>
</li>
</ol>
<h3 id="指针数组和数组指针"><a class="anchor" href="#指针数组和数组指针">#</a> 指针数组和数组指针</h3>
<ol>
<li><strong>指针数组（Array of Pointers）</strong>：
<ul>
<li>指针数组本质上是一个数组，其特点是数组中的每个元素都是指针。</li>
<li>这意味着数组可以存储多个指针，每个指针可以指向不同的数据或内存地址。</li>
<li>指针数组在数据结构中非常常见，尤其是在处理字符串数组时。例如，在 C 语言中，字符串通常表示为字符数组，而字符串数组可以表示为字符指针数组，即  <code>char *strArray[]</code> 。每个指针指向一个字符串的起始位置。</li>
</ul>
</li>
<li><strong>数组指针（Pointer to an Array）</strong>：
<ul>
<li>数组指针本质上是一个指针，它指向一个数组的首元素或整个数组。</li>
<li>这个指针允许我们通过指针操作来访问数组的元素，但它本身并不存储多个指针。</li>
<li>数组指针是一种不常见的语法，通常只在特定情况下使用，例如在处理二维数组或多维数组时。当你需要传递一个二维数组给函数时，由于数组在传递时会退化为指向其首元素的指针，所以如果函数需要操作整个二维数组，使用数组指针可以清晰地表达这一需求。</li>
</ul>
</li>
</ol>
<p>在中文表达中，“指针数组” 强调的是 “数组”，即一个由指针组成的集合；而 “数组指针” 强调的是 “指针”，即一个指向数组的单一指针。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 	<span class="token comment">// 这里 arr 是一个数组，这个数组的长度是 10，每个元素都是指向 int 的指针。这意味着我们可以存储 10 个整数指针</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//arr 是一个指针，它指向一个数组，而这个数组的长度是 10，类型是 int。</span></pre></td></tr><tr><td data-num="4"></td><td><pre>				<span class="token comment">// 这种声明通常用于函数指针参数，其中函数需要操作一个固定大小的数组</span></pre></td></tr></table></figure><p><code>arr</code>  和  <code>&amp;arr</code>  的区别：</p>
<ul>
<li><code>arr</code> ：当用作首元素指针时， <code>arr</code>  的值是数组首元素的地址，其类型是  <code>int*</code> 。</li>
<li><code>&amp;arr</code> ：当取  <code>arr</code>  的地址时，我们得到的是一个指向整个数组的指针，类型是数组指针类型，如果我们声明的是  <code>int arr[3]</code> ，则  <code>&amp;arr</code>  的类型是  <code>int(*)[3]</code> 。</li>
</ul>
<h3 id="数组的-7-种写法"><a class="anchor" href="#数组的-7-种写法">#</a> 数组的 7 种写法</h3>
<p>在 C 语言中，数组名  <code>arr</code>  在代码中被视为指向数组首元素的指针。当使用  <code>arr[2]</code>  时，可以直接访问数组的第三个元素，即下标为 2 的元素。实际上，数组名在很多语境下会被编译器视为一个指向数组第一个元素的常量指针，这意味着一旦定义，它就不能再被指向其他地址。然而，这并不影响我们通过数组名访问数组元素或进行遍历。</p>
<p>表达式  <code>*(arr + 2)</code>  通过将数组名与下标值相加，然后解引用结果指针来访问数组元素。这里  <code>arr + 2</code>  表示将数组的首元素指针向前移动两个元素的位置， <code>*</code>  运算符用于获取该指针指向的元素的值。</p>
<p><code>[]</code>  运算符是 C 语言提供的语法糖，它简化了程序员的操作。实际上， <code>arr[2]</code>  等价于  <code>*(arr + 2)</code> ，这种写法更加直观和易于理解。</p>
<p>值得注意的是，尽管语法  <code>array[3]</code>  和  <code>3[array]</code>  在 C 语言中都是合法的，它们都访问数组的第四个元素（假设数组索引从 0 开始），但后者的可读性较差，因为它违反了常规的数组访问习惯。通常，我们使用方括号  <code>[]</code>  来包围索引，以明确表示我们正在访问数组中的特定位置。</p>
<p>示例一：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> array<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      	 <span class="token comment">// 3，推荐写法</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     	 <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       	 <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     	 	 <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>array <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	 <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">[</span>array<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   	 <span class="token comment">// 3</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   	 <span class="token comment">// 3，推荐写法</span></pre></td></tr></table></figure><p>示例二：</p>
<p>对于  <code>*(*(matrix + 2) + 3)</code> ，有：</p>
<ol>
<li><strong>二维数组和指针</strong>： 假设  <code>matrix</code>  是一个二维数组，可以表示为  <code>int matrix [行数][列数]</code> 。在这种情况下， <code>matrix</code>  被视为指向其首元素的指针，其类型可以表示为  <code>int (*p) [列数]</code> 。</li>
<li><strong>指针算术</strong>：  <code>matrix+2</code>  表示将  <code>matrix</code>  指针向前移动两个一维数组的位置。如果每个一维数组的长度是 5（即列数），并且每个  <code>int</code>  占用 4 个字节（这取决于平台，这里假设为 20 字节），那么  <code>matrix + 2</code>  实际上移动了  <code>2 * 20</code>  字节。</li>
<li><strong>解引用和进一步的指针运算</strong>：  <code>*(matrix + 2)</code>  解引用  <code>matrix + 2</code>  指针，得到二维数组的第三个一维数组，此时类型变为  <code>int *</code> ，指向该一维数组的首元素（假设为元素  <code>11</code> ）。</li>
<li><strong>再次指针运算</strong>：  <code>*(matrix + 2) + 3</code>  再次进行指针运算，将  <code>int *</code>  类型的指针向前移动三个  <code>int</code>  的大小，即  <code>3 * 4</code>  字节，此时指针指向元素  <code>14</code> 。</li>
<li><strong>最终解引用</strong>：  <code>*(*(matrix + 2) + 3)</code>  进行第二次解引用，得到指针指向的元素值，即  <code>14</code> ，其类型为  <code>int</code> 。</li>
<li><strong>等价表达式</strong>： 这个运算等价于直接使用下标访问  <code>matrix [2][3]</code> ，得到的也是元素  <code>14</code> 。</li>
</ol>
<h2 id="左值和右值"><a class="anchor" href="#左值和右值">#</a> 左值和右值</h2>
<p>在 C 语言的赋值语句中，等号左边通常是代表一个内存位置的变量，而等号右边则是一个表达式，其计算结果将被赋值给左侧的变量。这意味着左侧必须是一个可以存储值的有效内存地址，如一个变量或一个数组元素。右侧可以是任何能够产生值的表达式，包括常量、变量、函数调用或其他算术或逻辑操作的结果。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//a 是左值，2 是右值</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//p 是左值，&amp;a 是右值</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//b 是左值，*p 是右值</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 左值是内存空间，右值是内存空间里的值</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>pp <span class="token operator">=</span> array<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token operator">*</span>pp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Ctrl + W 的妙用，IDE 自动展开寻找优先级，此处光标展开先是 pp++，然后是 *pp++</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="指针参数作为返回值"><a class="anchor" href="#指针参数作为返回值">#</a> 指针参数作为返回值</h2>
<h3 id="指针替代数组作为返回值"><a class="anchor" href="#指针替代数组作为返回值">#</a> 指针替代数组作为返回值</h3>
<p>在 C 语言中，数组不能直接作为函数的返回值。这是因为数组的返回涉及到复制整个数组，而 C 语言不支持这种复制操作。</p>
<p>尽管数组不能直接返回，但可以通过返回指向数组的指针来间接实现。数组名在 C 语言中被视为数组首元素的指针，因此返回数组名实际上是返回了数组的首元素指针。</p>
<p>将指针作为返回值时需要格外小心，尤其是当指针指向函数的局部变量时。如果函数返回指向其局部变量的指针，一旦函数执行完毕，其栈帧将被销毁，局部变量的生命周期结束，此时返回的指针将成为野指针，指向未定义的内存区域。</p>
<p><strong>避免野指针的最佳实践</strong>：</p>
<ul>
<li>避免返回指向局部变量的指针。</li>
<li>使用动态内存分配（如  <code>malloc</code> ）时，确保内存在使用完毕后被正确释放。</li>
<li>在函数外部分配数组内存，或使用静态或全局数组，这些内存的生命周期不受限于函数的局部作用域。</li>
</ul>
<h3 id="跨函数通过指针修改局部变量"><a class="anchor" href="#跨函数通过指针修改局部变量">#</a> 跨函数通过指针修改局部变量</h3>
<p>在跨函数操作中，通过指针修改局部变量时，必须确保该局部变量在被访问和修改期间是有效的。如果局部变量超出其生命周期，即它所占用的内存已经被释放或重用，那么通过指针访问它将导致未定义行为。</p>
<p>当 A 函数调用 B 函数时，B 函数可以通过指针访问和修改 A 函数中的局部变量。这是因为在 B 函数执行期间，A 函数的栈帧仍然存在于调用栈中，因此 A 中的局部变量仍然处于其生命周期内。为了安全地在 B 函数中操作 A 函数的局部变量，需要确保 B 函数在 A 函数结束前完成执行。这意味着 A 函数必须等待 B 函数的返回，才能继续执行或结束。</p>
<p>在设计程序时，应该考虑局部变量的存储位置和生命周期。如果需要在多个函数间共享数据，可能需要考虑使用全局变量、静态变量或通过参数传递的方式。未定义行为可能导致程序崩溃、数据损坏或不可预测的结果。因此，在编写涉及指针和跨函数操作的代码时，应该小心谨慎，确保所有操作都在变量的有效生命周期内进行。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//int* 指针类型作为形参，表示调用函数需要传入指针变量，也就是需要传入地址</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">swap_poniter</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>p_a <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>p_b <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"调用交换函数之前，实参a = %d , b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">swap_poniter</span><span class="token punctuation">(</span>p_a<span class="token punctuation">,</span> p_b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 等价于</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">//swap_poniter(&amp;a, &amp;b);</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"调用交换函数之前，实参a = %d , b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VhaEJSbzljZG9OS3FoTmFCcW1xblA0QkEycDgyR3EtYUo1SWxsNlNaLTZxY2c_ZT1rUkpPRGQ.png" alt="指针做实参仍然是值传递的-示意图" /></p>
<h3 id="指针传递和修改的变量"><a class="anchor" href="#指针传递和修改的变量">#</a> 指针传递和修改的变量</h3>
<p>当基本数据类型的实参直接作为参数传递给函数时，函数内部无法修改实参的值，因为传递的是值的副本。为了在函数内部修改实参的值，可以将实参的地址作为参数传递。这样，函数接收到的是指向实参的指针，从而能够修改实参的值。</p>
<p>如果将基本数据类型的实参的指针作为参数传递，函数内部可以修改实参的值，但不能修改指针本身的指向，因为传递的是指针值的拷贝。</p>
<p>如果需要在函数内部修改指针变量的指向，可以传递一个二级指针（即指向指针的指针）。这样，函数不仅可以修改原始变量的值，还可以修改指针变量的指向。</p>
<p>示例：</p>
<ul>
<li><code>int a = 10;</code>  直接传递  <code>a</code>  作为参数，函数内部不能修改  <code>a</code> 。</li>
<li><code>int a = 10; int *p = &amp;a;</code>  将  <code>p</code>  作为参数传递，函数内部可以修改  <code>a</code>  的值，但不能修改  <code>p</code>  的指向。</li>
<li><code>int a = 10; int *p = &amp;a; int **pp = &amp;p;</code>  将  <code>pp</code>  作为参数传递，函数内部可以修改  <code>a</code>  的值，也可以修改  <code>p</code>  的指向。</li>
</ul>
<h3 id="函数形参列表中的规律"><a class="anchor" href="#函数形参列表中的规律">#</a> 函数形参列表中的规律</h3>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">find_max_min</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> pmax<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> pmin<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个示例中，我们可以看到两种类型的形参：</p>
<ol>
<li><strong>基本数据类型形参</strong>： <code>int len</code> ，这种类型的参数是按值传递的，因此在函数内部对它的修改不会影响到函数外部的变量。</li>
<li><strong>指针类型形参</strong>：可以分为两类：
<ul>
<li><strong>传入参数</strong>： <code>const int* arr</code> ，使用  <code>const</code>  修饰的指针意味着函数不会修改它指向的数据。这种参数仅用于读取或访问传入的数据。</li>
<li><strong>传入传出参数</strong>： <code>int* pmax</code>  和  <code>int* pmin</code> ，这些指针类型的参数在函数内部可以被用来修改外部数据，它们既用于读取数据，也用于输出数据。</li>
</ul>
</li>
</ol>
<ul>
<li>当学习标准库函数时，如果看到  <code>const</code>  指针类型的基本数据类型形参，这表明函数内部不会修改原始数据。例如，文件操作函数通常需要  <code>const</code>  修饰的字符串参数来表示文件路径。</li>
<li>对于指针类型的形参，如果没有  <code>const</code>  修饰，这表明函数内部可能会修改指针指向的内容。例如， <code>scanf</code>  函数需要指针来初始化指向的内存块。</li>
<li>在编写自己的函数时，如果指针形参不应在函数内部被修改，应该使用  <code>const</code>  修饰。如果确定会修改，就不使用  <code>const</code> 。</li>
</ul>
<p>当分析一个函数的声明，特别是其返回值类型为指针时，确实需要特别注意以下几点：</p>
<ol>
<li>
<p><strong>指针与栈区</strong>： 返回的指针绝不应该指向当前栈区的内存。这是因为函数的局部变量在函数调用结束后会释放，返回指向这些局部变量的指针会导致悬空指针问题。</p>
</li>
<li>
<p><strong>指针与数据段</strong>： 返回的指针可能是指向数据段中的内存块。数据段中的数据具有静态存储期限，它们在程序的整个运行期间都是有效的。因此，返回指向数据段的指针是安全的，程序员不需要考虑这些内存的释放问题。</p>
</li>
<li>
<p><strong>指针与堆区</strong>： 返回的指针可能是指向堆区的内存块。堆内存需要程序员手动管理，具有动态存储期限。如果函数返回指向堆内存的指针，程序员必须考虑内存的分配和释放，以避免内存泄漏。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 利用 p 指针的传参，对 p 指向的内存块做各种各样的处理</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个函数接受一个指向  <code>int</code>  类型的指针  <code>p</code> ，处理指向的内存块，并返回这个指针。这种设计在 C 语言中很常见， <code>p</code>  参数作为传入传出参数，由函数调用者提供并确保其正确性。</p>
</li>
<li>
<p><strong>内存管理责任</strong>： 如果函数返回的是指向堆内存的指针，调用者需要负责管理这块内存，包括在适当的时候释放它。如果函数返回的是指向数据段的指针，调用者则不需要管理内存，因为数据段中的数据具有静态存储期限。</p>
</li>
</ol>
<h3 id="使用函数返回值的流程"><a class="anchor" href="#使用函数返回值的流程">#</a> 使用函数返回值的流程</h3>
<p>在 C 语言中，调用函数并处理其返回值的过程遵循特定的调用约定。当一个函数被调用时，其参数通常首先被推入调用栈中，这是通过将参数复制到函数栈帧的特定位置来实现的。然后，函数开始执行。</p>
<p>对于返回值，大多数 C 编译器使用寄存器来存储小的数据类型的返回值，如整数或指针。当函数执行完毕并准备返回时，它的返回值会被放置在特定的寄存器中。如果返回值是一个复合数据类型或者大小超过了寄存器能够存储的范围，它可能会被存储在堆栈上，或者通过引用参数来传递。</p>
<p>当控制权返回到调用者时，调用者可以通过读取寄存器中的值或从堆栈中获取返回值来使用函数的返回结果。对于小数据类型，通常只需要从寄存器中读取返回值，而对于大数据类型，则可能需要进行一次内存拷贝操作。</p>
<p>并非所有情况下都会发生两次拷贝。实际上，返回值的传递机制取决于编译器的优化和函数返回类型的具体情况。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">SumIntArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 第一次拷贝，函数栈中的函数返回值拷贝到寄存器中</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// mov	eax, DWORD PTR [rbp-4]    # _10, sum</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 第二次拷贝，函数返回值从寄存器拷贝至函数栈中</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//  mov	DWORD PTR [rbp-4], eax    # b, tmp85</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">SumIntArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个 demo 中， <code>SumIntArray(array, 5)</code>  的结果  <code>sum</code>  的值，就是先从函数栈拷贝到  <code>eax</code>  寄存器中，然后再从  <code>eax</code>  寄存器拷贝到变量  <code>b</code>  所在的函数栈地址中。</p>
<p>GCC 编译器下，通过 GDB 可以查看寄存器的值：</p>
<figure class="highlight armasm"><figcaption data-lang="armasm"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">#</span> 第一次拷贝</pre></td></tr><tr><td data-num="2"></td><td><pre>$<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info registers rbp</pre></td></tr><tr><td data-num="3"></td><td><pre>rbp            <span class="token number">0x5ffe10</span>            <span class="token number">0x5ffe10</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">#</span> 第二次拷贝</pre></td></tr><tr><td data-num="5"></td><td><pre>$<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info registers rbp</pre></td></tr><tr><td data-num="6"></td><td><pre>rbp            <span class="token number">0x5ffe60</span>            <span class="token number">0x5ffe60</span></pre></td></tr></table></figure><h3 id="大数返回值的处理"><a class="anchor" href="#大数返回值的处理">#</a> 大数返回值的处理</h3>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// TestBigValue:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="4"></td><td><pre>__int128 <span class="token function">TestBigValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// mov		eax, 0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// mov		edx, 0</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// pop     rbp</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// ret</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// main:</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// sub     rsp, 16</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">//  mov		eax, 0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">//  call 	TestBigValue</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">//	mov		QWORD PTR [rbp-16], rax</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">//	mov		QWORD PTR [rbp-8], rdx</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    __int128 big_int <span class="token operator">=</span> <span class="token function">TestBigValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">//  mov     eax, 0</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">//  leave</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">//  ret</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里使用了两个寄存器进行存储。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>name_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> gender_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> age_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>school_name_<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> Student<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// TestStruct:</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// mov     QWORD PTR [rbp-40], rdi</span></pre></td></tr><tr><td data-num="14"></td><td><pre>Student <span class="token function">TestStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">//  mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0 	# student.names</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">//  mov     DWORD PTR [rbp-24], 1					# student.gender</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">//  mov     DWORD PTR [rbp-20], 17					# student.age</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">//  mov     QWORD PTR [rbp-16], OFFSET FLAT:.LC1	# student.school_name</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    Student student <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Sakurakouji Runa"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"Firia joshi daigaku"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">//  mov     rcx, QWORD PTR [rbp-40]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">//  mov     rax, QWORD PTR [rbp-32]</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">//  mov     rdx, QWORD PTR [rbp-24]</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">//  mov     QWORD PTR [rcx], rax</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">//  mov     QWORD PTR [rcx+8], rdx</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">//  mov     rax, QWORD PTR [rbp-16]</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">//  mov     QWORD PTR [rcx+16], rax</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">return</span> student<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token comment">// mov     rax, QWORD PTR [rbp-40]</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment">// pop     rbp</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">// ret</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// main:</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// sub     rsp, 32</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token comment">// lea     rax, [rbp-32]</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token comment">// mov     rdi, rax</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token comment">// mov     eax, 0</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">// call    TestStruct</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    Student student <span class="token operator">=</span> <span class="token function">TestStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token comment">// mov     eax, 0</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token comment">// leave</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment">// ret</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里使用了多个寄存器进行存储。</p>
<p>为了减少在函数调用过程中的数据拷贝，特别是在返回大型数据结构时，可以采用一种优化技术：将用于接收返回值的指针作为参数传递给函数。这样，函数可以直接在调用者提供的内存地址上构建或修改数据，从而避免了数据的两次拷贝。</p>
<p>具体来说，第一次拷贝发生在将参数传递到函数的栈帧时。然后，函数执行过程中，计算结果直接存储到由指针参数指定的内存位置，通常是调用者栈帧中的一个变量。这种方法只涉及到一次数据拷贝 —— 从函数的参数栈到寄存器，然后直接写入目标内存地址，省略了将返回值从寄存器拷贝回调用者栈帧的步骤。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// SumIntArray:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// mov     QWORD PTR [rbp-24], rdi</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// mov     DWORD PTR [rbp-28], esi</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">SumIntArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">//  mov     DWORD PTR [rbp-4], 0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">//  mov     DWORD PTR [rbp-8], 0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token comment">//  jmp     .L2</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">// .L3</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">//  mov     eax, DWORD PTR [rbp-8]</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">//  cdqe</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">//  lea     rdx, [0+rax*4]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token comment">//  mov     rax, QWORD PTR [rbp-24]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">//  add     rax, rdx</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token comment">//  mov     eax, DWORD PTR [rax]</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token comment">//  add     DWORD PTR [rbp-4], eax</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token comment">//  add     DWORD PTR [rbp-8], 1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token comment">//	.L2:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token comment">//  mov     eax, DWORD PTR [rbp-8]</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">//  cmp     eax, DWORD PTR [rbp-28]</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token comment">//  jl      .L3</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token comment">// mov     eax, DWORD PTR [rbp-4]</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">// pop     rbp</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// ret</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// SumIntArray:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// push    rbp</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// mov     rbp, rsp</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// mov     QWORD PTR [rbp-24], rdi</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// mov     DWORD PTR [rbp-28], esi</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// mov     QWORD PTR [rbp-40], rdx</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">SumIntArray2</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">//  mov     rax, QWORD PTR [rbp-40]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">//  mov     DWORD PTR [rax], 0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token operator">*</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">//  mov     DWORD PTR [rbp-4], 0</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//  jmp     .L2</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//	.L3:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">//	mov     rax, QWORD PTR [rbp-40]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">//	mov     edx, DWORD PTR [rax]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">//	mov     eax, DWORD PTR [rbp-4]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">//	cdqe</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">//	lea     rcx, [0+rax*4]</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">//	mov     rax, QWORD PTR [rbp-24]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">//	add     rax, rcx</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">//	mov     eax, DWORD PTR [rax]</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">//	add     edx, eax</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">//	mov     rax, QWORD PTR [rbp-40]</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">//	mov     DWORD PTR [rax], edx</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token operator">*</span>sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// add     DWORD PTR [rbp-4], 1</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">//	.L2:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">//	mov     eax, DWORD PTR [rbp-4]</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">//	cmp     eax, DWORD PTR [rbp-28]</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">//	jl      .L3</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token comment">//  nop</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">//  nop</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token comment">//  pop     rbp</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">//  ret</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用指针参数作为返回值的好处：</p>
<ol>
<li>避免函数返回值带来的开销</li>
<li>实现函数多个返回值的目的</li>
</ol>
<h2 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h2>
<h3 id="存储期限"><a class="anchor" href="#存储期限">#</a> 存储期限</h3>
<p>存储期限（Storage Duration）是指变量在内存中存在的时间。以下是三种主要的存储期限类型及其特点：</p>
<ol>
<li><strong>自动存储期限（Automatic Storage Duration）</strong>：
<ul>
<li><strong>位置</strong>：通常位于栈（Stack）上。</li>
<li><strong>生命周期</strong>：与函数的调用周期相关。当函数被调用时，自动存储期限的变量被创建；当函数返回时，这些变量被销毁。</li>
<li><strong>示例</strong>：函数的局部变量（非静态）。</li>
<li><strong>特点</strong>：生命周期短，由系统自动管理。</li>
</ul>
</li>
<li><strong>静态存储期限（Static Storage Duration）</strong>：
<ul>
<li><strong>位置</strong>：通常位于数据段（Data Segment）。</li>
<li><strong>生命周期</strong>：与整个程序的生命周期相同，从程序开始运行直到程序结束。</li>
<li><strong>示例</strong>：全局变量、静态局部变量、字符串字面值。</li>
<li><strong>特点</strong>：生命周期长，存储在程序的全局数据区，通常用于存储程序运行期间需要一直访问的数据。</li>
</ul>
</li>
<li><strong>动态存储期限（Dynamic Storage Duration）</strong>：
<ul>
<li><strong>位置</strong>：通常位于堆（Heap）上。</li>
<li><strong>生命周期</strong>：由程序员通过动态内存分配函数（如  <code>malloc</code> 、 <code>calloc</code> 、 <code>realloc</code> ）和释放函数（如  <code>free</code> ）来控制。</li>
<li><strong>示例</strong>：通过  <code>malloc</code>  分配的内存。</li>
<li><strong>特点</strong>：灵活性高，程序员需要手动管理内存的分配和释放，不当管理可能导致内存泄漏。</li>
</ul>
</li>
</ol>
<h3 id="栈内存管理"><a class="anchor" href="#栈内存管理">#</a> 栈内存管理</h3>
<p><strong>栈内存管理的特点</strong>：</p>
<ol>
<li><strong>基于栈顶指针寄存器管理</strong>：栈内存管理依赖于一个栈顶指针寄存器（通常是 ESP 或 RSP），该寄存器的移动用来管理栈的内存空间。</li>
<li><strong>自动内存管理</strong>：栈内存的分配和释放是自动的，当函数调用结束时，其栈帧会自动被销毁，内存被回收。</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>简单高效</strong>：由于栈的后进先出（LIFO）特性，栈内存管理非常高效，访问速度很快。</li>
<li><strong>自动管理</strong>：程序员不需要手动管理栈内存，减少了内存泄漏的风险。</li>
<li><strong>线程安全</strong>：每个线程有自己的栈，因此栈内存是线程安全的。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>大小限制</strong>：栈的大小通常较小，且在编译时确定，不适合存储大的数据结构。</li>
<li><strong>编译时确定</strong>：函数的栈帧大小在编译时就确定，无法动态调整。</li>
<li><strong>线程隔离</strong>：栈内存是线程隔离的，无法实现线程间数据共享。</li>
</ol>
<p><strong>不适合存储在栈上的数据</strong>：</p>
<ol>
<li><strong>大数组或大数据结构</strong>：由于栈空间有限，大数组或大数据结构不适合存储在栈上。</li>
<li><strong>动态数据</strong>：需要在运行时确定大小的数据不适合存储在栈上，因为栈空间在编译时就固定了。</li>
<li><strong>需要线程共享的数据</strong>：由于栈内存是线程隔离的，需要线程共享的数据无法存储在栈上。</li>
</ol>
<h3 id="堆内存管理"><a class="anchor" href="#堆内存管理">#</a> 堆内存管理</h3>
<p><strong>堆内存管理的特点</strong>：手动管理：堆内存的分配和释放需要程序员手动管理，这与自动管理的栈内存不同。</p>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>大容量</strong>：堆区域的大小虽然受限于计算机实际可用内存的大小，但通常远大于栈，可以存储很大的数据。</li>
<li><strong>动态内存分配</strong>：堆内存可以在程序运行时动态分配和释放，适用于存储需要动态确定大小的数据。</li>
<li><strong>线程共享</strong>：在多线程环境中，所有线程共享同一个堆空间，便于实现线程间的数据共享。</li>
<li><strong>灵活的生命周期</strong>：程序员可以手动决定堆中数据的存活时间，堆中数据具有动态存储期限。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>性能问题</strong>：动态内存分配和回收的性能开销比栈操作要大，可能影响程序性能。堆内存动态分配过程可能涉及系统调用，对程序的性能影响较大。</li>
<li><strong>管理复杂且风险高</strong>：内存管理是程序中的一个重要方面，将这一责任交给程序员可能会导致内存泄漏、野指针等安全问题，尤其是对于初学者来说。</li>
<li><strong>线程安全问题</strong>：多个线程共享同一个堆，必须考虑线程同步和加锁等问题，这增加了复杂性，并可能导致性能下降。</li>
</ol>
<h3 id="内存分配使用的优先级"><a class="anchor" href="#内存分配使用的优先级">#</a> 内存分配使用的优先级</h3>
<ol>
<li><strong>栈（Stack）</strong>：
<ul>
<li>优先使用栈内存，因为它提供了自动内存管理和高效的访问速度。</li>
<li>适用于生命周期有限的局部变量。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：
<ul>
<li>当栈内存不足以满足需求时，考虑使用堆内存。</li>
<li>适用于大数据结构、大数组、大字符串或需要动态确定长度的数据。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：
<ul>
<li>一般不推荐使用数据段进行内存分配，因为它可能导致内存碎片和程序性能下降。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ol>
<li><strong>合理使用堆内存</strong>：
<ul>
<li>程序员在编写程序时，应首先考虑使用栈内存。只有在栈内存不可用时，才考虑使用堆内存。</li>
</ul>
</li>
<li><strong>动态内存分配的场景</strong>：
<ul>
<li>当需要存储的数据大小在编译时无法确定，或者数据需要在程序运行期间动态变化时，适合使用堆内存。</li>
</ul>
</li>
<li><strong>堆内存分配的类型</strong>：
<ul>
<li>在堆上分配数组或结构体是常见的做法，因为它们的大小可能是可变的。对于基本数据类型，通常不需要在堆上分配，除非有特殊需求。</li>
</ul>
</li>
</ol>
<h2 id="动态内存分配"><a class="anchor" href="#动态内存分配">#</a> 动态内存分配</h2>
<p><strong>动态内存分配的注意事项</strong>：</p>
<ol>
<li><strong>检查返回值类型</strong>：使用  <code>malloc</code> 、 <code>calloc</code>  或  <code>realloc</code>  函数时，应确保理解这些函数返回的指针类型，并正确地使用变量接收返回值。不应使用数组声明来接收这些函数的返回值。</li>
<li><strong>验证内存分配是否成功</strong>：分配内存后，首要任务是检查分配是否成功。这通常通过检查返回的指针是否为  <code>NULL</code>  来完成。如果指针为  <code>NULL</code> ，则表示内存分配失败。</li>
<li><strong>错误处理</strong>：如果内存分配失败，必须进行错误处理。在 C 语言中，由于缺乏异常机制，错误处理通常依赖于函数返回值。</li>
</ol>
<p><strong>总结规律</strong>：</p>
<ul>
<li>对于返回指针类型的函数，如动态内存分配函数，错误标志通常是返回  <code>NULL</code>  指针。</li>
<li>对于返回  <code>int</code>  类型的函数，如  <code>printf</code>  家族函数，错误标志通常是返回  <code>-1</code> 。</li>
</ul>
<h3 id="malloc"><a class="anchor" href="#malloc">#</a> malloc</h3>
<p>在 C 语言编程中，使用  <code>malloc</code>  函数可以从堆区分配内存，这与在栈上自动分配的数组不同。栈上分配的数组在函数调用结束时会自动释放，而通过  <code>malloc</code>  分配的内存则位于堆区，其生命周期不会随着函数调用的结束而结束。这意味着，程序员必须负责管理这部分内存的生命周期，包括在不再需要时使用  <code>free ()</code>  函数来显式释放内存。</p>
<p><strong> <code>malloc</code>  函数的使用注意事项</strong>：</p>
<ol>
<li><strong>参数</strong>： <code>malloc</code>  函数只有一个参数  <code>size</code> ，表示在堆上分配的内存大小，单位为字节。</li>
<li><strong>返回类型</strong>： <code>malloc</code>  返回一个通用指针类型  <code>void*</code> 。在使用分配的内存之前，需要将其转换为适当的指针类型。</li>
<li><strong>内存初始化</strong>：分配的内存块未初始化，包含随机值。在使用前，应手动初始化内存，以避免未定义行为。</li>
<li><strong>错误处理</strong>：
<ul>
<li>如果内存分配成功， <code>malloc</code>  返回指向分配内存块首字节的地址。</li>
<li>如果分配失败，返回  <code>NULL</code> 。此时，应检查返回值并进行适当的错误处理。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PLAYER_COUNT</span> <span class="token expression"><span class="token number">10</span></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>players <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>PLAYER_COUNT <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PLAYER_COUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	players<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PLAYER_COUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> players<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token function">free</span><span class="token punctuation">(</span>players<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放内存</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="内存泄露与内存溢出"><a class="anchor" href="#内存泄露与内存溢出">#</a> 内存泄露与内存溢出</h3>
<p><strong>内存泄漏（Memory Leak）</strong>：</p>
<ol>
<li><strong>定义</strong>： 内存泄漏发生在程序未能在适当的时机释放不再使用的内存区域，导致这部分内存空间始终被占用，无法重新利用。</li>
<li><strong>影响</strong>： 内存泄漏会导致系统的可用内存逐渐减少。虽然短期内可能不会对程序造成严重影响，但长期累积可能导致严重后果。</li>
<li><strong>长期风险</strong>： 在长时间运行或频繁执行的程序中，内存泄漏可能导致程序运行缓慢甚至崩溃，特别是在内存资源有限的系统中。</li>
<li><strong>与内存溢出的关系</strong>： 内存泄漏的累积有时可能导致内存溢出，但两者之间并没有必然的联系。</li>
</ol>
<p><strong>内存溢出（Memory Overflow）</strong>：</p>
<ol>
<li><strong>定义</strong>： 内存溢出发生在程序分配了过大的内存空间，超出了系统可用内存的容量，导致内存空间 “生长” 到不属于它的内存区域，引发越界访问和修改。</li>
<li><strong>后果</strong>： 内存溢出可能导致程序崩溃或数据损坏，对系统的稳定性构成威胁。</li>
</ol>
<h3 id="calloc"><a class="anchor" href="#calloc">#</a> calloc</h3>
<p><code>calloc</code>  函数是 C 语言中用于动态内存分配的另一种工具，它在功能上与  <code>malloc</code>  相似，但有一个关键的区别： <code>calloc</code>  在分配内存后会自动将所有字节初始化为零。这意味着当你使用  <code>calloc</code>  来分配内存时，得到的内存块中的每个字节都被预设为 0 值，省去了手动初始化的步骤。</p>
<p><strong> <code>calloc</code>  函数的行为</strong>：</p>
<ol>
<li><strong>内存分配</strong>：与  <code>malloc</code>  类似， <code>calloc</code>  函数也会在堆上分配一段连续的内存空间，并返回一个指向该内存块的指针。</li>
<li><strong>内存初始化</strong>： <code>calloc</code>  的一个显著特点是它会将分配的内存块初始化为零值。这是  <code>calloc</code>  与  <code>malloc</code>  最大的区别。</li>
<li><strong>函数声明</strong>： <code>calloc</code>  的函数声明如下： <code>void *calloc(size_t num, size_t size)</code>  其中  <code>num</code>  是内存块元素的个数， <code>size</code>  是每个元素的大小（以字节为单位）。</li>
<li><strong>适用场景</strong>： <code>calloc</code>  函数特别适合用于分配数组的内存空间，因为它会自动将数组初始化为零。</li>
<li><strong>性能差异</strong>：由于初始化内存的额外步骤， <code>calloc</code>  可能比  <code>malloc</code>  稍慢。如果性能是关键考虑因素， <code>malloc</code>  可能是更好的选择。</li>
<li><strong>安全性差异</strong>： <code>calloc</code>  分配的内存块中没有随机值，都是默认的零值，这使得它在某些情况下更安全。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>players <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>PLAYER_COUNT<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="realloc"><a class="anchor" href="#realloc">#</a> realloc</h3>
<p><code>realloc</code>  是一个动态内存管理函数，它允许程序员在不丢失原有数据的前提下，对已分配的内存块进行大小调整。使用  <code>realloc</code> ，可以扩展或缩减内存块，这在需要根据程序运行时的需要调整内存使用量时非常有用。</p>
<p>当使用  <code>realloc</code>  来增加内存块大小时，新的内存块将包含原始内存块的内容，并且可能包含额外的未初始化的内存。这意味着，新增的内存部分可能包含任何值，包括垃圾数据，因此不能假定它们是零或其他特定值。</p>
<p><code>realloc</code>  函数是一个动态内存重新分配函数，它可以调整已经分配的内存块的大小。</p>
<ol>
<li><strong>函数声明</strong>：  <code>void *realloc(void *ptr, size_t newsize)</code></li>
<li><strong>参数</strong>：
<ul>
<li><code>ptr</code> ：指向原来已分配内存的内存块的指针。</li>
<li><code>newsize</code> ：新的内存块大小。</li>
</ul>
</li>
<li><strong>特殊行为</strong>：
<ul>
<li>当  <code>ptr</code>  是  <code>NULL</code>  时， <code>realloc</code>  函数的行为类似于  <code>malloc</code> ，分配一个新的内存块。</li>
<li>当  <code>newsize</code>  为  <code>0</code>  时， <code>realloc</code>  函数的行为类似于  <code>free</code> ，释放传入的内存块。</li>
</ul>
</li>
<li><strong>内存调整</strong>：
<ul>
<li>如果  <code>newsize</code>  小于原始内存块的大小， <code>realloc</code>  会截断内存块，保留从低地址到  <code>newsize</code>  的部分。</li>
<li>如果  <code>newsize</code>  大于原始内存块的大小， <code>realloc</code>  会扩容内存块，可能移动内存块到新的地址。</li>
</ul>
</li>
<li><strong>内存截断</strong>：在内存截断过程中， <code>realloc</code>  会自动处理被截断的内存部分，程序员不需要手动释放这部分内存。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>players<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">InitPointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>players<span class="token punctuation">,</span> PLAYER_COUNT<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 函数 realloc 的用法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>players <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>players<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 重新分配四块内存</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PLAYER_COUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> players<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2 2 2 2 -842150451 ... ，只能确定前四个值，后面的值无法确定，因为是在原有空间的基础上重新分配了四块内存</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>players <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>players<span class="token punctuation">,</span> PLAYER_COUNT <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重新分配 20 块内存</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PLAYER_COUNT <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> players<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 2 2 2 -842150451 -842150451 -842150451 ... 后面一直都是 -842150451</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>players<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VRV1RLTTcxeEI5SnI2ZXZhcHFQM1VjQklZT01obnpha05YZ0ViWHdRSm0zb0E_ZT1tWWpBNTY.png" alt="" /></p>
<p><code>realloc</code>  函数用于调整已分配内存块的大小，与  <code>malloc</code>  和  <code>calloc</code>  相比，它需要特别的错误处理。 <code>realloc</code>  可能会失败，例如当没有足够的内存可用时。因此，不能直接使用原始指针接收  <code>realloc</code>  返回的内存块，惯用写法是创建一个临时指针来接收  <code>realloc</code>  返回的内存块，并进行错误处理。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error: realloc failed in main.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="5"></td><td><pre>	 * realloc 失败了</pre></td></tr><tr><td data-num="6"></td><td><pre>	 * 那么原本 malloc 分配的内存块怎么办呢？看需求</pre></td></tr><tr><td data-num="7"></td><td><pre>	 * 可以 free 掉</pre></td></tr><tr><td data-num="8"></td><td><pre>	 * 也可以做其他的处理</pre></td></tr><tr><td data-num="9"></td><td><pre>	 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>p <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">print_arr</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="free"><a class="anchor" href="#free">#</a> free</h3>
<p><code>free</code>  函数用于释放之前通过  <code>malloc</code> 、 <code>calloc</code>  或  <code>realloc</code>  函数分配的堆内存块。</p>
<ol>
<li><strong>函数声明</strong>：  <code>void free(void *ptr)</code></li>
<li><strong>参数要求</strong>： <code>free</code>  函数需要传入一个指向已分配堆内存块的指针。</li>
<li><strong>内存释放</strong>： <code>free</code>  函数释放内存块，但不会修改内存块中的数据。它仅通知系统该内存可以被重新分配。</li>
<li><strong>指针不变性</strong>：由于 C 语言使用值传递， <code>free</code>  函数不会修改传入的指针。因此，原始指针在  <code>free</code>  调用后仍然是一个悬空指针（野指针）。</li>
<li><strong>后续使用</strong>：如果指针需要继续使用，建议将其置为  <code>NULL</code> ，以避免悬空指针带来的风险。</li>
<li><strong>避免移动原始指针</strong>：分配内存时获得的原始指针不应移动。如果需要移动指针，应创建一个临时指针进行操作，并保留原始指针。</li>
<li><strong>避免重复释放</strong>：避免  <code>double free</code> ，即不要重复调用  <code>free</code>  释放同一块内存。</li>
<li><strong>单一职责原则</strong>：在多函数管理同一块内存时，应遵循单一职责原则。明确哪个函数负责分配内存，哪个函数负责释放内存。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaSC1TNmdqckg1SW53SXd4WXRlTzhZQlpmWlRaR2kxLUdSSEtZTWRtQ1oyWGc_ZT1GVzZLMGs.png" alt="YmlHhpyylR.png" /></p>
<p>尽管  <code>free</code>  函数释放了内存，但是内存块中的数据实际上并没有被修改。在某些平台上，例如 MSVC，可能会看到释放后的内存被标记为  <code>0xDD</code>  或其他模式，这是一种调试时的可视化手段，用于帮助程序员识别内存状态。并非所有平台都具备此特性。因此，最佳实践是在使用完动态分配的内存后，将其指针设置为  <code>NULL</code> ，以避免悬空指针的风险。</p>
<h3 id="分配内存之后"><a class="anchor" href="#分配内存之后">#</a> 分配内存之后</h3>
<p>在 C 语言编程中，动态内存分配是一个常见的操作，但这个过程并不总是成功的。当调用  <code>malloc</code> 、 <code>calloc</code>  或  <code>realloc</code>  函数时，可能会由于多种原因（如内存不足）导致分配失败。因此，在这些函数调用之后，应该立即检查返回的指针是否为  <code>NULL</code> ，这是一个良好的编程实践。</p>
<p>如果指针是  <code>NULL</code> ，这意味着内存分配未能成功，程序应该采取适当的错误处理措施，例如释放已分配的内存（如果调用的是  <code>realloc</code> ），并可能需要记录错误或终止程序。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>players<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 指针指向的地方有内存才有意义</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="注意事项"><a class="anchor" href="#注意事项">#</a> 注意事项</h3>
<p>常见指针使用错误：</p>
<ol>
<li><strong>忘记释放内存</strong>：使用  <code>malloc</code> 、 <code>calloc</code>  或  <code>realloc</code>  分配的内存，如果不再需要，应该使用  <code>free()</code>  函数及时释放，以避免内存泄漏。</li>
<li><strong>使用已释放的内存</strong>：释放内存后，如果没有将指针设置为  <code>NULL</code> ，再次使用该指针可能导致野指针错误。</li>
<li><strong>内存越界</strong>：访问数组或内存块的边界之外，可能导致未定义行为或程序崩溃。</li>
<li><strong>指针丢失</strong>：改变指针的值，使其指向其他内存地址，可能导致原始内存无法释放，因为没有任何指针指向它。</li>
</ol>
<p>改进建议：</p>
<ol>
<li><strong>保持指针稳定</strong>：一旦分配了内存，避免修改指针的值，直到内存被释放。</li>
<li><strong>释放后归零</strong>：释放内存后，应将指针显式设置为  <code>NULL</code> ，以避免悬垂指针问题。</li>
<li><strong>避免多指针管理</strong>：尽量不要让多个指针指向同一块动态分配的内存，这可能导致释放内存时的混乱。</li>
<li><strong>遵守释放原则</strong>：坚持 “谁分配，谁释放” 的原则，确保内存管理的清晰和一致性。</li>
</ol>
<h2 id="二级指针"><a class="anchor" href="#二级指针">#</a> 二级指针</h2>
<p>在 C 语言中，若需在函数间传递二维数组，应使用二维指针作为参数。例如，声明一个函数参数为  <code>int **array</code> ，允许函数访问和修改多维数组的内容。此外，当使用  <code>free ()</code>  函数释放内存后，内存块中原有的数据并不会被清除，它们依然保留在内存中。这意味着，如果再次使用  <code>malloc</code>  为相同大小的数组分配内存，新内存块中将包含之前释放的内存块的数据。因此，在使用  <code>malloc</code>  分配新内存后，通常需要对内存块进行初始化，以确保数据的一致性和预期行为。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PLAYER_COUNT</span> <span class="token expression"><span class="token number">10</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">InitPointer</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> default_value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> default_value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">// 和向函数传递想要修改的参数值的情况相同，必须将变量的地址传入函数才能进行修改，此处就是指针变量的地址传入 InitPointer 函数，进而修改指针变量的值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>players<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token function">InitPointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>players<span class="token punctuation">,</span> PLAYER_COUNT<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PLAYER_COUNT <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> players<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token function">free</span><span class="token punctuation">(</span>players<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>一级指针和二级指针的使用</p>
<ol>
<li><strong>基本数据类型和结构体对象</strong>：
<ul>
<li>当函数参数传递基本数据类型变量或结构体对象时，这些参数是通过值传递的。因此，函数内部对这些参数的修改不会影响到原始变量。</li>
</ul>
</li>
<li><strong>一级指针</strong>：
<ul>
<li>当函数参数传递的是基本数据类型变量或结构体对象的指针时，函数可以通过指针修改原始指针指向的内容，但无法修改指针本身的指向。</li>
</ul>
</li>
<li><strong>二级指针</strong>：
<ul>
<li>二级指针是指向指针的指针。如果函数参数传递的是二级指针，那么函数可以：
<ol>
<li>解引用一次，修改原本一级指针的指向。</li>
<li>解引用两次，修改原本一级指针指向的内容。</li>
</ol>
</li>
</ul>
</li>
<li>一级指针允许函数修改指针指向的内容，但不允许修改指针本身的指向。</li>
<li>二级指针提供了更多的灵活性，允许函数修改指针的指向和指针指向的内容。</li>
<li>在实际应用中，二级指针的使用已经足够满足大多数需求，更高级别的指针较为少见。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaSC1TNmdqckg1SW53SXd4WXRlTzhZQlpmWlRaR2kxLUdSSEtZTWRtQ1oyWGc_ZT1GVzZLMGs.png" alt="202311141235153.png" /></p>
<h2 id="函数指针与-typedef"><a class="anchor" href="#函数指针与-typedef">#</a> 函数指针与 typedef</h2>
<h3 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h3>
<p><strong>函数指针的概念</strong>：</p>
<ol>
<li><strong>定义</strong>： 函数指针是一种特殊的指针类型，它存储的是函数的地址。函数指针允许将函数作为参数传递给其他函数，或者在运行时动态地调用函数。</li>
<li><strong>函数地址</strong>：
<ul>
<li>每个函数在编译后都会转换为一系列机器指令，这些指令存储在程序的代码段（只读）中。</li>
<li>函数的地址是指向这些指令序列起始点的内存地址，即函数的入口点。</li>
</ul>
</li>
</ol>
<p><strong>函数指针的用途</strong>：</p>
<ol>
<li><strong>提高编程灵活性</strong>：函数指针的主要作用是将函数作为参数传递给其他函数，这使得编程更加灵活。</li>
<li><strong>函数回调</strong>：
<ul>
<li>将函数作为参数传递的语法被称为 “函数回调”。被传参的函数称为回调函数。</li>
<li>通过函数回调，可以在运行时自由地决定调用哪个函数，这为程序提供了更大的灵活性和可扩展性。</li>
</ul>
</li>
<li><strong>应用示例</strong>：
<ul>
<li>排序函数  <code>qsort</code>  使用函数指针作为参数，允许用户传递自定义的比较函数，实现任意规则的排序。</li>
<li>映射函数  <code>map</code>  使用函数指针作为参数，允许用户传递自定义的映射规则，实现任意规则的映射。</li>
</ul>
</li>
</ol>
<p><strong>函数指针变量的基本使用</strong>：</p>
<ol>
<li><strong>声明函数指针变量</strong>：
<ul>
<li>函数指针变量的声明需要指定函数的返回值类型、指针变量名以及函数的参数列表。</li>
<li>语法示例：  <code>返回值类型(∗指针变量名)(参数列表);</code></li>
<li>为了简化使用，可以为函数指针类型起别名： <code>typedef 返回值类型(∗函数指针别名)(参数列表);</code></li>
</ul>
</li>
<li><strong>初始化函数指针变量</strong>：
<ul>
<li>在 C 语言中，函数名代表该函数的地址，因此可以直接使用函数名来初始化函数指针变量。</li>
<li>函数指针变量的初始化类似于数组名的使用，函数名不能被改变指向。</li>
</ul>
</li>
<li><strong>函数指针的等价性</strong>：函数名和取地址操作  <code>&amp;函数名</code>  是完全等价的，编译器会自动判断它们是同等概念。</li>
<li><strong>调用函数指针</strong>：
<ul>
<li>有多种方式可以通过函数指针调用函数：
<ol>
<li>直接使用函数指针变量调用函数。</li>
<li>使用函数指针变量解引用后调用函数（不推荐，编译器会自动优化）。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 给 void 返回值类型和 void 形参的函数指针类型起一个别名</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>VoidPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 给 int 返回值类型和 int 形参的函数指针类型起一个别名</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>IntPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"有一种爱叫做放手!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"传参的数字是: %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 函数指针类型作为形参，这种方式会麻烦一些，不推荐</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 推荐使用类型别名</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span>VoidPtr ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 声明一个函数指针类型变量 ptr, 可以指向函数 test</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> test<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">// 声明一个函数指针类型变量 ptr2, 可以指向函数 test2</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> test2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 利用别名，可以更简单的声明函数指针类型的变量</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    VoidPtr ptr3 <span class="token operator">=</span> test<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    IntPtr ptr4 <span class="token operator">=</span> test2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>test<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 和上面等价的调用方式</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token comment">// 以下四种方式都是等价的</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 推荐</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr4<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 不推荐</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token keyword">int</span> ret3 <span class="token operator">=</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 推荐</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">int</span> ret4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>test2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 不推荐</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmWEtFNm95RHZOT3VfbF9fOUtaQS1ZQkw2eWFpZEJFdy04Y09MSjBJVV9maFE_ZT1yMTJVMFo.png" alt="" /></p>
<h3 id="打印现有的函数地址"><a class="anchor" href="#打印现有的函数地址">#</a> 打印现有的函数地址</h3>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">InitPointer</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> default_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> default_value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main: %#x\n"</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// main: 0x1ffa10e6</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;main: %#x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &amp;main: 0x1ffa10e6</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pointer: %#x\n"</span><span class="token punctuation">,</span> InitPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// pointer: 0x1ffa118b</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;pointer: %#x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>InitPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &amp;pointer: 0x1ffa118b</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="函数地址存入指针变量"><a class="anchor" href="#函数地址存入指针变量">#</a> 函数地址存入指针变量</h3>
<p>在 C 语言中，函数名本身就表示了函数的入口地址，这意味着我们可以将函数的地址赋给一个指针变量，这种指针称为函数指针。为了正确地声明一个函数指针，我们需要确保指针的类型与它所指向的函数的签名（返回类型和参数列表）一致。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">// 观察两者的区别，数据类型不变，（变量名）改换为（* + 变量名）</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// void InitPointer(int **ptr, int length, int default_value)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 对比上面进行改写，数据类型 void + * + 指针变量名 + 函数的参数</span></pre></td></tr></table></figure><h3 id="使用函数指针"><a class="anchor" href="#使用函数指针">#</a> 使用函数指针</h3>
<p>函数指针在 C 语言中允许我们将函数的执行能力 “存储” 在一个变量中。使用函数指针就像使用普通函数一样，但首先需要声明一个正确类型的指针变量，使其指向特定的函数。</p>
<p>一旦函数指针被正确初始化，就可以通过以下几种方式调用它指向的函数：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等同于 InitPointer (&amp;p, 5, 1);</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">InitPointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span><span class="token operator">*</span>InitPointer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注意，这样也能调用</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1 1 1 1 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//p 是动态分配的内存，别忘记要 free ()/ &amp;pointer: 0x1ffa118b</span></pre></td></tr></table></figure><ol>
<li>
<p>直接使用函数指针调用： <code>func (&amp;p, 5, 1);</code>  这里  <code>func</code>  是指向函数的指针。</p>
</li>
<li>
<p>使用函数名调用： <code>InitPointer (&amp;p, 5, 1);</code>  这里  <code>InitPointer</code>  是函数名。</p>
</li>
<li>
<p>通过解引用函数指针调用： <code>(*func)(&amp;p, 5, 1);</code>  这里通过解引用  <code>func</code>  来调用函数。</p>
</li>
<li>
<p>通过解引用函数名调用： <code>(*InitPointer)(&amp;p, 5, 1);</code>  这种方式较少使用，但语法上是正确的。这种用法与数组名类似，数组名是指向数组第一个元素的指针常量。相应地，函数名在大多数表达式中表现得就像指向函数的指针常量。当我们对函数名进行解引用时，我们实际上是在获取函数的入口地址，并直接调用该地址处的代码。</p>
</li>
</ol>
<p>在上述示例中， <code>p</code>  是动态分配的内存，因此在不再需要时，应使用  <code>free (p);</code>  来释放内存。</p>
<p>函数指针与函数名的关系在于，函数名在大多数情况下被编译器视为指向该函数的指针常量。因此，当我们将函数名用于调用时，编译器实际上在背后使用了一个隐式的函数指针。函数指针提供了这种隐式行为的显式形式，允许程序员在运行时动态地改变函数的行为。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: %#x\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a: 0x606ffc68</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a: %#x\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &amp;a: 0x606ffc68</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p: %#x\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// p: 0x606ffc68</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// == int *(f1 (int, double)), f1 函数，返回值是指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 2</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>f2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数指针，返回值是 int</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 3</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>f3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数指针，返回值是 int*</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 4 这里实质上是一个函数指针，不过返回值是数组，但 C 语言不支持返回值是数组，所以会报错</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 写成刚才那样看不出返回值，如果写成这样呢：int [] (*f4)(int, double); 类似 java 的方式，是不是清晰多了</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 之所以把括号放在后面，是因为 C 定义数组的时候是 int a [] 而不是 int [] a，所以这里函数返回数组的时候，括号也要放在后面</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">//int (*f4)(int, double)[];  // 如果将 (*f4)(int, double) 看作一个整体，当成 a，是不是 int a [];</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 5</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">//int (*f5)[](int, double);  // 把 (*f5) 看作 f，这里就变换为 int f [](int, double)，其实是个函数数组，但这在 C 语言中是不允许的</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 6 注意，[] 优先级比 * 优先级要高</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>f6<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// == int (*(f6 []))(int, double); 注意结合顺序，f6 先和 [] 结合</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 首先这是一个 f6 数组，然后是这是一个什么类型的数组呢？其实是一个指针类型的 f6 数组；然后这个指针是什么类型呢？其实是一个函数类型的指针；所以合起来就是函数指针的数组，每一个元素都是一个函数指针</span></pre></td></tr></table></figure><h3 id="typedef"><a class="anchor" href="#typedef">#</a> typedef</h3>
<p><strong>类型别名的优势</strong>：</p>
<ol>
<li><strong>提升代码可读性</strong>：通过为数据类型定义一个描述性的别名，可以增强代码的可读性和直观性。例如，在实现链表时，可以将链表的节点定义为一个结构体类型，并为其提供一个直观的别名，如  <code>Node</code> ，而不是使用通用的  <code>struct</code>  关键字。</li>
<li><strong>增强代码的扩展性</strong>：使用类型别名可以简化代码的修改和扩展。例如，如果链表中存储的数据类型需要改变，只需修改类型别名的定义，而无需修改链表实现中的每个数据类型声明。</li>
<li><strong>提高代码的跨平台性</strong>：类型别名允许程序员为不同的平台定义适当的数据类型。例如，在 32 位平台上，可以使用  <code>int</code>  作为大整数的类型，而在 16 位平台上，可以使用  <code>long long</code> 。通过修改类型别名的定义，可以确保代码在不同平台上的一致性和正确性。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token operator">*</span>IntPtr<span class="token punctuation">;</span>    <span class="token comment">// 将 int* 取别名为 IntPtr</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IntPtr p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> IntArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//typedef int [] IntArray; 这样写虽然不合法，但是不是清楚了许多，为创建数组取个别名，叫 IntArray</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IntArray array2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="qsort"><a class="anchor" href="#qsort">#</a> qsort</h2>
<h3 id="函数声明与参数"><a class="anchor" href="#函数声明与参数">#</a> 函数声明与参数</h3>
<p><code>qsort</code>  函数是基于快速排序算法实现的，它不是稳定的排序算法，这意味着相同元素的相对顺序可能会在排序过程中改变。</p>
<ol>
<li><strong>函数声明</strong>：  <code>void qsort(void* ptr, size_t count, size_t size, int (*comp)(const void*, const void*));</code></li>
<li><strong>参数解释</strong>：
<ul>
<li><code>base</code> ：通用指针类型，指向需要排序的数组的起始位置。由于是通用指针，它可以指向任意类型的数组。</li>
<li><code>num</code> ：无符号整数，表示数组  <code>base</code>  中元素的个数，即数组的长度。</li>
<li><code>size</code> ：无符号整数，表示数组  <code>base</code>  中每个元素的大小（以字节为单位）。</li>
<li><code>compare</code> ：函数指针，指向一个比较函数，用于比较两个元素。该函数应返回一个整数，如果第一个参数小于第二个参数则返回负数，如果相等则返回 0，如果大于则返回正数。</li>
</ul>
</li>
<li><strong>比较函数示例</strong>： <code>int compare(const void *a, const void *b);</code>
<ul>
<li>这个函数应该根据数组元素的类型进行相应的比较逻辑实现。</li>
</ul>
</li>
<li><strong>比较函数的返回值</strong>：
<ul>
<li>如果返回值大于 0，则认为  <code>a</code>  大于  <code>b</code> ，在排序中  <code>a</code>  应该在  <code>b</code>  的后面。</li>
<li>如果返回值小于 0，则认为  <code>a</code>  小于  <code>b</code> ，在排序中  <code>a</code>  应该在  <code>b</code>  的前面。</li>
<li>如果返回值等于 0，则认为  <code>a</code>  和  <code>b</code>  相等，在排序中  <code>a</code>  和  <code>b</code>  的位置可以相邻。</li>
</ul>
</li>
</ol>
<h3 id="示例代码"><a class="anchor" href="#示例代码">#</a> 示例代码</h3>
<h4 id="int-数组从大到小排序"><a class="anchor" href="#int-数组从大到小排序">#</a>  <code>int</code>  数组从大到小排序</h4>
<p>在  <code>qsort</code>  函数的比较函数中，参数  <code>a</code>  和  <code>b</code>  是通用指针类型，它们代表待排序数组中两个待比较元素的指针。</p>
<ol>
<li><strong>参数  <code>a</code>  和  <code>b</code>  的含义</strong>：当待排序的数组是  <code>int</code>  类型时， <code>a</code>  和  <code>b</code>  实际上就是指向  <code>int</code>  类型的指针。</li>
<li><strong>排序规则</strong>：如果排序规则是从大到小，即按照  <code>int</code>  数值的降序排序，比较函数需要相应地调整。</li>
<li><strong>比较逻辑</strong>：站在元素  <code>a</code>  的立场上，如果  <code>a</code>  的值越大，它应该在排序后的数组中排在前面。这意味着在比较函数中， <code>a</code>  应该被认为小于  <code>b</code> 。</li>
<li><strong>比较函数的返回值</strong>：为了让值较大的元素排在前面，比较函数应该在  <code>a</code>  值较大时返回负数。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">my_cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>num1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>num2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">*</span>num2 <span class="token operator">-</span> <span class="token operator">*</span>num1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">245</span><span class="token punctuation">,</span> <span class="token number">346</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3245</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2343</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ARR_SIZE</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> my_cmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="字符串数组按照字典序排序"><a class="anchor" href="#字符串数组按照字典序排序">#</a> 字符串数组按照字典序排序</h4>
<p>当使用  <code>qsort</code>  函数对字符串数组进行排序时，需要提供一个自定义的比较函数，该函数根据  <code>strcmp</code>  的返回值来确定字符串的相对顺序。</p>
<ol>
<li><strong>比较函数  <code>my_cmp2</code>  的实现</strong>：
<ul>
<li>该函数接受两个  <code>const void*</code>  类型的参数，它们是指向待比较字符串的指针。</li>
<li>由于数组元素是  <code>char*</code>  类型，参数  <code>a</code>  和  <code>b</code>  实际上是指向  <code>char*</code>  的指针，即二级指针  <code>char**</code> 。</li>
</ul>
</li>
<li><strong>正确地解引用指针</strong>：不能直接将二级指针转换为一级指针，需要先解引用。例如， <code>*(char **)a</code>  正确地获取了指向字符串的指针。</li>
<li><strong>比较函数的返回值</strong>：使用  <code>strcmp</code>  函数比较两个字符串。 <code>strcmp</code>  返回 0 如果两个字符串相等，返回小于 0 的值如果第一个字符串在字典序上在前，返回大于 0 的值如果第一个字符串在字典序上在后。</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">my_cmp2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">//(char*) a;	// 典型错误，二级指针不能直接强转成一级指针，需要解引用才行</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>str1 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> <span class="token comment">// () 不能省略，省略就错了</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span> <span class="token comment">// () 不能省略，省略就错了</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>strs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"aaa"</span><span class="token punctuation">,</span> <span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token string">"bbb"</span><span class="token punctuation">,</span> <span class="token string">"ccc"</span><span class="token punctuation">,</span> <span class="token string">"nba"</span><span class="token punctuation">,</span> <span class="token string">"bca"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> strs_len <span class="token operator">=</span> <span class="token function">ARR_SIZE</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">qsort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> strs_len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> my_cmp2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="结构体数组排序"><a class="anchor" href="#结构体数组排序">#</a> 结构体数组排序</h3>
<p>结构体定义：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> stu_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> total_socre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> Student<span class="token punctuation">;</span></pre></td></tr></table></figure><p>将学生数组按照成绩由高到低排序：为了实现降序排序，比较函数计算  <code>s2</code>  的总成绩与  <code>s1</code>  的总成绩之差。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">my_ruler1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Student <span class="token operator">*</span>s1 <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	Student <span class="token operator">*</span>s2 <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">return</span> s2<span class="token operator">-></span>total_socre <span class="token operator">-</span> s1<span class="token operator">-></span>total_socre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>将学生数组按照学号从小到大排序：为了实现升序排序，比较函数计算  <code>s1</code>  的学号与  <code>s2</code>  的学号之差</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">my_ruler2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Student <span class="token operator">*</span>s1 <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	Student <span class="token operator">*</span>s2 <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">return</span> s1<span class="token operator">-></span>stu_id <span class="token operator">-</span> s2<span class="token operator">-></span>stu_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>综合排序：先按总分从高到低进行排序，若总分相同则按照年龄从低到高排序，若仍然都相同，则按照名字的逆字典顺序排序。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">my_ruler3</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	Student <span class="token operator">*</span>s1 <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	Student <span class="token operator">*</span>s2 <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token operator">-></span>total_socre <span class="token operator">!=</span> s2<span class="token operator">-></span>total_socre<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		<span class="token keyword">return</span> s2<span class="token operator">-></span>total_socre <span class="token operator">-</span> s1<span class="token operator">-></span>total_socre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">// 代码运行到这里，说明总分是一样的，于是按照年龄排序 (但前提是年龄不相同)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token operator">-></span>age <span class="token operator">!=</span> s2<span class="token operator">-></span>age<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token keyword">return</span> s1<span class="token operator">-></span>age <span class="token operator">-</span> s2<span class="token operator">-></span>age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">// 代码运行到这里，说明总分和年龄都是一样的，于是按照名字的逆字典顺序排列</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>s2<span class="token operator">-></span>name<span class="token punctuation">,</span> s1<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i>C</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-12-11 16:21:35" itemprop="dateModified" datetime="2024-12-11T16:21:35+08:00">2024-12-11</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="http://cwlrin.github.io/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" title="C语言指针">http://cwlrin.github.io/c-cpp/c-base/C 语言指针/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/" rel="prev" itemprop="url" title="C 语言结构体" style="background-image: linear-gradient(to bottom right, #b2b2e9, #ccd9ad);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言结构体</h3></a></div><div class="item right"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/" rel="next" itemprop="url" title="C 语言数据结构——链表" style="background-image: linear-gradient(to bottom right, #9da1a6, #f5fd82);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言数据结构——链表</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text"> 指针基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text"> 指针的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E6%8C%87%E5%90%91%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text"> 只读指针变量和（指向）只读变量（的）指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%8C%87%E9%92%88"><span class="toc-number">3.</span> <span class="toc-text"> 特殊指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E8%87%AA%E5%B7%B1"><span class="toc-number">3.1.</span> <span class="toc-text"> 指针指向自己</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text"> 野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text"> 空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text"> 悬空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%8C%87%E9%92%88"><span class="toc-number">3.5.</span> <span class="toc-text"> 通用指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.</span> <span class="toc-text"> 指针的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text"> 指针的加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%AF%94%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.2.</span> <span class="toc-text"> 指针变量比大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.</span> <span class="toc-text"> 数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.</span> <span class="toc-text"> 数组名和指针的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">5.2.</span> <span class="toc-text"> 数组作为参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">5.3.</span> <span class="toc-text"> 指针数组和数组指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84-7-%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text"> 数组的 7 种写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text"> 左值和右值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text"> 指针参数作为返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%9B%BF%E4%BB%A3%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text"> 指针替代数组作为返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%87%BD%E6%95%B0%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text"> 跨函数通过指针修改局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%92%8C%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">7.3.</span> <span class="toc-text"> 指针传递和修改的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%A7%84%E5%BE%8B"><span class="toc-number">7.4.</span> <span class="toc-text"> 函数形参列表中的规律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.5.</span> <span class="toc-text"> 使用函数返回值的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text"> 大数返回值的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text"> 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%9F%E9%99%90"><span class="toc-number">8.1.</span> <span class="toc-text"> 存储期限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text"> 栈内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text"> 堆内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.4.</span> <span class="toc-text"> 内存分配使用的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">9.</span> <span class="toc-text"> 动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-number">9.1.</span> <span class="toc-text"> malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">9.2.</span> <span class="toc-text"> 内存泄露与内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calloc"><span class="toc-number">9.3.</span> <span class="toc-text"> calloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#realloc"><span class="toc-number">9.4.</span> <span class="toc-text"> realloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-number">9.5.</span> <span class="toc-text"> free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E4%B9%8B%E5%90%8E"><span class="toc-number">9.6.</span> <span class="toc-text"> 分配内存之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.7.</span> <span class="toc-text"> 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text"> 二级指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E-typedef"><span class="toc-number">11.</span> <span class="toc-text"> 函数指针与 typedef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">11.1.</span> <span class="toc-text"> 函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E7%8E%B0%E6%9C%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">11.2.</span> <span class="toc-text"> 打印现有的函数地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E5%AD%98%E5%85%A5%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">11.3.</span> <span class="toc-text"> 函数地址存入指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">11.4.</span> <span class="toc-text"> 使用函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef"><span class="toc-number">11.5.</span> <span class="toc-text"> typedef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qsort"><span class="toc-number">12.</span> <span class="toc-text"> qsort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text"> 函数声明与参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text"> 示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-%E6%95%B0%E7%BB%84%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.1.</span> <span class="toc-text">  int  数组从大到小排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%8C%89%E7%85%A7%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.2.</span> <span class="toc-text"> 字符串数组按照字典序排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text"> 结构体数组排序</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C 语言数据类型">C 语言数据类型</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5/" rel="bookmark" title="C 语言语句">C 语言语句</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/" rel="bookmark" title="C 语言函数">C 语言函数</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6/" rel="bookmark" title="C 语言头文件">C 语言头文件</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/" rel="bookmark" title="C 语言数组">C 语言数组</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="bookmark" title="C 语言字符串">C 语言字符串</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/" rel="bookmark" title="C 语言结构体">C 语言结构体</a></li><li  class="active"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" rel="bookmark" title="C语言指针">C语言指针</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——链表">C 语言数据结构——链表</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" rel="bookmark" title="C 语言数据结构——栈">C 语言数据结构——栈</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/" rel="bookmark" title="C 语言数据结构——队列">C 语言数据结构——队列</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——哈希表">C 语言数据结构——哈希表</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="bookmark" title="C 语言数据结构——二叉搜索树">C 语言数据结构——二叉搜索树</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" rel="bookmark" title="C 语言排序">C 语言排序</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81/" rel="bookmark" title="C 语言文件流">C 语言文件流</a></li><li ><a href="/c-cpp/c-base/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="bookmark" title="进程虚拟内存空间">进程虚拟内存空间</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.4m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">21:46</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `c-cpp/c-base/C 语言指针/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.20" type="module" fetchpriority="high" defer></script></body></html>