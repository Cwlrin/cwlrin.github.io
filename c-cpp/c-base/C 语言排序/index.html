<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="https://cwlrin.wiki/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.20"><link rel="modulepreload" href="/js/chunk-7SEFNKBW.js"></link><link rel="modulepreload" href="/js/chunk-B6LR4GZ7.js"></link><link rel="modulepreload" href="/js/chunk-R2ID445Y.js"></link><link rel="modulepreload" href="/js/copy-tex-6KGJ4I7N.js"></link><link rel="modulepreload" href="/js/index.esm-77JWK77F.js"></link><link rel="modulepreload" href="/js/post-NFR2DBU7.js"></link><link rel="modulepreload" href="/js/quicklink-KETDXBC3.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSRHNMcV9ES214SHVhWE9hYnFXRnY0Qm1FTG1zYkRKcXZrSUhJU1o1R3pwWUE_ZT0zdGhkSks.png" as="image" fetchpriority="high"><meta name="keywords" content="C,"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="https://cwlrin.wiki/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/"><title>C 语言排序</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C 语言排序</h1><div class="meta"><span class="item" title="创建时间：2020-03-15 12:25:05"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-03-15T12:25:05+08:00">2020-03-15</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>20k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSRHNMcV9ES214SHVhWE9hYnFXRnY0Qm1FTG1zYkRKcXZrSUhJU1o1R3pwWUE_ZT0zdGhkSks.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/c-basic/" itemprop="item" rel="index" title="分类于C 语言基础"><span itemprop="name">C 语言基础<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwlrin.wiki/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="算法性能分析"><a class="anchor" href="#算法性能分析">#</a> 算法性能分析</h2>
<p>时间复杂度描述了算法执行所需指令数量随着输入数据规模增长的变化趋势。它是一个理论概念，用于预测算法在不同规模输入下的性能表现，更好的时间复杂度通常意味着在相同条件下，算法的运行时间更短。</p>
<p>空间复杂度描述了算法执行过程中所需额外内存空间随着输入数据规模增长的变化趋势。它同样是一个理论概念，用于评估算法的内存使用效率，更好的空间复杂度意味着在相同条件下，算法占用的空间更少。</p>
<p>大 O 表示法是一种用来描述算法性能的数学符号，它提供了算法时间或空间需求的上界估计。通过忽略算法复杂度表达式中的低阶项和常数因子，大 O 表示法简化了对算法性能的分析，这种简化使得算法的渐进行为（随着输入规模的增长）更加突出，便于比较不同算法的效率。</p>
<p>例如，如果一个算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，这意味着在最坏的情况下，算法的执行时间随着输入规模 n 的增长而按二次方增长。同样，如果一个算法的空间复杂度为 O (n)，这意味着算法所需的额外内存空间随着输入规模线性增长。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VXTkZoNGRtWkpCSG9pbmlJM0Mtc3dZQi1zSmFPVWdVWXdXMUI0V3F1d2Eza2c_ZT1jYjJ6Yks.png" alt="202401151901805.png" /></p>
<p>在讨论算法的时间复杂度时，以下几点是关键：</p>
<ol>
<li><strong>可接受的性能</strong>：如果一个算法的时间复杂度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，通常认为其性能是可以接受的。这意味着算法的运行时间随着输入规模的增长而按二次方增长。</li>
<li><strong>更优的性能</strong>：如果算法的时间复杂度优于 O (n)，即亚线性时间，这通常被认为是非常优秀的。这类算法的运行时间增长慢于线性时间算法。</li>
<li><strong>算法适用性</strong>：即使算法的时间复杂度不是最优的，这并不意味着算法不可用。它可能在处理大数据集时效率不高，但在小数据集上仍然表现良好。</li>
<li><strong>小数据集的适用性</strong>：对于小数据集，即使时间复杂度高，指令数量的增加也不会太显著。因此，一些简单但时间复杂度不低的算法，如插入排序，可能仍然是合适的选择。</li>
<li><strong>大数据集的挑战</strong>：在大数据集的情况下，算法的时间复杂度变得尤为重要。高效的算法可以显著减少处理时间和资源消耗。</li>
<li><strong>算法选择</strong>：选择算法时，应根据数据集的大小、问题的具体需求和算法的实现复杂度来综合考虑。</li>
</ol>
<h2 id="排序算法"><a class="anchor" href="#排序算法">#</a> 排序算法</h2>
<p>有七种常见的排序算法：</p>
<ol>
<li><strong>冒泡排序</strong>：通过重复遍历待排序的数列，比较每对相邻元素的大小，并在必要时交换它们的位置。它的时间复杂度通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>选择排序</strong>：反复寻找未排序序列中的最小（或最大）元素，并将其放置在序列的起始位置。它的平均时间复杂度同样为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>插入排序</strong>：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。它在小数据集或基本有序的数据集中表现优异。</li>
<li><strong>希尔排序</strong>：也称为缩小增量排序，是插入排序的一种更高效的改进版本。它通过引入增量的概念来对数组进行分组，然后对每组进行插入排序。</li>
<li><strong>快速排序</strong>：一种分而治之的排序算法，通过选取一个 “基准” 元素并将数列分为两部分，一部分包含所有小于基准的元素，另一部分包含所有大于基准的元素。</li>
<li><strong>归并排序</strong>：通过递归地将数组分成两半，对每一半进行排序，然后将排序好的两半合并在一起。它是一种稳定的排序算法，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>堆排序</strong>：利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的属性：即子节点的键值或索引总是小于（或者大于）它的父节点。</li>
</ol>
<p>对于以上排序算法：</p>
<ul>
<li>冒泡排序和选择排序通常仅用于教学目的，因为它们在实际应用中的效率较低。</li>
<li>插入排序适用于小数据集或部分有序的数据集，性能较好。</li>
<li>希尔排序在某些情况下可能不如插入排序或更高级的排序算法。</li>
<li>快速排序、归并排序和堆排序是适用于大数据集的高效排序算法，具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log ⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度。</li>
</ul>
<h2 id="选择排序"><a class="anchor" href="#选择排序">#</a> 选择排序</h2>
<p>选择排序（Selection Sort）是一种直观且易于理解的排序算法，它体现了一种直接且原始的问题解决方法。尽管它简单，但通常不推荐在实际应用中使用，因为它的性能相对较差。</p>
<p>在讲解排序算法时，通常以将一个整数数组从小到大排序为例，这有助于简化算法的实现和理解。当然，排序算法的思想同样适用于其他类型的元素或逆序排序的场景。</p>
<p>以数组 [16, 1, 45, 23, 99, 2, 18, 67, 42, 10] 为例，选择排序的工作原理如下：</p>
<ol>
<li><strong>第一轮选择</strong>：初始时，整个数组视为未排序。选择从数组开头到结尾的最小元素，并将其放置在数组的开头位置。</li>
<li><strong>第二轮选择</strong>：剩余的数组部分（从第二个元素开始）被视为未排序。在这部分中找到最小元素，并将其移动到第二个位置。</li>
<li><strong>重复选择</strong>：在每一轮选择中，继续在剩余的未排序元素中寻找最小值，并将其放置在未排序序列的开头。</li>
<li><strong>最后一轮选择</strong>：当未排序序列的开头到达倒数第二个元素时，执行最后一轮选择。此时，数组中只剩下最后一个元素，它自然就是最大值，排序完成。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VaRmx2TzFLZTI5QnNMVUgyR0U1OFZVQnAyS2ZCdWE3bmZkd2NuMlp6bmFqMEE_ZT1JdWdBQ1M.png" alt="202401151904154.png" /></p>
<p>选择排序的特点是它不使用额外的存储空间（除了临时变量），但时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这使得它在处理大数据集时效率较低。尽管如此，由于其实现简单，选择排序在教学和理解排序算法的基本概念时非常有用。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ARR_LEN</span><span class="token expression"><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      </span><span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token expression"><span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           </span><span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token expression">arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            </span><span class="token punctuation">\</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token expression">arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token expression"><span class="token punctuation">&#125;</span>                               </span><span class="token punctuation">\</span></pre></td></tr><tr><td data-num="10"></td><td><pre></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">print_arr</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 选择排序</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="21"></td><td><pre>     * i 表示未排序序列的开头元素</pre></td></tr><tr><td data-num="22"></td><td><pre>     * 最后一轮选择排序时，未排序序列的开头元素是数组倒数第二个元素</pre></td></tr><tr><td data-num="23"></td><td><pre>     * i 的每个取值都表示一轮选择排序</pre></td></tr><tr><td data-num="24"></td><td><pre>     * 也就是选择排序一共执行 9 趟</pre></td></tr><tr><td data-num="25"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 不妨直接假设未排序序列的开头 i 位置元素就是最小值</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">int</span> min_index <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 遍历未排序数组序列，找出真正的最小值下标，此时应遍历最后一个元素</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                min_index <span class="token operator">=</span> j<span class="token punctuation">;</span>  <span class="token comment">// 记录较小值的下标</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span>   <span class="token comment">//for 循环结束时，未排序序列的最小值下标就是 min_index</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">// 交换 min_index 和下标 i 的元素</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> min_index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token comment">// 选择排序一趟打印一次数组</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token function">print_arr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="冒泡排序"><a class="anchor" href="#冒泡排序">#</a> 冒泡排序</h2>
<p>冒泡排序（Bubble Sort）是一种基础的排序算法，以其操作形象得名。尽管它简单易懂，但其效率相对较低，因此在实际应用中并不常用，更多地作为教学工具来帮助理解排序算法的基本概念。</p>
<p>以数组 [16, 1, 45, 23, 99, 2, 18, 67, 42, 10] 为例，冒泡排序的工作原理如下：</p>
<ol>
<li><strong>第一轮冒泡</strong>：从数组的第一个元素开始，对相邻元素进行比较。如果当前元素大于其相邻的下一个元素，则交换它们。这样，经过一轮比较后，最大的元素会被 “冒泡” 到它应该在的位置，即数组的末尾。</li>
<li><strong>后续轮次</strong>：在每一轮中，都将未排序部分的最大元素移动到其应在的位置。随着排序的进行，已排序的元素逐渐增多，需要比较的元素数量逐渐减少。</li>
<li><strong>优化</strong>：如果在一轮遍历中没有发生任何交换，这意味着数组已经有序，可以提前结束排序过程。</li>
<li><strong>结束条件</strong>：冒泡排序在最坏的情况下需要进行 n - 1 轮比较，其中 n 是数组的长度。但在优化的情况下，如果数组提前有序，可以减少比较次数。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZejFGdXpjeHh0QWpqR2RhSU1nU3drQkE5RHFZWkFVZ2o2V3R5UGJZM0ZKRXc_ZT1YdFdzZzk.png" alt="202401151904114.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmRGJIeHpuMmdGRmk3Q0tXaEJnZzlRQmhtZHBFSU1yX2prOG8wMXhWTU1SVnc_ZT1aRzA5RVI.png" alt="202401151904176.png" /></p>
<p>冒泡排序的时间复杂度在最坏和平均情况下都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最好情况下（即数组已经是有序的）时间复杂度为 O (n)。尽管有优化空间，但由于其固有的比较和交换操作，冒泡排序通常不适用于大型数据集的排序任务。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 外层 for 的 i 表示第几轮冒泡排序，最多需要进行 len - 1 轮</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 标记在这一次冒泡排序中有没有交换，false 表示没有交换</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        bool swapped <span class="token operator">=</span> false<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">/**</pre></td></tr><tr><td data-num="7"></td><td><pre>         * j 表示两两比较元素中的第一个元素的下标</pre></td></tr><tr><td data-num="8"></td><td><pre>         * 第一轮 j 的最大取值是数组倒数第二个元素，并且逐步减小</pre></td></tr><tr><td data-num="9"></td><td><pre>         * 所以 j 的条件是小于 (len - i)</pre></td></tr><tr><td data-num="10"></td><td><pre>         */</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 发生了交换改变标记</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                swapped <span class="token operator">=</span> true<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 在一轮冒泡排序中没有任何交换，则排序已经完成，终止循环</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>swapped<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 打印一轮冒泡排序后数组的元素排列</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token function">print_arr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="插入排序"><a class="anchor" href="#插入排序">#</a> 插入排序</h2>
<p>插入排序（Insertion Sort）是一种直观且易于实现的排序算法，其工作原理与打牌时整理手牌的过程相似。以下是对插入排序工作原理的描述：</p>
<ol>
<li><strong>初始化</strong>：将数组的第一个元素视为一个已排序的子序列。</li>
<li><strong>遍历数组</strong>：从数组的第二个元素开始，对数组进行遍历。</li>
<li><strong>比较与交换</strong>：
<ul>
<li>取出当前遍历到的元素，与已排序子序列中的元素从后向前逐一比较。</li>
<li>如果当前元素小于已排序子序列中的元素，则将后者向后移动，为当前元素腾出位置。</li>
<li>重复比较和移动过程，直到找到当前元素在已排序子序列中的合适位置或到达子序列的开头。</li>
</ul>
</li>
<li><strong>插入元素</strong>：将当前元素插入到已找到的位置。</li>
<li><strong>重复过程</strong>：继续遍历数组，重复步骤 3 和 4，直到所有元素都被插入到已排序子序列中。</li>
<li><strong>完成排序</strong>：当遍历到达数组的最后一个元素时，整个数组变为有序。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmcGZYNU9VTFMxRmt5bXc4bDJ6VEJBQm9RM0tUc0FiejdaVVNqUkZqakdsaUE_ZT1mS2w2MW4.png" alt="202401151904179.png" /></p>
<p>插入排序的时间复杂度在最坏情况下为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但如果输入数组已经接近有序，其性能会非常接近线性时间 O (n)。这使得插入排序在小数据集或部分有序的数据集中非常有效。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 外层 for 循环中的 i 表示每轮选择排序新插入元素的下标，也就是 "新摸手牌" 的下标</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 从数组第二个元素开始，后面的每一个元素都相当于 "你要摸的手牌"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 内层 for 循环的 j 表示新插入元素需要比较元素的下标，也就是每一张 "老手牌" 的下标</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">//j 从 i 的前一个位置开始，递减，但不可能成为负数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 注意：这里如果加等号就不是稳定的排序算法了</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 前面的元素比后面的元素大，交换</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 只需要在某一次比较中，发现前一个元素小于等于后一个元素</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 那么前面的元素就一定都是排序好的，此时这一轮选择排序结束</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 打印每一轮选择排序后，数组的元素序列</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">print_arr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="希尔排序"><a class="anchor" href="#希尔排序">#</a> 希尔排序</h2>
<p>希尔排序（Shell Sort）是由美国计算机科学家唐纳德・希尔（Donald Shell）在 1959 年提出的。这种排序算法是插入排序的一个改进版本，旨在通过引入增量的概念来提高排序效率。</p>
<p>希尔排序的工作原理：</p>
<ol>
<li><strong>增量序列</strong>：希尔排序的核心在于增量序列的选择。增量序列决定了排序过程中元素的比较和交换的步长。</li>
<li><strong>分组比较</strong>：通过增量，算法将数组分成多个组，每组内的元素间隔为增量值。例如，如果增量为 5，那么第一个元素与第五个元素比较，第二个元素与第六个元素比较。</li>
<li><strong>组内插入排序</strong>：在每组内进行插入排序，这允许较小的元素 “跳跃” 到前面的位置，从而减少整体的比较和移动次数。</li>
<li><strong>增量减小</strong>：完成一轮排序后，减小增量（通常是减半），并重复上述步骤。</li>
<li><strong>最终插入排序</strong>：当增量减小到 1 时，整个数组进行一次标准的插入排序，此时数组已经接近有序，因此排序效率很高。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VkM0lDSmRENWtkT2stMHRnOTRTbFBVQk10TUFESVhmM1ZGaXJIX1ZqQy1wdWc_ZT1vWnFnbGU.png" alt="202312061506009.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VTOFc3YW9TMFJaRW4ySjRybTNpVkFFQmVVMEl3bkFSZVAyTG1ralVrdncweVE_ZT1RNWlLU1U.png" alt="202312061506696.png" /></p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VhYmZneXBlUnBwTXFKd0hrTEFGbktvQm44VWNhWGNXZnhlN2RpOWtpMTlTMFE_ZT1zbVNUZVc.png" alt="202312061506466.png" /></p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 希尔排序：缩小增量排序，其实就是多人摸牌，逐渐减少摸牌人数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 希尔排序中，增量序列的设计非常重要，这里采取简单的 gap 序列：长度减半.. 一直减半，直到为 1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//gap 为 1 时就是一个在数组元素基本有序情况下的，插入排序</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 第一个元素是第一个人的初始手牌，一直到第 gap 个元素都是初始手牌</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> gap <span class="token operator">=</span> len <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 外层 for 的 i 仍然代表新摸到的手牌的下标，i 从 gap 开始，直到摸完整个数组元素</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 先记录一下新手牌的值，便于后续的插入操作</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>    <span class="token comment">// 代表每一个人旧手牌的最后一张牌</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 内层 for 代表 每个人每摸到一张新手牌，都会和原本的旧手牌比较，但由于 gap 存在，所以需要减去 gap</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意：不能加 =，加了就不稳定了</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 将旧手牌中大于新手牌的所有牌都向后移</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">else</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 只要发现一张旧手牌更小或相等，就说明已经找到新手牌的插入位置了</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token function">print_arr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 每一轮希尔排序后查看数组排序结果</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        gap <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 每一轮希尔排序，增量都减半</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>增量序列的选择：希尔本人提出的增量序列是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>n</mi><mn>2</mn></mfrac></mstyle><mo separator="true">,</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>n</mi><mn>4</mn></mfrac></mstyle><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\dfrac{n}{2}, \dfrac{n}{4},...,1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span> ，这种序列易于实现，但不是最优解。</p>
<p>时间复杂度：希尔排序的时间复杂度与增量序列的选择密切相关。使用希尔提出的增量序列，时间复杂度通常小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但在最坏情况下可能接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度：希尔排序是一种原地排序算法，不需要额外的内存空间，因此空间复杂度是 O (1)。</p>
<p>稳定性：</p>
<ul>
<li>希尔排序不是稳定的排序算法。由于其分组和插入排序的特性，相同的元素可能会因为分组的不同而改变相对位置。</li>
<li>假设有一个数组  <code>[4a,3,4b,2,1]</code> ，如果选择的增量是 3，那么第一轮希尔排序后的结果可能是  <code>[2,1,4b,4a,3]</code> ，这表明希尔排序可能会改变相同元素的相对顺序。</li>
</ul>
<p>希尔排序通过减少插入排序中的元素移动次数来提高效率，尤其适合于大规模数据集的初步排序。尽管它不是最高效的排序算法，但其简单性和对部分有序数据集的有效性使其在某些应用场景中仍然有其价值。</p>
<h2 id="归并排序"><a class="anchor" href="#归并排序">#</a> 归并排序</h2>
<ol>
<li>
<p><strong>归并排序函数的声明</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">mergesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数声明定义了归并排序的主要接口，其中  <code>arr</code>  是要排序的数组， <code>len</code>  是数组的长度。</p>
</li>
<li>
<p><strong>递归分解与合并的辅助函数声明</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">dividemerge_recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个辅助函数用于递归地分解数组区间，并在适当的时候合并这些区间，以完成排序。</p>
</li>
<li>
<p><strong> <code>dividemerge_recursion</code>  函数的实现</strong>：</p>
<ul>
<li><strong>分解思路</strong>：将数组  <code>arr</code>  的  <code>[left, right]</code>  区间分解为左右两个子区间，然后递归地对这两个子区间进行排序。</li>
<li><strong>区间中间索引</strong>：区间的中间索引可以通过  <code>((right - left) &gt;&gt; 1) + left</code>  计算得到，这是一种避免潜在溢出的高效计算方法。</li>
<li><strong>递归分解的出口</strong>：当  <code>left</code>  大于或等于  <code>right</code>  时，递归结束，因为这意味着区间内没有元素或只有一个元素，已经有序。</li>
<li><strong>合并操作</strong>：递归分解后，需要执行合并操作，将排序好的左右子区间合并为一个有序区间。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VkZ3lkdnM5Yno5SWk5MExMWHU4T0I4QkNLU0JqcW80ZW56QURRcEtjZ1cyUUE_ZT1EdEljSGc.png" alt="" /></p>
</li>
<li>
<p><strong>合并两个有序子数组的步骤：</strong></p>
<ol>
<li><strong>使用临时数组</strong>：为了简化合并过程，通常使用一个临时数组来存储合并后的结果。</li>
<li><strong>选择元素</strong>：在合并过程中，当左右子数组中有相同的元素时，应优先选择左子数组中的元素。这样做可以保持相等元素的原始顺序，从而确保归并排序的稳定性。</li>
<li><strong>合并结束条件</strong>：当任一子数组的索引超出其长度时，即认为该子数组已完全合并，此时合并过程结束。</li>
<li><strong>处理剩余元素</strong>：合并结束后，如果一个子数组还有剩余元素，应将这些元素复制到临时数组的末尾。</li>
<li><strong>复制回原数组</strong>：一旦临时数组包含了合并后的全部元素，应将这些元素复制回原数组的相应位置。</li>
</ol>
</li>
<li>
<p><strong>是否必须使用临时数组进行归并？</strong></p>
<p>归并排序的合并步骤可以通过以下方式实现，而不使用临时数组：</p>
<ol>
<li><strong>原地合并</strong>：理论上，可以通过在原数组上进行操作来实现原地合并，但这通常涉及到复杂的元素交换和可能的数组旋转。</li>
<li><strong>性能问题</strong>：原地合并可能会增加算法的复杂性，导致性能下降。在最坏的情况下，如果每次合并都需要大量交换，时间复杂度可能会接近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>稳定性问题</strong>：原地合并可能会破坏排序算法的稳定性，因为相同元素可能需要在数组中移动较远的距离。</li>
</ol>
<p><strong>选择哪种临时数组？</strong></p>
<p>对于使用临时数组的选择，有以下几种考虑：</p>
<ol>
<li><strong>栈局部变量临时数组</strong>：
<ul>
<li>优点：自动内存管理，方便安全，性能较高。</li>
<li>缺点：无法动态分配，长度需预先确定，不适合大数组合并。</li>
</ul>
</li>
<li><strong>数据段全局变量临时数组</strong>：
<ul>
<li>缺点：引入复杂性，维护困难，始终占用内存，无法动态分配。</li>
</ul>
</li>
<li><strong>堆动态临时数组</strong>：
<ul>
<li>优点：可以动态分配，适合大数组合并，空间大小可预先计算。</li>
<li>缺点：需要手动内存管理，存在一定风险，性能可能略低。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>： 尽管原地合并在理论上可行，但在实践中，使用临时数组进行归并排序的合并步骤更为常见和推荐。这种方法简单、高效，且保持了归并排序的稳定性和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度。</p>
</li>
<li>
<p>归并排序是一种经典的排序算法，其特点和性能表现如下：</p>
<ol>
<li><strong>输入质量无关性</strong>：归并排序的执行流程是固定的，先分解数组区间，然后逐步合并。因此，数据的初始状态对归并排序的执行没有影响，这使得其性能非常稳定和均衡。</li>
<li><strong>时间复杂度</strong>：在所有情况下，归并排序的时间复杂度始终保持为 O (nlog⁡n)<em>O</em>(<em>n</em> log <em>n</em>)，其中 n <em>n</em> 是数组的长度。</li>
<li><strong>空间复杂度</strong>：归并排序是非原地排序算法，需要使用临时数组来辅助合并过程，因此其空间复杂度为 O (n)<em>O</em>(<em>n</em>)。</li>
<li><strong>稳定性</strong>：归并排序是一种稳定的排序算法，能够保持相等元素的原始顺序，这在需要维持排序稳定性的场景中非常有用。</li>
</ol>
</li>
</ol>
<p><strong>归并排序的总结</strong>：</p>
<ul>
<li>在处理大数据集时，如果需要一个既高效又稳定的排序算法，归并排序是一个非常好的选择。</li>
<li>稳定性是归并排序的最大优势，这使得它在实际应用中非常受欢迎。</li>
<li>然而，归并排序也有一些缺点：
<ol>
<li>它的性能可能不如快速排序。</li>
<li>使用递归实现可能导致栈溢出的风险，尤其是在处理大数据集时。</li>
<li>需要占用额外的内存空间来存储临时数组。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ARR_SIZE</span><span class="token expression"><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 打印数组的函数</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">print_arr</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="15"></td><td><pre> * 合并的思路:</pre></td></tr><tr><td data-num="16"></td><td><pre> * 1. 把左右子数组中元素按照顺序合并到临时数组中，过程类似 "穿针引线"</pre></td></tr><tr><td data-num="17"></td><td><pre> * 2. 将排好序的临时数组元素按照下标赋值给原数组</pre></td></tr><tr><td data-num="18"></td><td><pre> * 注：临时数组和原数组共有一套下标</pre></td></tr><tr><td data-num="19"></td><td><pre> * 传入函数逻辑上的左右子数组是有序的，相当于合并两个有序的左右子数组</pre></td></tr><tr><td data-num="20"></td><td><pre> */</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="23"></td><td><pre>     * tmp_idx: 用于存放合并结果的临时数组的开始下标</pre></td></tr><tr><td data-num="24"></td><td><pre>     * left_idx: 左子数组的开始下标</pre></td></tr><tr><td data-num="25"></td><td><pre>     * right_idx: 右子数组的开始下标</pre></td></tr><tr><td data-num="26"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">int</span> tmp_idx <span class="token operator">=</span> left<span class="token punctuation">,</span> left_idx <span class="token operator">=</span> left<span class="token punctuation">,</span> right_idx <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 只要左右子数组同时还有元素</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left_idx <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> right_idx <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// 比较左右子数组的元素，按照从小到大放入临时数组</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// &lt;= 判断不会改变相同元素的相对位置，是稳定算法。反之则不是稳定算法</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left_idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>right_idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            tmp<span class="token punctuation">[</span>tmp_idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left_idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            tmp<span class="token punctuation">[</span>tmp_idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right_idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token comment">//  while 结束时，左右子数组必然有一个没有元素了，此时另一个数组必然还有元素</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">// 也就是说只会有一个数组是空的</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token comment">// 但我们无法确定是哪个数组没有元素了</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token comment">// 所以我们都判断一下将左右子数组还剩余的元素取出来</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left_idx <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token comment">// 说明左数组还有元素</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        tmp<span class="token punctuation">[</span>tmp_idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left_idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right_idx <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token comment">// 说明右数组还有元素</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        tmp<span class="token punctuation">[</span>tmp_idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right_idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token comment">// 将临时数组中已排序好的元素复制到原始数组中</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token comment">// 打印此一轮归并排序的元素</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token function">print_arr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="60"></td><td><pre></pre></td></tr><tr><td data-num="61"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="62"></td><td><pre> * 辅助函数，实现对 [left, right] 范围内的数组递归分解合并</pre></td></tr><tr><td data-num="63"></td><td><pre> * left 表示递归分解的区间起点，right 表示递归分解区间的终点，是一个闭区间</pre></td></tr><tr><td data-num="64"></td><td><pre> * 递归分解的思路是:</pre></td></tr><tr><td data-num="65"></td><td><pre> * 对 [left, right] 区间元素的排序，可以分解成:</pre></td></tr><tr><td data-num="66"></td><td><pre> * [left, mid] 区间，和 [mid + 1, right] 区间的排序合并</pre></td></tr><tr><td data-num="67"></td><td><pre> * 递归的出口是:</pre></td></tr><tr><td data-num="68"></td><td><pre> * 如果区间仅有一个元素或没有元素，递归结束</pre></td></tr><tr><td data-num="69"></td><td><pre> */</span></pre></td></tr><tr><td data-num="70"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">divide_merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token comment">// 递归的出口</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre></pre></td></tr><tr><td data-num="76"></td><td><pre>    <span class="token comment">// 递归体</span></pre></td></tr><tr><td data-num="77"></td><td><pre>    <span class="token comment">// 计算中间索引</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    <span class="token comment">// 分解，规定左数组是 [left, mid]</span></pre></td></tr><tr><td data-num="80"></td><td><pre>    <span class="token comment">// 右数组是 [mid + 1, right]</span></pre></td></tr><tr><td data-num="81"></td><td><pre>    <span class="token function">divide_merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    <span class="token function">divide_merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre></pre></td></tr><tr><td data-num="84"></td><td><pre>    <span class="token comment">/**</pre></td></tr><tr><td data-num="85"></td><td><pre>     * 归并，归并排序的核心操作</pre></td></tr><tr><td data-num="86"></td><td><pre>     * 需要一个临时数组完成此操作</pre></td></tr><tr><td data-num="87"></td><td><pre>     * 这个临时数组至少要和原先的数组一般大</pre></td></tr><tr><td data-num="88"></td><td><pre>     * 有两种方案：</pre></td></tr><tr><td data-num="89"></td><td><pre>     * 1. 用全局变量数组或局部变量，该方式简洁易实现，无需考虑内存回收</pre></td></tr><tr><td data-num="90"></td><td><pre>     *   但缺点是</pre></td></tr><tr><td data-num="91"></td><td><pre>     *   a. 必须编译时期确定数组长度，无法运行时期动态分配</pre></td></tr><tr><td data-num="92"></td><td><pre>     *   b. 栈区和数据段都无法创建长数组，在大数据集下容易产生溢出错误</pre></td></tr><tr><td data-num="93"></td><td><pre>     * 为了解决这两个缺点，我们可以在堆上动态分配数组</pre></td></tr><tr><td data-num="94"></td><td><pre>     *   但同样也有缺点:</pre></td></tr><tr><td data-num="95"></td><td><pre>     *   a. 内存管理风险</pre></td></tr><tr><td data-num="96"></td><td><pre>     *   b. 动态分配数组会带来额外性能开销</pre></td></tr><tr><td data-num="97"></td><td><pre>     */</span></pre></td></tr><tr><td data-num="98"></td><td><pre>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="99"></td><td><pre></pre></td></tr><tr><td data-num="100"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="101"></td><td><pre></pre></td></tr><tr><td data-num="102"></td><td><pre><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="103"></td><td><pre>    <span class="token comment">// 临时数组</span></pre></td></tr><tr><td data-num="104"></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="105"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="106"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"calloc failed in merge_sort.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="107"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="108"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="109"></td><td><pre></pre></td></tr><tr><td data-num="110"></td><td><pre>    <span class="token comment">// 将整个数组进行递归分解合并，即完成归并排序</span></pre></td></tr><tr><td data-num="111"></td><td><pre>    <span class="token function">divide_merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="112"></td><td><pre></pre></td></tr><tr><td data-num="113"></td><td><pre>    <span class="token comment">// 不要忘记 free 释放资源</span></pre></td></tr><tr><td data-num="114"></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="115"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="快速排序"><a class="anchor" href="#快速排序">#</a> 快速排序</h2>
<h3 id="单向分区"><a class="anchor" href="#单向分区">#</a> 单向分区</h3>
<ol>
<li>
<p><strong>单向分区快速排序的实现函数声明</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">quicksortoneway</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数声明定义了快速排序的主要接口，其中  <code>arr</code>  是要排序的数组， <code>len</code>  是数组的长度。</p>
</li>
<li>
<p><strong>辅助的递归函数声明</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">partitionrecursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个辅助函数用于递归地分解数组区间，并在分解过程中完成排序。</p>
</li>
<li>
<p><strong>分区操作</strong>：</p>
<ul>
<li>分区操作是快速排序的核心，它通过选择一个基准值（pivot）来确定其在最终排序数组中的定位。</li>
<li>分区过程将数组划分为两个子区间，一个包含所有小于基准值的元素，另一个包含所有大于基准值的元素。</li>
<li>递归地对这两个子区间进行分区操作，这个过程称为 “分而治之”。</li>
</ul>
</li>
<li>
<p><strong>分区与合并</strong>：分区操作完成后，由于快速排序是原地排序算法，子区间的排序会自动完成整个区间的排序，不需要额外的合并步骤。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VXaTB1X0s0bnZwSnZ4Q19WQWFUOFg4QjVkcHZnZ1A4NzhmVHhMSkxOSFB4NHc_ZT1HQm1qV20.png" alt="202312111445869.jpg" /></p>
</li>
</ol>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 分区核心操作实现，返回一轮快排选择的 pivot 的下标</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 随机选择一个基准值，然后把它先放到数组末尾</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> pivot_idx <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到一个 [left, right] 范围内的随机索引</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivot_idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot_idx<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 设置一个 partition_idx 索引，指示小于 pivot 的元素应该插入的位置</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 同时该索引最终表示分区的界限索引，所以命名为 partition_idx</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> partition_idx <span class="token operator">=</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 遍历整个数组，当元素小于 pivot 时，将它和 partition_idx 位置元素交换，partition_idx 加 1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 希望遍历结束时，i 指向数组末尾的 pivot，所以 i &lt; right</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> partition_idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            partition_idx<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 遍历结束后，将 pivot 元素 (最后一个元素) 交换到 partition_idx 位置</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">SWAP</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> right<span class="token punctuation">,</span> partition_idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 返回基准值的位置索引</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> partition_idx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="28"></td><td><pre> * 辅助函数</pre></td></tr><tr><td data-num="29"></td><td><pre> * 用于对对 [left, right] 区间中的元素进行递归分区操作</pre></td></tr><tr><td data-num="30"></td><td><pre> */</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">void</span> <span class="token function">partition_recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 递归出口</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">// 递归体</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分区操作，找到 pivot 元素的下标位置</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token keyword">void</span> <span class="token function">quick_sort_one_way</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token comment">// 初始化随机数生成器，time (NULL) 获取当前时间戳</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token comment">// 用于生成随机索引</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token comment">// 调用辅助函数进行递归分解</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>单向分区</strong>： 单向分区快速排序的实现使用一个索引来跟踪小于基准值的元素应该存储的位置。通过这个索引，算法将遍历数组，并将所有小于基准值的元素交换到数组的前部。一轮遍历结束后，基准值被放置在其最终位置，将数组分为左右两个子区间。</p>
<p><strong>单向分区的优化</strong>：</p>
<ol>
<li><strong>双向分区</strong>：在遍历数组的过程中，可以同时从两边开始，一边将小于基准值的元素向数组开头移动，另一边将大于基准值的元素向数组末尾移动。这种方法称为双向分区。</li>
<li><strong>元素赋值</strong>：为了避免元素交换，可以使用赋值操作来替代。这种方法减少了交换操作的开销，因为赋值通常比交换操作更高效。</li>
</ol>
<h3 id="双向分区"><a class="anchor" href="#双向分区">#</a> 双向分区</h3>
<p><strong>双向分区策略实现</strong>： 在双向分区中，使用两个索引  <code>low</code>  和  <code>high</code>  来对数组进行分区。</p>
<ol>
<li><strong>初始化</strong>：选择数组的第一个元素作为基准值，并将其交换到数组的开头，同时初始化  <code>low</code>  为 0， <code>high</code>  为数组长度减一。</li>
<li><strong> <code>low</code>  索引的作用</strong>：
<ul>
<li>指示下一个比基准值小的元素应该放置的位置。</li>
<li>从左向右遍历数组，寻找比基准值大或相等的元素，并将其覆盖到  <code>low</code>  索引的位置。</li>
</ul>
</li>
<li><strong> <code>high</code>  索引的作用</strong>：
<ul>
<li>指示下一个比基准值大或相等的元素应该放置的位置。</li>
<li>从右向左遍历数组，寻找比基准值小的元素，并将其覆盖到  <code>high</code>  索引的位置。</li>
</ul>
</li>
<li><strong>分区过程</strong>：
<ul>
<li>初始时， <code>high</code>  向左移动一位， <code>low</code>  向右移动一位，开始交替搜索过程。</li>
<li>当  <code>low</code>  遇到一个大于或等于基准值的元素，或  <code>high</code>  遇到一个小于基准值的元素时，交换这两个元素。</li>
<li>继续移动  <code>low</code>  和  <code>high</code> ，直到它们相遇。相遇点即为基准值的最终位置。</li>
</ul>
</li>
<li><strong>递归排序</strong>：一旦基准值就位，递归地对左侧和右侧的子区间执行相同的分区操作。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VjYnBZSlBIa21wT2lYNF9VU3BuTnI0QjVmMkhKSWlnNWVNR05PaU0yaUVDZ0E_ZT1kRXZnVGM.png" alt="202401142226630.png" /></p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 快速排序的核心操作：双向分区，也就是确定 pivot 的最终位置</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 挑选一个基准值，通过双向分区操作，决定最终的位置，最终位置就是基准值排好序的位置</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 为了简化实现，直接挑选首元素为基准值（因为基准值要交换到开头，所以直接挑选首元素作为基准值，可以减少一步交换）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 初始化两个索引 low 和 high，分别指向数组两端</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> low <span class="token operator">=</span> left<span class="token punctuation">,</span> high <span class="token operator">=</span> right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 循环遍历这个数组区间</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 两个索引没有相遇就继续循环</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 在两个索引没有相遇的情况下，high 索引用于寻找比基准值小的元素</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            high<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span>   <span class="token comment">//while 循环结束时，要么两个索引相遇了，要么 high 索引已经找到了一个比基准值小的元素</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 将这个比基准值小的元素覆盖到 low 位置</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">//low++;    该行语句不能加，因为若此时两个索引相遇结束 while，low++ 将导致相遇的索引不再相遇</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 在两个索引没有相遇的情况下，low 索引用于寻找比基准值大和相等的元素</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            low<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span>   <span class="token comment">//while 循环结束时，要么两个索引相遇了，要么 low 索引已经找到了一个比基准值大或相等的元素</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 将这个比基准值大或相等的元素覆盖到 high 位置</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">//high--;   该行语句不能加，因为若此时两个索引相遇结束 while，high-- 将导致相遇的索引不再相遇</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span>   <span class="token comment">//while 循环结束时，说明 low 和 high 索引相遇，此时该位置就是 pivot 应该放置的位置</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">return</span> low<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">// 对 [left, right] 区间进行递归分区操作</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">void</span> <span class="token function">partition_recursion</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">// 递归出口</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">// 递归体</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分区操作，找到 pivot 下标位置</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token keyword">void</span> <span class="token function">quick_sort_two_way</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token function">partition_recursion</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">ARR_SIZE</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token comment">// 测试双向分区 - 快速排序</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token function">quick_sort_two_way</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="快速排序算法分析"><a class="anchor" href="#快速排序算法分析">#</a> 快速排序算法分析</h3>
<p>快速排序算法是一种高效的排序方法，其性能分析如下：</p>
<ol>
<li><strong>性能优势</strong>：
<ul>
<li>双向分区策略可以减少不必要的遍历，提高效率。</li>
<li>使用元素赋值替代元素交换操作，减少了指令数量。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：
<ul>
<li>在最佳和平均情况下，快速排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log⁡ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>在最坏情况下，如果每次都选择到一个糟糕的基准值，时间复杂度会退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</li>
</ul>
</li>
<li><strong>基准值选择优化</strong>：随机选择基准值或采用 “多选一” 中位数策略，以避免最坏情况。</li>
<li><strong>空间复杂度</strong>：快速排序是原地算法，但递归实现会占用栈空间，空间复杂度在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mtext>⁡</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log ⁡n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⁡</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 之间变动。</li>
<li><strong>稳定性</strong>：快速排序不是稳定的排序算法。</li>
</ol>
<p><strong>快速排序总结</strong>：</p>
<ul>
<li>在大数据集排序场景中，快速排序因其高效性通常是首选。</li>
<li>快速排序的缺点包括：
<ol>
<li>不稳定性，可通过其他稳定排序算法弥补。</li>
<li>最坏情况下性能退化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，且递归实现可能导致栈溢出。</li>
</ol>
</li>
</ul>
<h2 id="堆排序"><a class="anchor" href="#堆排序">#</a> 堆排序</h2>
<p><strong>堆排序的基本概念</strong>：</p>
<ol>
<li><strong>堆</strong>：在数据结构中，堆是一棵特殊的完全二叉树，它可以在数组中按照特定顺序存储，使得父节点的值总是大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值。</li>
<li><strong>大顶堆</strong>：根节点是树中最大元素的堆结构。</li>
<li><strong>小顶堆</strong>：根节点是树中最小元素的堆结构。</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VVZ181a2lmaDBSQ2dXMURBTWdublEwQmtKWnRqN1N5VDVPcFd3dTFVMjVVX2c_ZT1aOXZIREQ.png" alt="202312121656686.png" /></p>
<p><strong>堆排序的实现</strong>：</p>
<ul>
<li>在堆排序过程中，通常使用大顶堆来实现。</li>
<li>无需创建实际的堆数据结构，而是将待排序数组视为一个大顶堆。</li>
<li>通过调整数组元素，使其满足大顶堆的性质，然后逐步将堆顶元素（最大值）移动到数组的末尾，减小堆的大小，并重新调整剩余元素以维持大顶堆的性质。</li>
</ul>
<p><strong>堆排序的算法特点</strong>：</p>
<ul>
<li>堆排序是原地算法，不需要额外的数组空间来进行排序。</li>
<li>堆排序不使用递归，因此避免了栈溢出的风险。</li>
</ul>
<p>要将数组视为一个大顶堆，我们可以按照以下步骤操作：</p>
<ol>
<li><strong>理解数组与完全二叉树的关系</strong>：在数组中，对于任意元素（除了最后一个），其索引为  <code>i</code>  的父节点的左右子节点索引分别为  <code>2i + 1</code>  和  <code>2i + 2</code> 。</li>
<li><strong>构建大顶堆</strong>：对于给定的数组  <code>int arr[] = &#123;4, 10, 3, 5, 1&#125;;</code> ，我们需要调整元素的位置，以满足大顶堆的性质，即每个父节点的值都大于其子节点的值。</li>
<li><strong>堆排序过程</strong>：
<ul>
<li>首先，将数组构建成一个逻辑上的大顶堆。</li>
<li>交换堆顶元素（数组首元素，即最大值）与最后一个元素，然后将该最大值视为已排序，从待排序元素中移除。</li>
<li>调整剩余元素，重新构建大顶堆。</li>
<li>重复上述过程，每次从堆顶移除最大元素，并重新构建大顶堆，直到所有元素都被排序。</li>
</ul>
</li>
<li><strong>定义函数</strong>：
<ul>
<li><strong>构建大顶堆的函数</strong>：从最后一个父节点开始，向上调整每个节点，以满足大顶堆的性质。</li>
<li><strong>调整堆的函数</strong>：在移除堆顶元素后，将最后一个元素放到堆顶，并调整堆以维持大顶堆结构。</li>
</ul>
</li>
</ol>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VlWS01TzFaM3JkSnZGU3JCVFg3Qk1nQlVZdm0zQ0lhYjdfamg4SHVtVndOanc_ZT13SlBFVGs.png" alt="" /></p>
<div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i>C</a><a href="/tags/ds/" rel="tag"><i class="ic i-tag"></i>数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-12-16 15:50:20" itemprop="dateModified" datetime="2024-12-16T15:50:20+08:00">2024-12-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.png" alt="樱小路七叶 微信支付"/><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.png" alt="樱小路七叶 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="https://cwlrin.wiki/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" title="C 语言排序">https://cwlrin.wiki/c-cpp/c-base/C 语言排序/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="prev" itemprop="url" title="C 语言数据结构——二叉搜索树" style="background-image: linear-gradient(to bottom right, #a1e4a3, #8b82a0);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言数据结构——二叉搜索树</h3></a></div><div class="item right"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81/" rel="next" itemprop="url" title="C 语言文件流" style="background-image: linear-gradient(to bottom right, #bab0b3, #9db9f8);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>C 语言基础</span><h3>C 语言文件流</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text"> 算法性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text"> 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text"> 希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text"> 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text"> 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%88%86%E5%8C%BA"><span class="toc-number">8.1.</span> <span class="toc-text"> 单向分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%88%86%E5%8C%BA"><span class="toc-number">8.2.</span> <span class="toc-text"> 双向分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">8.3.</span> <span class="toc-text"> 快速排序算法分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text"> 堆排序</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="bookmark" title="C 语言数据类型">C 语言数据类型</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5/" rel="bookmark" title="C 语言语句">C 语言语句</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/" rel="bookmark" title="C 语言函数">C 语言函数</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6/" rel="bookmark" title="C 语言头文件">C 语言头文件</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/" rel="bookmark" title="C 语言数组">C 语言数组</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="bookmark" title="C 语言字符串">C 语言字符串</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/" rel="bookmark" title="C 语言结构体">C 语言结构体</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" rel="bookmark" title="C语言指针">C语言指针</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——链表">C 语言数据结构——链表</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/" rel="bookmark" title="C 语言数据结构——栈">C 语言数据结构——栈</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/" rel="bookmark" title="C 语言数据结构——队列">C 语言数据结构——队列</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="bookmark" title="C 语言数据结构——哈希表">C 语言数据结构——哈希表</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="bookmark" title="C 语言数据结构——二叉搜索树">C 语言数据结构——二叉搜索树</a></li><li  class="active"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F/" rel="bookmark" title="C 语言排序">C 语言排序</a></li><li ><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81/" rel="bookmark" title="C 语言文件流">C 语言文件流</a></li><li ><a href="/c-cpp/c-base/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/" rel="bookmark" title="进程虚拟内存空间">进程虚拟内存空间</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%B5%81/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/c-base/C%20%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.4m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">21:46</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div><br/><span style="display:inline;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:var(--grey-5);"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">黑ICP备2021000748号-1</a><br/><a target="_blank" href="https://beian.mps.gov.cn/#/query/webSearch?code=23120202000171 # 网安备案链接中的recordcode参数
post: count: true
# 文章是否失效 outime: enable: false days: 90 # 超过 90 天文章失效
reward: # If true, reward will be displayed in every article by default. enable: false account: wechatpay: /wechatpay.png alipay: /alipay.png # paypal: /paypal.png
# TagCloud settings for tags page. tagcloud: # All values below are same as default, change them by yourself. min: 16 # Minimun font size in px max: 22 # Maxium font size in px start: "><img loading="lazy" decoding="async" data-src="/assets/https://beian.mps.gov.cn/img/logo01.dd7ff50e.png" style="max-width: 2em;display:inline;" width="20" height="20" alt="备案"/>黑公网安备23120202000171号</a></span></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `c-cpp/c-base/C 语言排序/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.20" type="module" fetchpriority="high" defer></script></body></html>