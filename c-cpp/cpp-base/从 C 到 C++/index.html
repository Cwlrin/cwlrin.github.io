<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="http://cwlrin.wiki/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.20"><link rel="modulepreload" href="/js/chunk-NPDU2HRQ.js"></link><link rel="modulepreload" href="/js/chunk-R2ID445Y.js"></link><link rel="modulepreload" href="/js/chunk-YHPSMGA6.js"></link><link rel="modulepreload" href="/js/copy-tex-2AKW2INC.js"></link><link rel="modulepreload" href="/js/index.esm-TLZT3I4E.js"></link><link rel="modulepreload" href="/js/post-AWU7OAKV.js"></link><link rel="modulepreload" href="/js/quicklink-3TNKEFE4.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWeUV6VG9rX05SRGlzZHFDcGo4Y25RQndESlpkN1p0X1F2WmUxNk1jc2pRM2c_ZT1JczZaSWY.png" as="image" fetchpriority="high"><meta name="keywords" content="C++"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="http://cwlrin.wiki/c-cpp/cpp-base/%E4%BB%8E%20C%20%E5%88%B0%20C++/"><title>从 C 到 C++</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">从 C 到 C++</h1><div class="meta"><span class="item" title="创建时间：2020-10-30 15:40:48"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-10-30T15:40:48+08:00">2020-10-30</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>42k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>39 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWeUV6VG9rX05SRGlzZHFDcGo4Y25RQndESlpkN1p0X1F2WmUxNk1jc2pRM2c_ZT1JczZaSWY.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/cpp-basic/" itemprop="item" rel="index" title="分类于C++ 基础"><span itemprop="name">C++ 基础<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://cwlrin.wiki/c-cpp/cpp-base/%E4%BB%8E%20C%20%E5%88%B0%20C++/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="命名空间"><a class="anchor" href="#命名空间">#</a> 命名空间</h2>
<h3 id="为什么要使用命名空间"><a class="anchor" href="#为什么要使用命名空间">#</a> 为什么要使用命名空间</h3>
<p>命名冲突指的是在同一个作用域内，存在两个或多个具有相同名称的实体。</p>
<p>在 C 语言中，避免此类冲突通常需要开发者遵循特定的命名约定。例如，通过在变量名前添加开发者的标识符，可以在一定程度上减少冲突的可能性：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> hw_cpp_tom_num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> xm_cpp_bob_num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>C++ 提供了一种解决方案，即 <strong>命名空间</strong>。命名空间允许开发者定义自己的命名作用域，使得在不同作用域中可以存在同名的变量或函数，而不会相互干扰。这样，系统能够根据命名空间来区分这些同名实体，从而有效地解决了命名冲突的问题。</p>
<h3 id="什么是命名空间"><a class="anchor" href="#什么是命名空间">#</a> 什么是命名空间</h3>
<p>命名空间（Namespace）是一种编程概念，它允许程序员创建命名的内存区域，用于组织和隔离代码中的全局实体。通过将全局实体分配到不同的命名空间中，可以有效地避免命名冲突，因为每个命名空间都定义了自己的作用域，其中的实体只在该命名空间内可见。</p>
<p>在 C++ 中，命名空间的使用不仅有助于解决命名冲突，还能提高代码的模块化和可读性。以下是 C++ 中定义命名空间的基本格式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> val1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">char</span> val2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr></table></figure><p>在声明一个命名空间时，大括号内可以包含多种类型的实体，包括：</p>
<ul>
<li><strong>变量</strong>：存储数据的变量。</li>
<li><strong>常量</strong>：存储固定值的常量。</li>
<li><strong>函数</strong>：执行特定操作的代码块。</li>
<li><strong>结构体</strong>：用于数据组织的结构。</li>
<li><strong>引用</strong>：指向其他变量或实体的引用。</li>
<li><strong>类</strong>：定义对象的数据结构和行为的模板。</li>
<li><strong>对象</strong>：类的实例。</li>
<li><strong>模板</strong>：用于创建泛型函数和类的代码。</li>
<li><strong>命名空间</strong>：可以嵌套定义，进一步组织代码。</li>
</ul>
<h3 id="命名空间的使用方式"><a class="anchor" href="#命名空间的使用方式">#</a> 命名空间的使用方式</h3>
<p>命名空间一共有三种使用方式，分别是 using 编译指令、作用域限定符、using 声明机制。</p>
<p>在 C++ 中，使用 <strong>作用域限定符  <code>::</code> </strong> 来访问命名空间中的实体是一种非常直接和明确的方法。这种方式确保了对命名空间内实体的精确访问，避免了命名冲突，并且使得代码的意图更加清晰。</p>
<h4 id="作用域限定符"><a class="anchor" href="#作用域限定符">#</a> 作用域限定符</h4>
<p>在代码中，通过在实体名前加上命名空间名和作用域限定符  <code>::</code> ，可以直接访问该命名空间内的任何实体。这种方法虽然在某些情况下显得繁琐，但它提供了最高的精确度和控制力。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::number = "</span> <span class="token operator">&lt;&lt;</span> ccb<span class="token double-colon punctuation">::</span>number <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, world"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>优点：</strong></p>
<ul>
<li><strong>精确性</strong>：通过明确指定命名空间，可以确保访问正确的实体，避免因命名冲突导致的错误。</li>
<li><strong>清晰性</strong>：代码的读者可以立即识别出实体所属的命名空间，增加了代码的可读性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>繁琐性</strong>：每次访问命名空间内的实体都需要使用作用域限定符，这在实体频繁使用时会增加代码的冗余。</li>
<li><strong>可维护性</strong>：如果命名空间的名称更改，需要在整个代码库中进行相应的修改，这可能会影响代码的维护性。</li>
</ul>
<h4 id="using-编译指令"><a class="anchor" href="#using-编译指令">#</a> using 编译指令</h4>
<p><code>std</code>  命名空间是标准库中所有实体的集合，包括常用的  <code>cout</code>  和  <code>endl</code> 。为了简化代码，可以使用  <code>using namespace std;</code>  指令，这样可以直接访问这些实体而无需每次使用前缀  <code>std::</code> 。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token comment">// 引入标准命名空间</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>尽管  <code>using namespace</code>  可以简化代码，但过度使用可能导致命名冲突，尤其是在大型项目中。因此，建议仅在局部作用域内使用此指令。</p>
<p>例如，当两个命名空间中存在同名实体时，直接使用  <code>using namespace</code>  可能会导致编译器无法确定使用哪个实体，从而引发冲突：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> cpp <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace cpp</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> ccb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 正确，因为 ccb 命名空间已被引入</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> cpp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 错误，因为存在命名冲突</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为了避免这种冲突，建议将  <code>using namespace</code>  指令放在局部作用域内，并在必要时使用命名空间限定符来明确指定实体来源。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> cpp <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace cpp</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> ccb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> cpp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 错误，仍然存在命名冲突</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此外，当全局命名空间中也存在同名实体时，使用  <code>using namespace</code>  也可能导致冲突：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> ccb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 错误，存在命名冲突</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>建议：</strong> 在不确定命名空间中实体的情况下，谨慎使用  <code>using namespace</code> ，以避免不必要的命名冲突。对于初学者，建议先熟悉命名空间中的实体，再考虑是否使用  <code>using namespace</code>  指令。</p>
<p>使用  <code>using namespace</code>  的好处是代码更简洁，但坏处是可能引发命名空间污染和访问冲突。</p>
<h4 id="using-声明机制"><a class="anchor" href="#using-声明机制">#</a> using 声明机制</h4>
<p><code>using</code>  声明提供了一种更精确的方式来引入命名空间中的特定实体，而不是将整个命名空间的内容全部引入。这种方式有助于减少命名冲突，并提高代码的清晰度。</p>
<p><strong>使用  <code>using</code>  声明的好处：</strong></p>
<ul>
<li><strong>精确控制：</strong> 只引入所需的实体，避免不必要的命名空间污染。</li>
<li><strong>减少冲突：</strong> 通过局部引入，减少命名冲突的可能性。</li>
<li><strong>提高可读性：</strong> 明确指出哪些实体被使用，使代码更易理解。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>display<span class="token punctuation">;</span> <span class="token comment">// 只引入函数名</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::number = "</span> <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 正确，访问到 ccb::number</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，我们通过  <code>using</code>  声明引入了  <code>ccb</code>  命名空间中的  <code>number</code>  和  <code>display</code>  实体。这样，即使全局命名空间中也存在名为  <code>number</code>  的变量，局部作用域中仍然可以明确访问  <code>ccb</code>  命名空间中的  <code>number</code> 。</p>
<p><strong>冲突处理：</strong> 如果在同一作用域内使用  <code>using</code>  声明引入了不同命名空间中的同名实体，仍然会发生冲突。例如：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">namespace</span> ccb2 <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb2::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb2</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>display<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">using</span> ccb2<span class="token double-colon punctuation">::</span>display<span class="token punctuation">;</span> <span class="token comment">// 冲突</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  ccb2<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，尝试在同一个作用域内引入两个不同命名空间中的  <code>display</code>  函数，导致了冲突。正确的做法是避免在同一作用域内引入同名实体，或者使用命名空间限定符来明确指定要使用的实体。</p>
<p><code>using</code>  声明机制是一种有效的方法，用于精确控制命名空间中实体的引入，减少命名冲突，并提高代码的可读性和可维护性。在编写 C++ 代码时，推荐使用这种方式来引入所需的命名空间实体。</p>
<h3 id="命名空间的嵌套使用"><a class="anchor" href="#命名空间的嵌套使用">#</a> 命名空间的嵌套使用</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">namespace</span> cpp <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cpp::func"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token comment">// namespace cpp</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 方式一，使用作用域限定精确访问实体</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ccb<span class="token double-colon punctuation">::</span>cpp<span class="token double-colon punctuation">::</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span>cpp<span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// 方式二，using 编译指令一次性引入 cpp 的实体</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> ccb<span class="token double-colon punctuation">::</span>cpp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// 方式三，using 声明语句</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>cpp<span class="token double-colon punctuation">::</span>num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>cpp<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="匿名命名空间"><a class="anchor" href="#匿名命名空间">#</a> 匿名命名空间</h3>
<p>在 C++ 中，匿名命名空间（也称为匿名空间）是一种特殊的命名空间，它没有名字，其作用域限定在定义它的文件内。这意味着在匿名命名空间中定义的实体（如变量、函数等）只能在该文件内部访问，无法在其他文件中直接访问，从而实现了良好的封装和避免命名冲突。</p>
<p><strong>定义匿名命名空间：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace</span></pre></td></tr></table></figure><p><strong>使用匿名命名空间中的实体：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 直接访问</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token double-colon punctuation">::</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 使用全局作用域限定符访问</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接访问</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用全局作用域限定符访问</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意事项：</strong></p>
<ol>
<li>
<p><strong>避免命名冲突：</strong> 如果在匿名命名空间中定义了与全局命名空间中同名的实体，直接访问时会发生冲突。使用全局作用域限定符  <code>::</code>  也无法访问到匿名命名空间中的实体，只能访问全局实体。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"g_func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">namespace</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 冲突，访问全局的 val</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token double-colon punctuation">::</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 全局的 val</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 冲突，访问全局的 func</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局的 func</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>匿名空间的实体不能跨模块调用：</strong> 匿名命名空间中的实体仅在定义它们的文件内可见，无法在其他文件中访问。</p>
</li>
</ol>
<p><strong>概念澄清：</strong></p>
<ul>
<li><strong>匿名命名空间</strong>：没有名字的命名空间，其作用域限定在定义它的文件内。</li>
<li><strong>具名命名空间</strong>：有名字的命名空间，可以在多个文件中定义和使用。</li>
<li><strong>命名空间</strong>：包括匿名命名空间和具名命名空间，用于封装代码，避免命名冲突。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func1()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 如果希望将一些内容限定在本文件中使用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 就可以将它们定义在匿名空间中</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 同时，要注意不要在全局位置定义同名的实体</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 否则在本文件中只能访问到全局的内容</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 无法访问匿名空间中重名的实体</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">namespace</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 通常使用匿名空间中实体时直接写实体的名字</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token double-colon punctuation">::</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="跨模块调用问题"><a class="anchor" href="#跨模块调用问题">#</a> 跨模块调用问题</h3>
<p>在 C++ 中，全局变量和函数可以跨模块调用，这是通过在其他模块中使用  <code>extern</code>  关键字声明这些全局变量和函数来实现的。</p>
<p><code>extern</code>  声明告诉编译器这些变量和函数的定义在其他地方存在，因此编译器在链接时会将这些声明与它们的定义关联起来。</p>
<h4 id="全局变量和函数是可以跨模块调用的"><a class="anchor" href="#全局变量和函数是可以跨模块调用的">#</a> 全局变量和函数是可以跨模块调用的</h4>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>externA.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>externB.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span> <span class="token comment">// 外部引入声明</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上述示例中， <code>externA.cc</code>  定义了全局变量  <code>num</code>  和函数  <code>print</code> 。 <code>externB.cc</code>  通过  <code>extern</code>  声明引入了这些全局变量和函数，使得它们可以在  <code>externB.cc</code>  中被调用。</p>
<h4 id="有名命名空间中的实体可以跨模块调用"><a class="anchor" href="#有名命名空间中的实体可以跨模块调用">#</a> 有名命名空间中的实体可以跨模块调用</h4>
<p>对于命名空间中的实体，也可以实现跨模块调用，但需要在每个模块中声明同名的命名空间，并使用  <code>extern</code>  关键字引入实体。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>externA.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>externB.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token comment">// 在 ccb 命名空间中引入 val</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在 ccb 命名空间中引入 display</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ccb<span class="token double-colon punctuation">::</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上述示例中， <code>externA.cc</code>  定义了命名空间  <code>ccb</code>  及其中的变量  <code>val</code>  和函数  <code>display</code> 。 <code>externB.cc</code>  同样声明了命名空间  <code>ccb</code> ，并在其中使用  <code>extern</code>  关键字引入了  <code>val</code>  和  <code>display</code> 。这样， <code>externB.cc</code>  就可以访问这些实体。</p>
<p>命名空间中的实体跨模块调用时，要在新的源文件中再次定义同名的命名空间，在其中通过 extern 引入实体。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// #include "externA.cc"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token comment">// void display();</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ccb<span class="token double-colon punctuation">::</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>externA.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 全局位置定义的变量、函数与命名空间中的实体同名</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ccb::display()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>externB.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 访问到全局的实体</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 访问到命名空间中的实体</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ccb<span class="token double-colon punctuation">::</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  ccb<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">using</span> <span class="token keyword">namespace</span> ccb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 冲突</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 冲突</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>val<span class="token punctuation">;</span><span class="token comment">// 声明冲突</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>display<span class="token punctuation">;</span><span class="token comment">// 声明冲突</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token keyword">using</span> ccb<span class="token double-colon punctuation">::</span>display<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//ok，在本作用域中对全局的实体起到了屏蔽的效果</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果需要跨模块调用命名空间中的实体，要尽量避免它们与全局位置的实体重名，在使用时尽量采取作用域限定的方式。</p>
<h4 id="静态变量和函数只能在本模块内部使用"><a class="anchor" href="#静态变量和函数只能在本模块内部使用">#</a> 静态变量和函数只能在本模块内部使用</h4>
<h4 id="匿名空间的实体只能在本模块内部使用"><a class="anchor" href="#匿名空间的实体只能在本模块内部使用">#</a> 匿名空间的实体只能在本模块内部使用</h4>
<p>匿名空间中的实体只能在本文件的作用域内有效，它的作用域是从匿名命名空间声明开始到本文件结束。</p>
<h4 id="extern-和-include"><a class="anchor" href="#extern-和-include">#</a> extern 和 include</h4>
<h5 id="extern-的使用"><a class="anchor" href="#extern-的使用">#</a> extern 的使用</h5>
<p><code>extern</code>  关键字用于声明全局变量或函数，告诉编译器这些变量或函数的定义在其他文件中。这种方式非常适合于管理较小的代码组织，因为它允许程序员明确指定需要引入哪些外部定义。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>精细控制：</strong> 可以精确地控制哪些外部变量或函数被引入，避免不必要的代码引入。</li>
<li><strong>减少依赖：</strong> 减少对其他模块的依赖，因为只有需要的变量或函数才会被声明。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>易出错：</strong> 如果跨模块的调用关系不清晰，或者忘记声明某个外部变量或函数，很容易导致编译错误或运行时错误。</li>
<li><strong>维护困难：</strong> 当项目规模增大时，跟踪和管理所有的  <code>extern</code>  声明可能会变得复杂。</li>
</ul>
<h5 id="include-的使用"><a class="anchor" href="#include-的使用">#</a> include 的使用</h5>
<p><code>include</code>  指令用于包含头文件，这些头文件中通常包含了函数声明、模板定义、宏定义等。使用  <code>include</code>  可以确保所有相关的声明都在编译时可用。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>代码清晰：</strong> 通过包含头文件，可以确保所有相关的声明都在一个地方管理，使得代码结构更清晰。</li>
<li><strong>自动更新：</strong> 当头文件更新时，所有包含该头文件的源文件都会自动更新，保持一致性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>效率较低：</strong> 因为  <code>include</code>  会一次性引入头文件中的所有内容，即使有些内容在当前文件中并未使用，这可能导致编译效率降低。</li>
<li><strong>循环依赖：</strong> 过度使用  <code>include</code>  可能导致头文件之间的循环依赖，使得项目结构变得复杂。</li>
</ul>
<h5 id="对比和选择"><a class="anchor" href="#对比和选择">#</a> 对比和选择</h5>
<ul>
<li><strong>小型项目或简单模块：</strong> 如果项目较小或者模块之间的依赖关系简单，使用  <code>extern</code>  可能更合适，因为它提供了更精细的控制。</li>
<li><strong>大型项目或复杂模块：</strong> 对于大型项目或模块化程度较高的项目，使用  <code>include</code>  可能更合适，因为它有助于保持代码的清晰和一致性。</li>
</ul>
<h3 id="使用命名空间的规则"><a class="anchor" href="#使用命名空间的规则">#</a> 使用命名空间的规则</h3>
<h4 id="多次定义"><a class="anchor" href="#多次定义">#</a> 多次定义</h4>
<p>命名空间可以在多个地方定义，但所有定义都被视为同一个命名空间。这意味着在同一个命名空间中定义的实体在整个程序中是唯一的。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">namespace</span> ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr></table></figure><p>在这个例子中， <code>ccb</code>  命名空间被定义了两次，但它们被视为同一个命名空间。</p>
<h4 id="重复定义"><a class="anchor" href="#重复定义">#</a> 重复定义</h4>
<p>不能在同一个命名空间中定义同名的实体。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>namespace ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>namespace ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 错误：不能在同一个命名空间中重新定义 num</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token comment">// namespace ccb</span></pre></td></tr></table></figure><h4 id="实体使用"><a class="anchor" href="#实体使用">#</a> 实体使用</h4>
<p>命名空间中的实体（如变量和函数）不能在命名空间内部使用，它们必须在命名空间外部被访问和使用。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>namespace ccb <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：不能在命名空间内部调用函数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 错误：不能在命名空间内部访问变量</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  ccb<span class="token operator">::</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确：在命名空间外部调用函数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  ccb<span class="token operator">::</span>num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 正确：在命名空间外部访问变量</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ccb<span class="token operator">::</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3>
<h4 id="命名空间的作用"><a class="anchor" href="#命名空间的作用">#</a> 命名空间的作用</h4>
<ol>
<li><strong>避免命名冲突：</strong> 通过将相关的实体封装在命名空间中，可以避免不同代码库或模块间的命名冲突。</li>
<li><strong>组织代码：</strong> 将逻辑上相关的实体（如类、函数、变量等）组织在一起，使代码更加模块化和易于管理。</li>
<li><strong>版本控制：</strong> 通过在不同的命名空间中放置不同版本的实体，可以方便地进行版本控制和迁移。</li>
<li><strong>声明主权：</strong> 在一定程度上，命名空间的使用可以表明代码的所有权或来源，有助于维护和责任分配。</li>
</ol>
<h4 id="命名空间使用建议"><a class="anchor" href="#命名空间使用建议">#</a> 命名空间使用建议</h4>
<ol>
<li><strong>定义变量：</strong> 推荐在命名空间中定义变量，而不是直接使用全局变量或静态全局变量。这有助于限制变量的作用域，减少意外的全局影响。</li>
<li><strong>局部 using 声明：</strong> 建议将  <code>using</code>  声明语句的作用域限制在局部，而不是全局。这样可以减少命名冲突的风险，并提高代码的清晰度。</li>
<li><strong>避免在头文件中使用 using 指令：</strong> 在头文件中使用  <code>using</code>  指令可能会导致命名空间污染，因为包含该头文件的源文件可能会无意中引入了不需要的命名空间实体，造成二义性问题。</li>
<li><strong>头文件包含顺序：</strong> 推荐首先包含自定义头文件，然后是 C 标准库头文件，接着是 C++ 标准库头文件，最后是第三方库头文件。这种顺序有助于减少编译依赖和提高编译效率。</li>
</ol>
<h4 id="包含头文件的顺序"><a class="anchor" href="#包含头文件的顺序">#</a> 包含头文件的顺序</h4>
<ol>
<li><strong>自定义头文件：</strong> 首先包含，因为它们可能依赖于项目特定的配置或定义。</li>
<li><strong>C 标准库头文件：</strong> 其次包含，因为它们提供了基本的 C 语言功能。</li>
<li><strong>C++ 标准库头文件：</strong> 接着包含，因为它们提供了 C++ 语言的核心功能。</li>
<li><strong>第三方库头文件：</strong> 最后包含，因为它们可能依赖于前面的标准库或自定义头文件。</li>
</ol>
<h2 id="const-关键字"><a class="anchor" href="#const-关键字">#</a> const 关键字</h2>
<h3 id="修饰内置类型"><a class="anchor" href="#修饰内置类型">#</a> 修饰内置类型</h3>
<p><code>const</code>  修饰的变量在 C++ 中被称为常量，它们一旦被初始化后就不能被修改。这些常量可以是整型、浮点型或其他任何基本数据类型。 <code>const</code>  常量在定义时必须立即初始化，因为它们在程序运行时存储在内存中，并且编译器需要知道它们的确切值。</p>
<p><code>const</code>  常量的特点：</p>
<ol>
<li><strong>类型安全</strong>： <code>const</code>  常量具有明确的类型，编译器会进行类型检查。</li>
<li><strong>编译时处理</strong>： <code>const</code>  常量在编译时处理，它们在内存中占有空间，并且可以参与编译时的优化。</li>
<li><strong>初始化要求</strong>：必须在定义时初始化，因为它们在程序运行时存储在内存中。</li>
<li><strong>作用域限制</strong>： <code>const</code>  常量具有作用域限制，它们的作用域由定义它们的位置决定。</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> number1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 正确的初始化</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token keyword">const</span> number2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 等价于上面的声明</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>          <span class="token comment">// 错误：常量必须要进行初始化</span></pre></td></tr></table></figure><p>宏定义常量是通过预处理器指令  <code>#define</code>  创建的，它们在预处理阶段进行文本替换，没有类型，也不进行类型检查。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span></pre></td></tr></table></figure><h3 id="const-常量和宏定义常量的区别"><a class="anchor" href="#const-常量和宏定义常量的区别">#</a> const 常量和宏定义常量的区别</h3>
<ol>
<li><strong>发生的时机不同</strong>：
<ul>
<li>宏定义在预处理时发生，是简单的文本替换。</li>
<li><code>const</code>  常量在编译时处理，具有类型和作用域。</li>
</ul>
</li>
<li><strong>类型和安全检查不同</strong>：
<ul>
<li>宏定义没有类型，不进行类型检查。</li>
<li><code>const</code>  常量有类型，编译器会进行类型检查。</li>
</ul>
</li>
<li><strong>内存占用</strong>：
<ul>
<li><code>const</code>  常量在内存中占有空间，可以有构造和析构。</li>
<li>宏定义不占用内存，它们只是文本替换。</li>
</ul>
</li>
<li><strong>调试和维护</strong>：
<ul>
<li><code>const</code>  常量更容易调试，因为它们有类型和作用域。</li>
<li>宏定义可能更难调试，因为它们在预处理阶段就被替换了。</li>
</ul>
</li>
</ol>
<h3 id="修饰指针类型"><a class="anchor" href="#修饰指针类型">#</a> 修饰指针类型</h3>
<p>在 C++ 中，使用  <code>const</code>  关键字修饰指针可以有多种含义，取决于  <code>const</code>  的位置。以下是三种主要的修饰方式：</p>
<h4 id="指向常量的指针pointer-to-const"><a class="anchor" href="#指向常量的指针pointer-to-const">#</a> 指向常量的指针（Pointer to const）</h4>
<p>当  <code>const</code>  位于星号（*）的左侧时，表示指针指向的值是常量，不能通过这个指针来修改它指向的值。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> number1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> number2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>number1<span class="token punctuation">;</span> <span class="token comment">// 指向常量的指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                <span class="token comment">// 错误：不能通过 p1 修改它指向的值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>number2<span class="token punctuation">;</span>            <span class="token comment">// 可以改变 p1 指针的指向</span></pre></td></tr></table></figure><p>如果有一个  <code>const</code>  修饰的变量，那么只有  <code>const</code>  修饰的指针才能指向它，因为  <code>const</code>  修饰的变量的值不能被修改。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">// 错误</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> cp <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">// 正确</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 还有一个意义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 只有指向常量的指针才能去指向 const 常量</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 指向常量的指针不仅能够指向 const 常量</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 还可以指向普通的变量</span></pre></td></tr><tr><td data-num="8"></td><td><pre>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>const int * p1</code>  和  <code>int const * p1</code>  是等价的，都表示指向常量的指针。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>number1<span class="token punctuation">;</span> <span class="token comment">// 指向常量的指针的第二种写法</span></pre></td></tr></table></figure><h4 id="常量指针const-pointer"><a class="anchor" href="#常量指针const-pointer">#</a> 常量指针（Const pointer）</h4>
<p>当  <code>const</code>  位于星号（*）的右侧时，表示指针本身是常量，一旦指针被初始化后，就不能改变它的指向。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>number1<span class="token punctuation">;</span> <span class="token comment">// 常量指针</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 可以修改它指向的值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>number2<span class="token punctuation">;</span> <span class="token comment">// 错误：不能改变 p2 指针的指向</span></pre></td></tr></table></figure><h4 id="指向常量的常量指针const-pointer-to-const"><a class="anchor" href="#指向常量的常量指针const-pointer-to-const">#</a> 指向常量的常量指针（Const pointer to const）</h4>
<p>当指针和它指向的值都是  <code>const</code>  时，这种指针既不能改变指向，也不能通过这个指针修改它指向的值。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>number1<span class="token punctuation">;</span> <span class="token comment">// 指向和指向的值皆不能进行修改</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 错误：不能通过 p3 修改它指向的值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>number2<span class="token punctuation">;</span> <span class="token comment">// 错误：不能改变 p3 指针的指向</span></pre></td></tr></table></figure><h4 id="数组指针pointer-to-array"><a class="anchor" href="#数组指针pointer-to-array">#</a> 数组指针（Pointer to array）</h4>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 数组指针，指向数组的指针</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 数组中首个元素的首地址</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> arr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> arr <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 数组指针</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 整个数组的首地址</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>arr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>arr <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// 0x7ffffcbe0</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">// 0x7ffffcbe4</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">// 0x7ffffcbe0</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 0x7ffffcbf4</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">// 1 2 3 4 5</span></pre></td></tr></table></figure><h4 id="指针数组array-of-pointers"><a class="anchor" href="#指针数组array-of-pointers">#</a> 指针数组（Array of pointers）</h4>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 指针数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 元素类型为指针的数组</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> num2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> num3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> #</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>num2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>num3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// 1 2 3</span></pre></td></tr></table></figure><h4 id="函数指针pointer-to-function"><a class="anchor" href="#函数指针pointer-to-function">#</a> 函数指针（Pointer to function）</h4>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 函数指针</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 指向函数的指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func() "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// 定义函数指针要确定其指向的函数的</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// 返回类型和参数信息</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">//</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 简略写法</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token comment">// 完整写法</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// func() 4</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 7func() 7</span></pre></td></tr></table></figure><h4 id="指针函数function-that-returns-a-pointer"><a class="anchor" href="#指针函数function-that-returns-a-pointer">#</a> 指针函数（Function that returns a pointer）</h4>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 指针函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 返回值为指针的函数</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 返回的指针指向的内容生命周期应该比函数更长</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> #</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 100</span></pre></td></tr></table></figure><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3>
<ol>
<li>指向常量的指针（Pointer to const）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：指针指向一个常量值，不能通过这个指针修改它指向的值。</li>
<li><strong>用途</strong>：用于只读数据。</li>
</ul>
<ol start="2">
<li>常量指针（Const pointer）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr<span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：指针本身的值是常量，一旦指针被初始化后，就不能改变它的指向。</li>
<li><strong>用途</strong>：用于确保指针的指向不变。</li>
</ul>
<ol start="3">
<li>指向常量的常量指针（Const pointer to const）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr<span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：既不能改变指针指向的值，也不能改变指针的指向。</li>
<li><strong>用途</strong>：用于确保指针和数据的不可变性。</li>
</ul>
<ol start="4">
<li>数组指针（Pointer to array）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：指针指向一个数组。</li>
<li><strong>用途</strong>：用于处理数组，特别是多维数组或数组的数组。</li>
</ul>
<ol start="5">
<li>指针数组（Array of pointers）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：一个数组，其元素是指针。</li>
<li><strong>用途</strong>：用于管理一组指针，例如管理一组对象或资源。</li>
</ul>
<ol start="6">
<li>函数指针（Pointer to function）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：指针指向一个函数。</li>
<li><strong>用途</strong>：用于回调函数、函数指针数组等。</li>
</ul>
<ol start="7">
<li>指针函数（Function that returns a pointer）</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>描述</strong>：一个函数，它返回一个指针。</li>
<li><strong>用途</strong>：用于动态内存分配、返回对象的指针等。</li>
</ul>
<p>比较和用途</p>
<ul>
<li><strong>指向常量的指针</strong> 和 <strong>常量指针</strong> 的主要区别在于限制的方向：前者限制了通过指针修改数据的能力，后者限制了改变指针指向的能力。</li>
<li><strong>指向常量的常量指针</strong> 结合了前两者的限制，提供了最严格的限制。</li>
<li><strong>数组指针</strong> 通常用于处理更复杂的数据结构，如多维数组。</li>
<li><strong>指针数组</strong> 则用于管理多个指针，常用于动态数据结构。</li>
<li><strong>函数指针</strong> 在事件驱动和回调机制中非常有用，也常用于 API 设计。</li>
<li><strong>指针函数</strong> 则提供了一种返回复杂数据结构或动态分配内存的方式。</li>
</ul>
<h2 id="newdelete-表达式"><a class="anchor" href="#newdelete-表达式">#</a> new/delete 表达式</h2>
<h3 id="cc申请-释放堆空间的方式对比"><a class="anchor" href="#cc申请-释放堆空间的方式对比">#</a> C/C++ 申请、释放堆空间的方式对比</h3>
<h4 id="c-语言中的内存管理"><a class="anchor" href="#c-语言中的内存管理">#</a> C 语言中的内存管理</h4>
<p>在 C 语言中，使用  <code>malloc</code>  和  <code>free</code>  函数来管理动态内存。这两个函数分别用于分配和释放内存。</p>
<ul>
<li><strong> <code>malloc</code>  函数</strong>：它根据指定的大小（以字节为单位）分配一块内存，并返回一个指向这块内存的指针。如果分配失败，返回  <code>NULL</code> 。</li>
<li><strong> <code>free</code>  函数</strong>：用于释放先前使用  <code>malloc</code>  分配的内存。</li>
</ul>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配内存</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 使用内存</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放内存</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="c-中的内存管理"><a class="anchor" href="#c-中的内存管理">#</a> C++ 中的内存管理</h4>
<p>C++ 提供了  <code>new</code>  和  <code>delete</code>  运算符，这些运算符不仅分配内存，还调用对象的构造函数和析构函数，使得内存管理更加安全和方便。</p>
<ul>
<li><strong> <code>new</code>  运算符</strong>：分配内存，并调用对象的构造函数来初始化对象。如果分配失败，抛出  <code>std::bad_alloc</code>  异常。</li>
<li><strong> <code>delete</code>  运算符</strong>：释放内存，并调用对象的析构函数。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为默认值（0）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 0</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为指定值（1）</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">delete</span> p1<span class="token punctuation">;</span> <span class="token comment">// 释放内存</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">delete</span> p2<span class="token punctuation">;</span> <span class="token comment">// 释放内存</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="mallocfree-和-newdelete-的区别"><a class="anchor" href="#mallocfree-和-newdelete-的区别">#</a> malloc/free 和 new/delete 的区别</h4>
<ol>
<li><strong>库函数 / 运算符</strong>：
<ul>
<li><code>malloc</code>  和  <code>free</code>  是 C 标准库提供的函数，分别用于分配和释放内存。它们定义在  <code>&lt;stdlib.h&gt;</code> （或在 C++ 中为  <code>&lt;cstdlib&gt;</code> ）。</li>
<li><code>new</code>  和  <code>delete</code>  是 C++ 的运算符，它们不仅分配内存，还调用构造函数和析构函数。它们是语言的一部分，不是库函数。</li>
</ul>
</li>
<li><strong>返回类型</strong>：
<ul>
<li><code>malloc</code>  返回  <code>void*</code>  类型的指针，这意味着返回的指针需要显式转换为需要的指针类型。</li>
<li><code>new</code>  表达式返回一个具体类型的指针，无需显式类型转换。</li>
</ul>
</li>
<li><strong>初始化</strong>：
<ul>
<li><code>malloc</code>  分配的内存不会自动初始化，它可能包含任意的 “脏数据”。</li>
<li><code>new</code>  表达式可以初始化对象。如果不提供初始化器，对象将被默认初始化（零初始化对于基本类型和类的对象）。</li>
</ul>
</li>
<li><strong>内存大小参数</strong>：
<ul>
<li>使用  <code>malloc</code>  时，需要手动计算并指定所需内存的字节数。</li>
<li><code>new</code>  运算符会自动计算所需的内存大小（基于对象的类型和构造函数参数），使得代码更加简洁和安全。</li>
</ul>
</li>
<li><strong>构造和析构</strong>：
<ul>
<li><code>malloc</code>  不涉及任何构造函数的调用，它只是分配内存。</li>
<li><code>new</code>  运算符在分配内存后会调用对象的构造函数， <code>delete</code>  运算符在释放内存前会调用对象的析构函数。</li>
</ul>
</li>
<li><strong>异常处理</strong>：
<ul>
<li><code>malloc</code>  在内存分配失败时返回  <code>NULL</code> ，需要手动检查返回值。</li>
<li><code>new</code>  在内存分配失败时抛出  <code>std::bad_alloc</code>  异常（除非使用了  <code>new (nothrow)</code> ），这使得错误处理更加统一和方便。</li>
</ul>
</li>
<li><strong>类型安全</strong>：
<ul>
<li><code>malloc</code>  由于返回  <code>void*</code> ，不是类型安全的。</li>
<li><code>new</code>  和  <code>delete</code>  是类型安全的，因为它们知道分配和释放的对象类型。</li>
</ul>
</li>
</ol>
<h3 id="new-表达式申请数组空间"><a class="anchor" href="#new-表达式申请数组空间">#</a> new 表达式申请数组空间</h3>
<p><strong>申请并默认初始化数组</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  p<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>new int[10]()</code>  分配了一个包含 10 个整数的数组，并默认初始化所有元素为 0。然后通过循环为数组的每个元素赋值。最后，使用  <code>delete[]</code>  来释放数组占用的内存。</p>
<p><strong>使用大括号初始化数组</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 如果想要指定数组元素初始化的值，</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 不能用小括号</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 只能用大括号</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 直接输出指针变量名就是输出</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 指针变量所保存的地址值</span></pre></td></tr><tr><td data-num="12"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> p2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>p2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>new int[10]&#123;1, 2, 3, 4, 5&#125;</code>  分配了一个包含 5 个整数的数组，并通过大括号直接初始化数组的元素。这种方式简洁明了，特别适合数组元素已知且数量不多的情况。</p>
<p><strong>使用 new 表达式申请堆空间存放字符串：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* char * pstr = new char[6]&#123;"hello"&#125;; */</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>pstr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> pstr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 输出流运算符对 char* 有默认重载效果</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 会自动去访问该地址上的内容</span></pre></td></tr><tr><td data-num="10"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> pstr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pstr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pstr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>pstr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="回收空间时的注意事项"><a class="anchor" href="#回收空间时的注意事项">#</a> 回收空间时的注意事项</h3>
<h3 id="申请空间和回收空间的匹配"><a class="anchor" href="#申请空间和回收空间的匹配">#</a> 申请空间和回收空间的匹配</h3>
<table>
<thead>
<tr>
<th>行为</th>
<th>申请</th>
<th style="text-align:left">回收</th>
</tr>
</thead>
<tbody>
<tr>
<td>C 语言</td>
<td><code>malloc</code></td>
<td style="text-align:left"><code>free</code></td>
</tr>
<tr>
<td>C++ 非数组</td>
<td><code>new</code></td>
<td style="text-align:left"><code>delete</code></td>
</tr>
<tr>
<td>C++ 数组</td>
<td><code>new[]</code></td>
<td style="text-align:left"><code>delete[]</code></td>
</tr>
</tbody>
</table>
<p>如果错误地匹配申请和回收操作，比如使用  <code>free</code>  来释放由  <code>new</code>  申请的内存，或者使用  <code>delete</code>  来释放由  <code>malloc</code>  申请的内存，可能会导致未定义的行为，包括内存泄漏、程序崩溃或其他难以预测的错误。</p>
<h4 id="安全回收"><a class="anchor" href="#安全回收">#</a> 安全回收</h4>
<p>在 C++ 中， <code>delete</code>  或  <code>delete[]</code>  操作后，指针本身并不自动变为无效。它仍然持有它被删除的内存的地址，这样的指针称为 “野指针”（Dangling Pointer）。引用野指针可能导致未定义行为，因为它指向的内存已经不再有效。</p>
<p>为了避免野指针带来的风险，最佳实践是在释放内存后立即将指针设置为  <code>nullptr</code> 。在 C++11 及更高版本中， <code>nullptr</code>  是表示空指针的首选方式，它比老式的  <code>NULL</code>  更为明确和安全。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为该类型的默认值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">delete</span> p1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 安全回收，避免野指针</span></pre></td></tr></table></figure><h2 id="引用"><a class="anchor" href="#引用">#</a> 引用</h2>
<h3 id="引用的概念"><a class="anchor" href="#引用的概念">#</a> 引用的概念</h3>
<p>在 C++ 中，引用（reference）是一种变量的别名，它为变量提供了另一个名字。引用在声明时必须初始化，并且一旦与某个变量绑定，就不能再与另一个变量绑定。</p>
<ol>
<li>
<p><strong>定义</strong>：</p>
<ul>
<li>引用在声明时使用  <code>类型&amp; 引用名 = 变量名;</code>  的形式。</li>
<li>引用的类型必须与其绑定的变量类型相同。</li>
</ul>
</li>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>引用在声明时必须初始化，不能留空。</li>
<li>初始化后，引用就与被绑定的变量紧密关联，任何对引用的操作都等同于对原变量的操作。</li>
</ul>
</li>
<li>
<p><strong>不可更改绑定</strong>：</p>
<ul>
<li>一旦引用被绑定到一个变量上，就不能重新绑定到另一个变量上。</li>
</ul>
</li>
<li>
<p><strong>地址</strong>：</p>
<ul>
<li>引用和其绑定的变量共享相同的内存地址。</li>
<li><code>&amp;ref</code>  将得到引用所绑定变量的地址。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">&amp;</span> ref <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// 声明 ref 时进行了初始化（绑定）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">&amp;</span> ref2<span class="token punctuation">;</span> <span class="token comment">// 错误，引用未初始化</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref: "</span> <span class="token operator">&lt;&lt;</span> ref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address of num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Address of ref: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// num: 100</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// ref: 100</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Address of num: 0x7ffeedf677a8</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Address of ref: 0x7ffeedf677a8</span></pre></td></tr></table></figure><h3 id="引用的本质"><a class="anchor" href="#引用的本质">#</a> 引用的本质</h3>
<p>在 C++ 中，引用是一种特殊的指针，它提供了一种间接访问变量的方式。</p>
<p>普遍的观点认为引用本身不占用内存空间，它仅仅是一个变量的另一个名字。但如果从原理去理解，就会发现引用实际上是通过指针来实现的，因此它确实会占用内存空间，其大小等同于一个指针的大小。</p>
<p>引用变量占用内存，存储的是一个地址值。编译器限制了对这个地址的直接访问，确保引用始终指向它最初被绑定的那个变量。在汇编语言层面，引用的操作本质上是基于 “间接寻址” 的概念。</p>
<p>通过尝试对引用进行取址操作可以发现得到的地址正是引用所绑定的变量的地址。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* int &amp; ref; // 错误操作 */</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span>ref <span class="token operator">=</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>ref <span class="token operator">=</span> num2<span class="token punctuation">;</span> <span class="token comment">// 赋值操作</span></pre></td></tr><tr><td data-num="7"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num:"</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// num:100</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 0x7ffd55322d20</span></pre></td></tr><tr><td data-num="11"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 0x7ffd55322d20</span></pre></td></tr><tr><td data-num="12"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x7ffd55322d24</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> #</pre></td></tr><tr><td data-num="16"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 0x7ffd55322d28</span></pre></td></tr><tr><td data-num="17"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 0x7ffd55322d20</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="引用与指针的联系与区别"><a class="anchor" href="#引用与指针的联系与区别">#</a> 引用与指针的联系与区别</h3>
<p>联系：</p>
<ol>
<li>
<p><strong>间接访问</strong>：引用和指针都允许我们通过一个间接的方式访问变量，这意味着它们不直接存储数据，而是存储数据的地址或指向数据的指针。</p>
</li>
<li>
<p><strong>底层实现</strong>：引用在底层实际上是通过指针来实现的。这意味着引用的内部机制与指针类似，都是通过地址来访问数据。可以将引用视为一种特殊的指针，通常是一个常量指针（const pointer），意味着一旦引用被初始化指向一个变量，它就不能被重新指向另一个变量。</p>
</li>
</ol>
<p>区别：</p>
<ol>
<li>
<p><strong>初始化要求</strong>：</p>
<ul>
<li><strong>引用</strong>：必须在声明时立即初始化，并且一旦初始化后，就不能改变其指向的变量。</li>
<li><strong>指针</strong>：可以在声明时不立即初始化，可以在任何时候被赋予任何有效的地址。</li>
</ul>
</li>
<li>
<p><strong>指向的修改</strong>：</p>
<ul>
<li><strong>引用</strong>：一旦引用被绑定到一个变量，它就不能被重新绑定到另一个变量。引用的指向是固定的。</li>
<li><strong>指针</strong>：可以随时改变其指向的地址，指向任何其他有效的内存位置。</li>
</ul>
</li>
<li>
<p><strong>取址操作</strong>：</p>
<ul>
<li><strong>引用</strong>：在代码中对引用进行取址操作，得到的是它所绑定的变量的地址。这是因为引用本质上是变量的一个别名，所以取址实际上是获取了变量的地址。</li>
<li><strong>指针</strong>：对指针进行取址操作，得到的是指针变量本身存储的地址，即指针变量的内存地址。</li>
</ul>
</li>
</ol>
<h3 id="引用的使用场景"><a class="anchor" href="#引用的使用场景">#</a> 引用的使用场景</h3>
<h4 id="引用作为函数的参数"><a class="anchor" href="#引用作为函数的参数">#</a> 引用作为函数的参数</h4>
<p>引用在 C++ 中是一种非常有用的机制，它允许函数直接操作传入的变量，而不是它们的副本。这不仅提高了效率，还增强了代码的可读性。以下是使用引用来交换两个整数变量值的示例：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 值传递</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 形参初始化实际是复制的过程</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 函数体中操作的是实参的副本</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 不会改变实参</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  x <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  y <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 地址传递（指针传递）</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 不会让变量本身发生复制</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">void</span> <span class="token function">swap2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>px<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>py<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>px<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">*</span>py<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token operator">*</span>py <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 引用传递，也不会让变量本身发生复制</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 形参初始化过程</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// int &amp; x = a;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// int &amp; y = b;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">// 在函数体中对 x，y 进行操作，a 和 b 会随之改变</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">void</span> <span class="token function">swap3</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  x <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  y <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">// 希望确保 print 函数不会修改实参的值</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// 如果采用值传递，虽然也能确保，但是有复制过程</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// 若参数是对象，可能占内存较大，复制的开销是不必要的</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// 如果采用普通的引用传递，不会复制，</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// 但是无法确保实参不会改变</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment">// 引用底层本身是 int * const</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment">// 现在要增加的效果是不能通过引用修改其绑定的本体的值</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token comment">// 可以使用常引用 const int &amp; x 作为函数的形参</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token comment">/* x = 1; */</span></pre></td></tr><tr><td data-num="42"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"y:"</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>  <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>参数传递的方式包括值传递、指针传递和引用传递。</p>
<ol>
<li>
<p><strong>值传递</strong>：</p>
<ul>
<li>形参是实参的副本，修改形参不会影响实参。</li>
<li>适用于小型数据或不需要修改实参的场景。</li>
</ul>
</li>
<li>
<p><strong>指针传递</strong>：</p>
<ul>
<li>形参是实参地址的副本，通过解引用可以直接修改实参。</li>
<li>需要处理指针，可能增加代码复杂性。</li>
</ul>
</li>
<li>
<p><strong>引用传递</strong>：</p>
<ul>
<li>形参是实参的别名，直接操作实参。</li>
<li>代码简洁，易于理解，且避免了数据复制。</li>
</ul>
</li>
</ol>
<p>使用常引用（ <code>const int &amp;</code> ）作为函数参数可以防止函数内部修改传入的变量，同时避免了复制，适用于以下情况：</p>
<ul>
<li><strong>不修改值</strong>：确保函数不会改变传入参数的值。</li>
<li><strong>避免复制</strong>：对于大型数据结构，避免不必要的复制开销。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  Value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value: "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">printValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确调用，不会修改 a 的值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个示例中， <code>printValue</code>  函数接收一个常引用作为参数，确保了函数内部不会修改  <code>value</code>  的值，同时避免了复制  <code>a</code>  的开销。</p>
<h4 id="引用作为函数的返回值"><a class="anchor" href="#引用作为函数的返回值">#</a> 引用作为函数的返回值</h4>
<p>引用作为函数返回值是一种有效的方法，可以避免不必要的数据复制，从而提高程序的效率。然而，使用引用作为返回值时必须确保返回的变量在函数返回后仍然存在。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> gNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> gNum<span class="token punctuation">;</span><span class="token comment">//return 时会发生复制</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> gNum<span class="token punctuation">;</span><span class="token comment">//return 时并不会发生复制</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token comment">//func1 的返回值是 gNum 的副本</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">/* &amp;func1();//error */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token comment">//func2 的返回值是绑定到 gNum 的一个匿名的引用</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>gNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token operator">++</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> gNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">//func3 的返回值实际是一个悬空引用</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">// 所以如果函数返回类型为引用</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 要确保其绑定的本体生命周期比函数更长</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">/* int &amp; func3()&#123; */</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token comment">/*     int num = 100; */</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment">/*     return num; */</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">/* &#125; */</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token comment">/* cout &lt;&lt; func4() &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token comment">/* cout &lt;&lt; &amp;func4() &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token comment">/* delete &amp;func4(); */</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">&amp;</span>ref <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>  <span class="token keyword">int</span> a <span class="token operator">=</span> ref <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>ref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>  <span class="token keyword">delete</span> <span class="token operator">&amp;</span>ref<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>  <span class="token comment">// 执行 delete 之后，ref 成了悬空引用</span></pre></td></tr><tr><td data-num="49"></td><td><pre>  <span class="token comment">/* cout &lt;&lt; ref &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>注意事项：</strong></p>
<ol>
<li>
<p><strong>避免返回局部变量的引用</strong>：</p>
<ul>
<li>局部变量在函数返回后会被销毁，返回其引用会导致未定义行为。</li>
<li>以下是一个错误示例：</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> number<span class="token punctuation">;</span> <span class="token comment">// 错误：返回局部变量的引用</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>谨慎返回堆空间变量的引用</strong>：</p>
<ul>
<li>返回堆空间变量的引用可能导致内存泄漏，因为调用者可能忘记释放内存。</li>
<li>以下是一个错误示例：</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>pint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span>pint<span class="token punctuation">;</span> <span class="token comment">// 错误：返回堆空间变量的引用</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// 内存泄漏</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
</ol>
<p>建议：</p>
<ul>
<li>
<p><strong>使用静态变量</strong>：如果函数确实需要返回一个引用，可以考虑使用静态变量，这样变量的生命周期会持续到程序结束。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>返回值拷贝</strong>：如果返回引用可能导致问题，可以考虑返回值的拷贝，虽然这会增加一定的开销。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>使用智能指针</strong>：如果需要返回动态分配的内存，可以考虑使用智能指针来管理内存，避免内存泄漏。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
</ul>
<h2 id="强制转换"><a class="anchor" href="#强制转换">#</a> 强制转换</h2>
<h3 id="c-风格的类型转换"><a class="anchor" href="#c-风格的类型转换">#</a> C 风格的类型转换</h3>
<p>C 风格的类型转换在 C++ 中仍然可以使用，其基本格式如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TYPE a <span class="token operator">=</span> <span class="token punctuation">(</span>TYPE<span class="token punctuation">)</span> EXPRESSION<span class="token punctuation">;</span></pre></td></tr></table></figure><p>C 风格类型转换的缺点：</p>
<ol>
<li><strong>灵活性过高</strong>：C 风格的转换可以在任意类型之间进行，这可能导致不安全的转换，如将  <code>const</code>  指针转换为非  <code>const</code>  指针。</li>
<li><strong>难以查找和维护</strong>：C 风格的转换使用括号和类型标识符，这在 C++ 代码中非常常见，使得查找和维护转换代码变得困难。</li>
</ol>
<p>C++ 为了克服这些缺点，引进了 4 个新的类型转换操作符： <code>static_cast</code> ， <code>const_cast</code> ， <code>dynamic_cast</code> ， <code>reinterpret_cast</code> 。</p>
<h3 id="static_cast"><a class="anchor" href="#static_cast">#</a>  <code>static_cast</code></h3>
<p><code>static_cast</code>  是 C++ 中最常用的类型转换操作符，它用于在相关类型之间进行转换，但不能用于运行时类型检查。以下是  <code>static_cast</code>  的使用形式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>目标类型 转换后的变量 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>目标类型<span class="token operator">></span></span></span><span class="token punctuation">(</span>要转换的变量<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="基本类型转换"><a class="anchor" href="#基本类型转换">#</a> 基本类型转换</h4>
<p><code>static_cast</code>  可以用于基本数据类型之间的转换，例如将  <code>int</code>  转换为  <code>float</code> ：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> iNumber <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> fNumber <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>iNumber<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="指针类型转换"><a class="anchor" href="#指针类型转换">#</a> 指针类型转换</h4>
<p><code>static_cast</code>  也可以用于指针之间的转换，例如将  <code>void*</code>  指针转换成其他类型的指针：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span>pVoid <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pInt <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pVoid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">*</span>pInt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="限制"><a class="anchor" href="#限制">#</a> 限制</h4>
<p><code>static_cast</code>  不能完成任意两个指针类型间的转换，特别是不能将一个类型的指针转换为不相关的类型的指针，因为这可能导致未定义行为：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> iNumber <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pInt <span class="token operator">=</span> <span class="token operator">&amp;</span>iNumber<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> <span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pInt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：不能将 int* 转换为 float*</span></pre></td></tr></table></figure><h4 id="优势"><a class="anchor" href="#优势">#</a> 优势</h4>
<ol>
<li><strong>安全性</strong>： <code>static_cast</code>  不允许非法的转换发生，因为它在编译时进行检查。</li>
<li><strong>可读性</strong>：使用  <code>static_cast</code>  可以提高代码的可读性，因为它明确表示了类型转换的意图。</li>
<li><strong>易于查找</strong>：与 C 风格的转换相比， <code>static_cast</code>  更容易在代码中查找和识别。</li>
</ol>
<h3 id="const_cast"><a class="anchor" href="#const_cast">#</a>  <code>const_cast</code></h3>
<p><code>const_cast</code>  用于修改类型的  <code>const</code>  或  <code>volatile</code>  属性。它主要用于以下情况：</p>
<ol>
<li>
<p><strong>将常量指针转换为非常量指针</strong>：</p>
<p>指向常量的指针可以被转换为普通指针，但仍然指向原来的对象。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//int *pInt = &amp;number; // 错误</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pInt2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>将常量引用转换为非常量引用</strong>：</p>
<p>常量引用可以被转换为非常量引用，但仍然指向原来的对象。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>numberRef <span class="token operator">=</span> number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span>numberRef2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>numberRef<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li>
</ol>
<p><code>const_cast</code>  通常用于修改  <code>const</code>  属性，但应谨慎使用，以避免违反  <code>const</code>  正确性。基本不用于其他类型的转换。</p>
<h3 id="dynamic_cast"><a class="anchor" href="#dynamic_cast">#</a>  <code>dynamic_cast</code></h3>
<p>该运算符主要用于基类和派生类间的转换，尤其是向下转型的用法中。</p>
<h3 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a>  <code>reinterpret_cast</code></h3>
<p><code>reinterpret_cast</code>  是 C++ 中功能最强大的类型转换操作符，它允许进行以下类型的转换：</p>
<ol>
<li><strong>指针（或引用）类型之间的转换</strong>：
<ul>
<li>可以将任何指针类型转换为任何其他指针类型，包括将指针转换为足够大的整数类型，以及反过来。</li>
</ul>
</li>
<li><strong>指针与整数之间的转换</strong>：
<ul>
<li>可以将指针转换为整数，或者将整数转换为指针。</li>
</ul>
</li>
</ol>
<p>使用注意事项：</p>
<ul>
<li><code>reinterpret_cast</code>  的使用需要非常小心，因为它可以绕过类型系统的保护，导致未定义行为。</li>
<li>最正确的使用方式是将转换后的类型值转换回其原始类型。这种来回转换可以确保类型的一致性和安全性。</li>
<li>错误的使用  <code>reinterpret_cast</code>  可能导致程序崩溃或数据损坏，因为它允许进行几乎任意的类型转换。</li>
</ul>
<h2 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h2>
<p>在 C++ 中，函数重载（Function Overloading）是一种允许多个函数具有相同名称，但参数列表不同的特性。这使得程序员可以使用相同的函数名来执行相似的操作，但针对不同类型的数据。</p>
<h3 id="重载函数的定义"><a class="anchor" href="#重载函数的定义">#</a> 重载函数的定义</h3>
<ul>
<li><strong>相同函数名</strong>：重载函数具有相同的函数名。</li>
<li><strong>不同参数列表</strong>：每个重载函数的参数类型、数量或顺序必须至少有一个不同。</li>
</ul>
<h3 id="重载函数的优势"><a class="anchor" href="#重载函数的优势">#</a> 重载函数的优势</h3>
<ol>
<li><strong>减少函数名数量</strong>：通过重载，可以减少创建大量类似名称的函数，使代码更加简洁。</li>
<li><strong>提高可读性</strong>：使用相同的函数名可以提高代码的可读性，因为函数的行为更容易被理解。</li>
<li><strong>增加灵活性</strong>：允许程序员为不同类型的数据定义相同的操作，增加了代码的灵活性。</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数一"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数二"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数三"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数四"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数五"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="函数重载的规则"><a class="anchor" href="#函数重载的规则">#</a> 函数重载的规则</h3>
<p>在 C++ 中，函数重载允许在同一作用域内定义多个具有相同名称但参数列表不同的函数。参数列表的不同可以包括：</p>
<ol>
<li><strong>参数的数量</strong>：函数接受不同数量的参数。</li>
<li><strong>参数的类型</strong>：即使参数数量相同，参数的类型也可以不同。</li>
<li><strong>参数的顺序</strong>：参数的顺序也会影响重载决策。</li>
</ol>
<p>重载的决策不包括 <strong>返回类型</strong>：仅当返回类型不同时，不能构成重载。如果两个函数的参数列表完全相同，但返回类型不同，它们不会被视为重载，而是两个不同的函数。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数一"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数二"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 错误：仅当返回类型不同时，不能构成重载</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">/* int add(double x, double y)&#123; */</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">/*   cout &lt;&lt; "函数三" &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">/*   return x + y; */</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">/* &#125; */</span></pre></td></tr></table></figure><h3 id="函数重载的实现原理"><a class="anchor" href="#函数重载的实现原理">#</a> 函数重载的实现原理</h3>
<p>在 C++ 中，当函数重载时，编译器会对函数名进行改编，以确保每个函数都有一个唯一的标识符。这个过程通常涉及以下信息：</p>
<ol>
<li><strong>函数名</strong>：原始的函数名称。</li>
<li><strong>参数类型</strong>：函数接受的参数类型。</li>
<li><strong>参数顺序</strong>：参数在函数声明中的顺序。</li>
<li><strong>参数数量</strong>：函数接受的参数总数。</li>
</ol>
<p>名字改编的作用</p>
<ul>
<li><strong>确保唯一性</strong>：改编后的名称是唯一的，即使在不同的作用域中存在同名函数，只要参数列表不同，编译器也能区分它们。</li>
<li><strong>支持链接</strong>：在大型项目中，名字改编确保了不同编译单元中的同名函数可以被正确链接。</li>
</ul>
<p>函数重载的优缺点</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>代码简洁</strong>：可以使用相同的函数名来处理不同类型的数据，减少了代码的冗余。</li>
<li><strong>提高可读性</strong>：使得代码更加直观，易于理解和维护。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>编译器效率</strong>：编译器需要额外处理名字改编，可能会稍微降低编译效率。</li>
<li><strong>调用歧义</strong>：在某些情况下，重载函数的调用可能不够明确，需要程序员提供更多的信息来消除歧义。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmVGJxSDFFNDVWSG9vTklkU19Dd24wQmtrbWFBWEgzTDNlckprYS1na3F6YUE_ZT1JV2gxNmg.png" alt="" /></p>
<h3 id="extern-c"><a class="anchor" href="#extern-c">#</a> extern C</h3>
<p>在 C++ 中，函数名在编译时可能会经过名字改编（Name Mangling），这是为了支持函数重载。然而，C 语言不支持重载，因此 C 编译器不会对函数名进行改编。为了确保 C++ 编译器在处理 C 代码或与 C 代码交互时不进行名字改编，可以使用  <code>extern &quot;C&quot;</code> 。</p>
<p><strong>修饰单个函数</strong>：当只需要确保某个函数按照 C 语言的链接约定编译时，可以直接在函数声明前使用  <code>extern &quot;C&quot;</code> 。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 函数实现</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>修饰多个函数或代码块</strong>：当需要将多个函数或整个代码块按照 C 语言的链接约定编译时，可以使用大括号  <code>&#123;&#125;</code>  包围这些函数或代码。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 函数实现</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 函数实现</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用 C 语言库：当 C++ 程序需要调用 C 语言库中的函数时，应该使用  <code>extern &quot;C&quot;</code>  来确保函数名不会被改编，从而保证链接正确。</p>
<h2 id="默认参数"><a class="anchor" href="#默认参数">#</a> 默认参数</h2>
<h3 id="默认参数的目的"><a class="anchor" href="#默认参数的目的">#</a> 默认参数的目的</h3>
<p>在 C++ 中，可以在函数声明时为参数指定默认值。如果在函数调用时没有提供对应的实参，函数会使用这些默认值。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 为参数 x 和 y 指定默认值 0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 调用时提供两个参数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 只提供第一个参数，y 使用默认值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 没有提供任何参数，x 和 y 都使用默认值</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>缺省调用</strong>：在调用函数时，如果某些参数没有提供实参，函数会使用参数的默认值。</p>
<p><strong>传入的参数优先级高于默认参数</strong>：如果在函数调用时提供了某个参数的实参，即使后面还有未提供的参数，后面的参数也会使用默认值。</p>
<p>注意事项：</p>
<ol>
<li><strong>默认参数应在函数声明时定义</strong>：不能在函数定义时才指定默认参数。</li>
<li><strong>默认参数只能用于函数声明</strong>：在 C++ 中，函数的定义（实现）不能包含默认参数，必须与声明完全一致。</li>
</ol>
<h3 id="默认参数的声明"><a class="anchor" href="#默认参数的声明">#</a> 默认参数的声明</h3>
<p>在 C++ 中，函数的默认参数通常在函数的声明中提供。这样做的原因是：</p>
<ol>
<li><strong>编译器在编译时已经知道默认值</strong>：这使得编译器在处理函数调用时能够正确地识别哪些参数使用了默认值。</li>
<li><strong>避免在函数定义中重复默认值</strong>：在声明中设置默认值后，定义中不需要再次指定。</li>
</ol>
<p><strong>声明中设置默认值</strong>：声明中设置默认值是推荐的做法，因为它允许编译器在处理函数调用之前就知道所有必要的信息。</p>
<p><strong>定义中设置默认值</strong>：如果在定义中设置默认值，函数的定义必须在任何函数调用之前。这是因为编译器需要在处理调用时知道参数的默认值。</p>
<p>正确的示例：在声明中设置默认值</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 声明中设置默认值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//y 使用默认值</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//x 和 y 都使用默认值</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 定义</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>错误的示例：在定义中设置默认值</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 声明</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 错误：在调用时编译器不知道默认值</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 定义中设置默认值</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意事项</p>
<ol>
<li><strong>不要在声明和定义中都设置默认值</strong>：这会导致编译错误，因为编译器会看到两个不同的默认值设置。</li>
<li><strong>确保定义与声明匹配</strong>：如果声明中设置了默认值，定义中也必须使用相同的默认值。</li>
</ol>
<h3 id="默认参数的顺序规定"><a class="anchor" href="#默认参数的顺序规定">#</a> 默认参数的顺序规定</h3>
<p>在 C++ 中，如果一个函数有多个参数，并且其中一些参数有默认值，那么这些默认参数必须按照从右到左的顺序定义。这是因为在调用函数时，如果省略了一些参数，编译器需要能够从左到右匹配剩余的参数。</p>
<p>正确的默认参数定义：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 正确的默认参数定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", c = "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">", d = "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//c 和 d 使用默认值</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//d 使用默认值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 所有参数都指定了值</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>错误的默认参数定义</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 错误的默认参数定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 错误：b 在有默认值的参数之前</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", c = "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">", d = "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">//func (1, 2); // 这会导致编译错误，因为 b 没有默认值，而 c 有默认值</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>从左到右匹配</strong>：在调用函数时，实参是从左到右匹配形参的。如果某个参数有默认值，那么它后面的所有参数也必须有默认值，以确保可以正确地省略参数。</p>
<h3 id="默认参数与函数重载"><a class="anchor" href="#默认参数与函数重载">#</a> 默认参数与函数重载</h3>
<p>使用默认参数可以将多个重载的函数合并为一个，减少代码的冗余。例如，以下三个重载函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以合并为一个带有默认参数的函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样，通过省略参数，可以灵活地调用函数。</p>
<p>在使用默认参数时，必须确保不会引起调用的二义性。如果一组重载函数（可能带有默认参数）都允许相同实参个数的调用，将会引起调用的二义性。</p>
<p>正确的示例：合并重载函数</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 合并重载函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用所有默认值</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//y 使用默认值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 所有参数都指定了值</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>错误的示例：引起二义性</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 引起二义性的重载</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：无法确定调用的是哪种形式的 func</span></pre></td></tr></table></figure><h2 id="bool-类型"><a class="anchor" href="#bool-类型">#</a>  <code>bool</code>  类型</h2>
<ol>
<li>
<p><strong>逻辑值</strong>：</p>
<ul>
<li><code>bool</code>  类型有两个可能的值： <code>true</code>  和  <code>false</code> 。</li>
</ul>
</li>
<li>
<p><strong>隐式转换</strong>：</p>
<ul>
<li>任何数字或指针值都可以隐式转换为  <code>bool</code>  类型。</li>
<li>非零值（包括所有非空指针）转换为  <code>true</code> ，零值（包括空指针）转换为  <code>false</code> 。</li>
</ul>
</li>
<li>
<p><strong>字面值转换</strong>：</p>
<ul>
<li><code>true</code>  和  <code>false</code>  可以隐式转换为  <code>int</code>  类型，其中  <code>true</code>  转换为 1， <code>false</code>  转换为 0。</li>
</ul>
</li>
<li>
<p><strong>存储大小</strong>：</p>
<ul>
<li><code>bool</code>  类型的变量通常占用 1 个字节的空间，但实际大小可能取决于编译器的实现。</li>
</ul>
</li>
</ol>
<p>示例代码</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 隐式转换 true 和 false 为 int</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//x 的值为 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//y 的值为 0</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// 隐式转换数字和指针为 bool</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// true</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token comment">// true</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">bool</span> b3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// false</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">bool</span> b4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// true</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">bool</span> b5 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// true</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">bool</span> b6 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// false</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token comment">// 显示 bool 变量的大小</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Size of bool: "</span> <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> <span class="token string">" bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// Size of bool: 1 bytes</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token comment">// 隐式转换演示</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b1 (-100) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b1 (-100) as bool: 1 (true or false)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b2 (100) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b2 (100) as bool: 1 (true or false)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b3 (0) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b3<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b3 (0) as bool: 0 (true or false)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b4 (1) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b4<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b4 (1) as bool: 1 (true or false)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b5 (true) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b5<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b5 (true) as bool: 1 (true or false)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b6 (false) as bool: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">bool</span><span class="token punctuation">(</span>b6<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" (true or false)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// b6 (false) as bool: 0 (true or false)</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意事项</p>
<ul>
<li><strong>隐式转换</strong>：虽然  <code>bool</code>  类型可以与其他类型隐式转换，但应谨慎使用，以避免逻辑错误。</li>
<li><strong>条件表达式</strong>：在条件表达式中，如  <code>if</code>  或  <code>while</code>  语句中，任何非  <code>bool</code>  类型的表达式都会转换为  <code>bool</code>  类型。</li>
<li><strong>存储大小</strong>：尽管  <code>bool</code>  变量通常占用 1 个字节，但 C++ 标准没有明确规定其大小，因此依赖于编译器和平台。</li>
</ul>
<h2 id="inline-函数"><a class="anchor" href="#inline-函数">#</a> inline 函数</h2>
<h3 id="普通函数"><a class="anchor" href="#普通函数">#</a> 普通函数</h3>
<p>在 C++ 编程中，确定两个整数中的最大值通常可以通过定义一个专门的函数来实现，如下所示：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token operator">?</span> x <span class="token operator">:</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>尽管一些人可能会认为，直接使用三元运算符来获取两个数中的最大值更为便捷，但定义一个函数有其独特的优势：</p>
<ol>
<li><strong>提高可读性</strong>：调用  <code>max</code>  函数比阅读并理解一个等价的条件表达式更为直观，尤其是在函数返回值被用于更复杂的表达式中时。</li>
<li><strong>便于维护</strong>：如果需要对最大值的获取逻辑进行修改，只需更改函数内部的实现，而不必在代码中搜索并修改每一个等价的条件表达式。</li>
<li><strong>确保一致性</strong>：使用函数可以保证在不同地方调用时行为的一致性，这对于测试和验证代码的正确性至关重要。</li>
<li><strong>代码重用</strong>：定义函数意味着可以在不同的程序中重用相同的代码，而无需重复编写相同的逻辑。</li>
</ol>
<p>然而，将逻辑封装在函数中也有其潜在的不足之处：函数调用通常比直接执行等价表达式要消耗更多的时间。</p>
<p>在大多数计算机系统中，函数调用涉及到一系列的开销：保存寄存器状态、复制参数、跳转到函数的内存地址执行等。对于如此简单的操作，使用函数可能会引入不必要的性能开销。当然，在 C++ 中，我们可以通过 <strong>内联函数</strong>（inline functions）来减少这种开销，因为编译器会尝试将内联函数的代码直接插入到调用点，从而避免函数调用的额外开销。</p>
<p>此外，对于 C 语言，还可以考虑使用 <strong>宏定义</strong>（macro definitions）来实现类似的功能，并通过编译器优化来提高执行效率。在 C++ 中，宏定义通常不推荐用于此类逻辑，因为它们不提供类型检查，且可能导致预处理时的意外行为。相反，内联函数提供了一个更安全且类型安全的替代方案。</p>
<h3 id="宏定义"><a class="anchor" href="#宏定义">#</a> 宏定义</h3>
<p>在 C 语言中，宏定义是一种提高代码执行效率的方法。宏定义通过预处理器在编译前将代码片段替换为指定的表达式，避免了函数调用的开销，如参数传递、栈操作和返回指令等。</p>
<p>然而，宏定义存在一些潜在的问题，如边际效应，这可能导致意料之外的结果。例如：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//res 的值是多少？</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> res2 <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//res2 的值是多少？</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 预处理器将扩展为: result = (i) > (j) ? (i) : (j) + 20</span></pre></td></tr></table></figure><p>为了避免这类问题，宏定义可以修改为：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr></table></figure><p>尽管如此，宏定义仍然可能引入其他问题，如：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//res 的值是多少？</span></pre></td></tr><tr><td data-num="4"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//i 的值是多少？</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 预处理器将扩展为: result = ((i++) > (j) ? (i++) : (j));</span></pre></td></tr></table></figure><p>宏定义的替换机制不进行安全检查，可能会导致复杂表达式的错误。</p>
<p>在 C++ 中，内联函数提供了一种更安全且高效的替代方案。内联函数通过编译器优化，减少了函数调用的开销，同时保持了代码的可读性和可维护性。</p>
<p>与宏定义不同，内联函数支持调试。在调试模式下，内联函数不会真正内联，而是像普通函数一样生成包含调试信息的代码。这使得开发者能够在调试过程中跟踪函数调用和变量状态。</p>
<h3 id="内联函数"><a class="anchor" href="#内联函数">#</a> 内联函数</h3>
<p>在 C++ 编程中，内联函数是一种优化技术，旨在减少函数调用的开销，从而提高程序的执行效率。通过在函数定义前添加  <code>inline</code>  关键字，开发者向编译器提出将该函数内联展开的建议。</p>
<p>内联函数的工作机制：</p>
<ol>
<li>
<p><strong>内联展开</strong>：当编译器接受内联建议时，它会在编译阶段将函数的定义直接替换到函数调用的位置。这种替换可以减少函数调用的开销，如参数传递、栈操作和返回指令等。</p>
</li>
<li>
<p><strong>符号表的使用</strong>：内联函数的声明和定义被存储在编译器的符号表中。在调用内联函数时，编译器会进行类型安全检查和自动类型转换，确保调用的正确性。</p>
</li>
<li>
<p><strong>调试支持</strong>：与宏定义不同，内联函数在调试模式下不会真正展开。编译器会为内联函数生成包含调试信息的可执行代码，使得开发者能够在调试过程中跟踪函数调用和变量状态。</p>
</li>
</ol>
<p>内联函数的使用建议：</p>
<ol>
<li>
<p><strong>内联建议的非强制性</strong>： <code>inline</code>  关键字只是一个建议，编译器有权决定是否进行内联展开。编译器会根据函数的复杂度、调用频率和优化策略来决定是否内联。</p>
</li>
<li>
<p><strong>编译时展开</strong>：内联展开发生在编译时，这与预处理器的宏展开不同。编译器在内联展开时会执行类型安全检查和自动类型转换，确保代码的正确性。</p>
</li>
<li>
<p><strong>代码膨胀的考虑</strong>：如果函数体过长或包含复杂的控制结构（如循环），则不建议使用内联。内联这样的函数可能会导致代码膨胀，从而增加程序的大小，降低缓存命中率，反而降低程序的性能。</p>
</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 add 函数，编译器可能会进行内联展开</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上述示例中， <code>add</code>  函数是一个内联函数，它在调用时可能会被编译器内联展开，以提高执行效率。然而，如果  <code>add</code>  函数的实现变得复杂，或者调用频率不高，编译器可能会选择不进行内联展开。</p>
<p>在 C++ 中使用内联函数时，需要注意以下几个关键点以确保代码的正确性和效率：</p>
<ol>
<li>
<p>内联函数声明与实现分离：内联函数可以在头文件中声明和定义，也可以在源文件中定义。但是，如果声明和定义分离，编译器可能无法在调用点找到函数的定义，从而无法进行内联展开。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 按照普通函数的形式调用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">////////////////////////////////////</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 按照内联函数的形式调用</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">////////////////////////////////////</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// 按照内联函数的形式调用</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p>内联函数的定义必须在头文件中：如果内联函数的声明在头文件中，那么其定义也必须在头文件中，以确保在每个调用点都能被正确内联展开。这是因为编译器在编译时需要访问到函数的完整定义来进行替换。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 该语句在头文件中</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 实现在 .cpp 文件中</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">//... </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//foo 函数不能成为内联函数</span></pre></td></tr></table></figure></li>
<li>
<p>内联函数的定义位置</p>
<ul>
<li>
<p><strong>头文件中的内联定义</strong>：将内联函数的定义放在头文件中可以确保所有包含该头文件的源文件都能使用相同的函数定义，从而实现内联展开。</p>
</li>
<li>
<p><strong>源文件中的内联定义</strong>：如果内联函数定义在源文件中，那么只有该源文件中的调用可以内联，其他源文件则无法内联该函数。</p>
</li>
</ul>
</li>
<li>
<p>内联函数的使用注意事项</p>
<ul>
<li>
<p><strong>代码膨胀</strong>：内联函数虽然可以减少函数调用的开销，但会增加代码量，可能导致内存占用增加，特别是在函数体较大或被频繁调用时。</p>
</li>
<li>
<p><strong>执行效率</strong>：如果函数体内的执行时间远大于函数调用的开销，内联可能不会带来显著的性能提升。</p>
</li>
<li>
<p><strong>编译器的决策</strong>：编译器会根据函数的复杂度和调用频率来决定是否内联。复杂的函数或调用频率不高的函数可能不会被内联。</p>
</li>
</ul>
</li>
<li>
<p>内联函数的适用场景</p>
<ul>
<li>
<p><strong>简单函数</strong>：对于逻辑简单、执行速度快的函数，内联可以显著提高执行效率。</p>
</li>
<li>
<p><strong>频繁调用的函数</strong>：对于在程序中被频繁调用的函数，内联可以减少重复的函数调用开销。</p>
</li>
</ul>
</li>
<li>
<p>编译器的优化：现代编译器通常具有智能的内联决策机制，能够自动决定哪些函数适合内联，哪些不适合。</p>
</li>
</ol>
<h3 id="三种函数之间的比较"><a class="anchor" href="#三种函数之间的比较">#</a> 三种函数之间的比较</h3>
<p>宏函数</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>执行效率高</strong>：宏函数通过预处理器进行文本替换，不涉及函数调用的开销，适合用于简单的、频繁执行的代码片段。</li>
<li><strong>简单替换</strong>：对于非常简短的操作，如条件判断或简单的算术运算，宏可以提供快速的执行。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>缺乏类型检查</strong>：宏在预处理阶段进行文本替换，不进行类型安全检查，可能导致运行时错误。</li>
<li><strong>易于出错</strong>：宏的替换可能导致意外的边际效应，如操作符优先级问题，使得代码难以维护和理解。</li>
<li><strong>不可调试</strong>：宏展开后的代码在调试时难以追踪，因为它们在编译前就已经被替换，失去了原有的函数调用结构。</li>
</ul>
<p>普通函数</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>类型安全</strong>：普通函数在编译时进行类型检查，确保参数和返回值的类型正确。</li>
<li><strong>易于调试</strong>：函数调用在调试时清晰可见，便于追踪和分析程序的执行流程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>调用开销</strong>：每次函数调用都会涉及参数传递、栈操作等开销，可能影响程序性能，尤其是在频繁调用的情况下。</li>
</ul>
<p>内联函数</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>效率与安全兼备</strong>：内联函数在编译时展开，减少了函数调用的开销，同时保留了类型检查和调试信息。</li>
<li><strong>代码优化</strong>：内联函数可以减少小函数调用的开销，同时保持代码的可读性和可维护性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>代码膨胀</strong>：如果内联函数体较大，可能会导致代码膨胀，增加程序的内存占用。</li>
<li><strong>编译器决策</strong>：内联的决定权在编译器，编译器可能基于性能和代码大小的权衡决定是否内联。</li>
</ul>
<p>在 C++ 中，推荐尽可能使用内联函数来取代宏函数，因为它们提供了更好的类型安全性和调试支持，同时还能保持较高的执行效率。然而，对于复杂的函数或在性能敏感的应用中，应仔细考虑是否使用内联，以避免不必要的代码膨胀和性能下降。普通函数则适用于需要频繁调用且逻辑复杂的场景，尽管它们会带来一定的调用开销。</p>
<h2 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h2>
<p>异常处理允许程序在遇到错误时，优雅地处理问题，而不是直接崩溃。C++ 异常处理主要涉及三个关键字： <code>try</code> 、 <code>catch</code>  和  <code>throw</code> 。</p>
<p>当程序检测到错误条件时，可以使用  <code>throw</code>  语句来抛出一个异常。异常可以是任何类型的表达式，包括基本数据类型、对象或字符串。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> <span class="token function">division</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">throw</span> <span class="token string">"Division by zero condition!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，如果尝试除以零，程序将抛出一个字符串异常。</p>
<p><code>try</code>  块用于包围可能抛出异常的代码。 <code>catch</code>  块用于捕获并处理这些异常。可以有多个  <code>catch</code>  块来处理不同类型的异常。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">division</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 捕获 char* 类型的异常</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error: "</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 捕获所有类型的异常</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"An unknown error occurred."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，如果  <code>division</code>  函数抛出异常， <code>try-catch</code>  块将捕获该异常并处理它。</p>
<p>注意事项：</p>
<ul>
<li><strong>异常类型匹配</strong>： <code>catch</code>  块捕获的是异常的类型，而不是具体的信息。例如， <code>catch (const char* msg)</code>  只能捕获  <code>char*</code>  类型的异常。</li>
<li><strong>异常的传递</strong>：如果一个  <code>catch</code>  块没有捕获到异常，控制权将传递给下一个  <code>catch</code>  块。</li>
<li><strong>异常的安全性</strong>：在抛出和捕获异常时，应确保程序的安全性和数据的完整性。</li>
</ul>
<p>异常处理的建议：</p>
<ul>
<li><strong>精确捕获</strong>：尽量使用具体的异常类型，而不是使用  <code>catch (...)</code> ，这可以提供更精确的错误处理。</li>
<li><strong>资源管理</strong>：在异常可能发生的地方，确保资源（如文件句柄、网络连接等）得到正确管理，例如使用 RAII（资源获取即初始化）技术。</li>
<li><strong>异常的文档</strong>：在函数或类的文档中明确指出可能抛出的异常，以便调用者可以正确处理。</li>
</ul>
<h2 id="内存布局"><a class="anchor" href="#内存布局">#</a> 内存布局</h2>
<p>以 32 位系统为例，一个进程在执行时，能够访问的空间是 <strong>虚拟地址空间</strong>。理论上为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>，即 4G，有 1G 左右的空间是内核态，剩下的 3G 左右的空间是用户态。从高地址到低地址可以分为五个区域：</p>
<ol>
<li>
<p><strong>栈区（Stack）</strong>：</p>
<ul>
<li>由操作系统自动管理。</li>
<li>用于存储局部变量、函数参数、返回地址等。</li>
<li>通常从高地址向低地址增长。</li>
<li>每个线程拥有自己的栈空间，以支持多线程环境下的数据隔离。</li>
</ul>
</li>
<li>
<p><strong>堆区（Heap）</strong>：</p>
<ul>
<li>由程序员通过  <code>malloc</code> 、 <code>new</code>  等函数手动管理。</li>
<li>用于动态内存分配，如创建动态数组、对象等。</li>
<li>从低地址向高地址增长。</li>
<li>堆区的大小通常由操作系统限制，但可以通过程序调整。</li>
</ul>
</li>
<li>
<p><strong>全局 / 静态区（Data Segment）</strong>：</p>
<ul>
<li>存储全局变量和静态变量。</li>
<li>包括初始化数据段和未初始化数据段（BSS 段）。</li>
<li>全局变量在程序启动时分配，生命周期贯穿整个程序。</li>
</ul>
</li>
<li>
<p><strong>文字常量区（Text Segment/Read-Only Data Segment）</strong>：</p>
<ul>
<li>存储程序中使用的只读数据，如字符串常量。</li>
<li>例如， <code>const char* p = &quot;hello&quot;;</code>  中的 &quot;hello&quot; 存储在此区域。</li>
<li>此区域在程序运行期间通常不可修改。</li>
</ul>
</li>
<li>
<p><strong>程序代码区（Text Segment）</strong>：</p>
<ul>
<li>存储程序的二进制指令。</li>
<li>此区域为只读，以防止程序运行时被修改。</li>
<li>包含函数定义、操作指令等。</li>
</ul>
</li>
</ol>
<p>内存管理注意事项：</p>
<ul>
<li><strong>栈溢出</strong>：如果栈空间使用过多，可能会导致栈溢出，这可能覆盖其他内存区域，引发安全问题。</li>
<li><strong>堆溢出</strong>：不当的内存管理可能导致堆溢出，同样可能破坏内存数据，引发安全问题。</li>
<li><strong>内存泄漏</strong>：未正确释放已分配的堆内存，可能导致内存泄漏，随着时间的推移，可能会耗尽系统资源。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSXzdpNTU4WEJsR21WMElZOVdsTHdRQjl2akxIdlg1V3hIWUtWU3pETjJBSVE_ZT1yTVdzOGY.png" alt="undefined202403061703535.png" /></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">namespace</span> wd <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> wNum <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> gNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> cNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">const</span> <span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;num3:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;num3:0x7ffd36174da4</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;num2:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;num2:0x7ffd36174da0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;num1:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>num1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;num1:0x7ffd36174d9c</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p:"</span> <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// p:0x556afaa742c0</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">int</span> sNum <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;sNum:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>sNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;sNum:0x556afa45e018</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;gNum:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>gNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;gNum:0x556afa45e014</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;wNum:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>wd<span class="token double-colon punctuation">::</span>wNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;wNum:0x556afa45e010</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstr <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> pstr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// hello</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x556afa45c035</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pstr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x556afa45c035</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pstr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x556afa45c035</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;cNum:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>cNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// &amp;cNum:0x556afa45c004</span></pre></td></tr><tr><td data-num="39"></td><td><pre> </pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>test0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x556afa45b249</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>  <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x556afa45b58e</span></pre></td></tr><tr><td data-num="46"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="c-风格字符串"><a class="anchor" href="#c-风格字符串">#</a> C 风格字符串</h2>
<p>C 风格字符串是 C 和 C++ 语言中处理文本数据的一种基本方式。它们是由字符组成的数组，以空字符（ <code>'\0'</code> ，值为 0 的字符）作为字符串的结束标志。</p>
<p>使用字符数组存储字符串时，需要在数组的最后一个元素位置留出空间放置空字符，以标识字符串的结束。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'h'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'l'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'\0'</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"World!"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当使用指针来存储字符串时，通常定义为  <code>const char *</code>  类型，这样可以确保字符串内容不会被修改，增强代码的安全性。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 这里的字符串是只读的，str 指针指向一个只读内存区域</span></pre></td></tr></table></figure><p>字符串常量通常存放在程序的只读数据段。如果使用  <code>char *</code>  指针指向字符串常量，理论上存在修改字符串内容的风险，尽管大多数现代编译器会禁止这么做。</p>
<p>在 C++ 中，输出流运算符（ <code>&lt;&lt;</code> ）对于  <code>char *</code>  类型有重载，可以直接输出字符串的内容而不是地址。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出字符串内容</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意事项</p>
<ul>
<li><strong>安全性</strong>：使用  <code>const char *</code>  而不是  <code>char *</code>  来避免意外修改字符串常量。</li>
<li><strong>内存管理</strong>：C 风格字符串不涉及动态内存分配，但如果你使用  <code>strdup</code>  等函数复制字符串，需要记得释放内存。</li>
<li><strong>编码问题</strong>：C 风格字符串通常使用 ASCII 或 UTF-8 编码，处理非 ASCII 字符时需要注意编码问题。</li>
</ul>
<div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i>C++</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-02-02 22:12:15" itemprop="dateModified" datetime="2025-02-02T22:12:15+08:00">2025-02-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="http://cwlrin.wiki/c-cpp/cpp-base/%E4%BB%8E%20C%20%E5%88%B0%20C++/" title="从 C 到 C++">http://cwlrin.wiki/c-cpp/cpp-base/从 C 到 C++/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E6%B1%A0/" rel="prev" itemprop="url" title="Linux 进程池" style="background-image: linear-gradient(to bottom right, #d9bcf8, #c69bfa);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Linux C</span><h3>Linux 进程池</h3></a></div><div class="item right"><a href="/c-cpp/cpp-base/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" rel="next" itemprop="url" title="C++ 类和对象" style="background-image: linear-gradient(to bottom right, #cba0ff, #b1f1cd);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>C++ 基础</span><h3>C++ 类和对象</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.</span> <span class="toc-text"> 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.</span> <span class="toc-text"> 为什么要使用命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.</span> <span class="toc-text"> 什么是命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text"> 命名空间的使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 作用域限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#using-%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text"> using 编译指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#using-%E5%A3%B0%E6%98%8E%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text"> using 声明机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text"> 命名空间的嵌套使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text"> 匿名命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text"> 跨模块调用问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E7%9A%84"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 全局变量和函数是可以跨模块调用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E5%8F%AF%E4%BB%A5%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 有名命名空间中的实体可以跨模块调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%9C%AC%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 静态变量和函数只能在本模块内部使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9E%E4%BD%93%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%9C%AC%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 匿名空间的实体只能在本模块内部使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-%E5%92%8C-include"><span class="toc-number">1.6.5.</span> <span class="toc-text"> extern 和 include</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#extern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.5.1.</span> <span class="toc-text"> extern 的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#include-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.5.2.</span> <span class="toc-text"> include 的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.5.3.</span> <span class="toc-text"> 对比和选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text"> 使用命名空间的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 多次定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.</span> <span class="toc-text"> 重复定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text"> 实体使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text"> 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 命名空间的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 命名空间使用建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 包含头文件的顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text"> const 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 修饰内置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text"> const 常量和宏定义常量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> 修饰指针类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88pointer-to-const"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 指向常量的指针（Pointer to const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88const-pointer"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 常量指针（Const pointer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88const-pointer-to-const"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 指向常量的常量指针（Const pointer to const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88pointer-to-array"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 数组指针（Pointer to array）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84array-of-pointers"><span class="toc-number">2.3.5.</span> <span class="toc-text"> 指针数组（Array of pointers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88pointer-to-function"><span class="toc-number">2.3.6.</span> <span class="toc-text"> 函数指针（Pointer to function）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0function-that-returns-a-pointer"><span class="toc-number">2.3.7.</span> <span class="toc-text"> 指针函数（Function that returns a pointer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.4.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newdelete-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text"> new&#x2F;delete 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cc%E7%94%B3%E8%AF%B7-%E9%87%8A%E6%94%BE%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.</span> <span class="toc-text"> C&#x2F;C++ 申请、释放堆空间的方式对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text"> C 语言中的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text"> C++ 中的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mallocfree-%E5%92%8C-newdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text"> malloc&#x2F;free 和 new&#x2F;delete 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%B3%E8%AF%B7%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4"><span class="toc-number">3.2.</span> <span class="toc-text"> new 表达式申请数组空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%A9%BA%E9%97%B4%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text"> 回收空间时的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9B%9E%E6%94%B6%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="toc-number">3.4.</span> <span class="toc-text"> 申请空间和回收空间的匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%9B%9E%E6%94%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 安全回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text"> 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text"> 引用的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.2.</span> <span class="toc-text"> 引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text"> 引用与指针的联系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.</span> <span class="toc-text"> 引用的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 引用作为函数的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 引用作为函数的返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text"> 强制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.</span> <span class="toc-text"> C 风格的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static_cast"><span class="toc-number">5.2.</span> <span class="toc-text">  static_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 基本类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 指针类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">5.2.4.</span> <span class="toc-text"> 优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const_cast"><span class="toc-number">5.3.</span> <span class="toc-text">  const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic_cast"><span class="toc-number">5.4.</span> <span class="toc-text">  dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret_cast"><span class="toc-number">5.5.</span> <span class="toc-text">  reinterpret_cast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.</span> <span class="toc-text"> 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text"> 重载函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">6.2.</span> <span class="toc-text"> 重载函数的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">6.3.</span> <span class="toc-text"> 函数重载的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text"> 函数重载的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-c"><span class="toc-number">6.5.</span> <span class="toc-text"> extern C</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> 默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">7.1.</span> <span class="toc-text"> 默认参数的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.2.</span> <span class="toc-text"> 默认参数的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%AE%9A"><span class="toc-number">7.3.</span> <span class="toc-text"> 默认参数的顺序规定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.4.</span> <span class="toc-text"> 默认参数与函数重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bool-%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">  bool  类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text"> inline 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text"> 普通函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">9.2.</span> <span class="toc-text"> 宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text"> 内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">9.4.</span> <span class="toc-text"> 三种函数之间的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text"> 异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">11.</span> <span class="toc-text"> 内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.</span> <span class="toc-text"> C 风格字符串</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li  class="active"><a href="/c-cpp/cpp-base/%E4%BB%8E%20C%20%E5%88%B0%20C++/" rel="bookmark" title="从 C 到 C++">从 C 到 C++</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" rel="bookmark" title="C++ 类和对象">C++ 类和对象</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="bookmark" title="C++ 输入输出流">C++ 输入输出流</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" rel="bookmark" title="C++ 运算符重载">C++ 运算符重载</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E5%85%B3%E8%81%94%E6%80%A7%E5%AE%B9%E5%99%A8/" rel="bookmark" title="C++ 关联性容器">C++ 关联性容器</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%BB%A7%E6%89%BF/" rel="bookmark" title="C++ 继承">C++ 继承</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E5%A4%9A%E6%80%81/" rel="bookmark" title="C++ 多态">C++ 多态</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="C++ 模板">C++ 模板</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" rel="bookmark" title="C++ 移动语义">C++ 移动语义</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" rel="bookmark" title="C++ 资源管理">C++ 资源管理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">91</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/cpp-base/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/linux-c/Linux%20%E8%BF%9B%E7%A8%8B%E6%B1%A0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.4m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">21:46</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `c-cpp/cpp-base/从 C 到 C++/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.20" type="module" fetchpriority="high" defer></script></body></html>