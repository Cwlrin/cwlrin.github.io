<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Nana7ha's Café Stella" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Nana7ha's Café Stella" type="application/atom+xml"><link rel="alternate" type="application/json" title="Nana7ha's Café Stella" href="http://cwlrin.github.io/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.14"><link rel="modulepreload" href="/js/chunk-3QGRG5LW.js"></link><link rel="modulepreload" href="/js/chunk-UI4753RE.js"></link><link rel="modulepreload" href="/js/chunk-W4TLJ2OW.js"></link><link rel="modulepreload" href="/js/copy-tex-AOQYTOAX.js"></link><link rel="modulepreload" href="/js/index.esm-CJDJKRJB.js"></link><link rel="modulepreload" href="/js/post-3U5GTE2G.js"></link><link rel="modulepreload" href="/js/quicklink-SMYWLNBX.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="s" as="image" fetchpriority="high"><link rel="preload" href=":" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="i" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="." as="image" fetchpriority="high"><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="o" as="image" fetchpriority="high"><link rel="preload" href="s" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="r" as="image" fetchpriority="high"><link rel="preload" href="v" as="image" fetchpriority="high"><link rel="preload" href="/" as="image" fetchpriority="high"><link rel="preload" href="a" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="R" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="c" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="6" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="y" as="image" fetchpriority="high"><link rel="preload" href="8" as="image" fetchpriority="high"><link rel="preload" href="x" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="H" as="image" fetchpriority="high"><link rel="preload" href="J" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="z" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="v" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="y" as="image" fetchpriority="high"><link rel="preload" href="9" as="image" fetchpriority="high"><link rel="preload" href="i" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="G" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="j" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="j" as="image" fetchpriority="high"><link rel="preload" href="h" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="M" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="L" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="5" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="R" as="image" fetchpriority="high"><link rel="preload" href="m" as="image" fetchpriority="high"><link rel="preload" href="e" as="image" fetchpriority="high"><link rel="preload" href="E" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="x" as="image" fetchpriority="high"><link rel="preload" href="S" as="image" fetchpriority="high"><link rel="preload" href="G" as="image" fetchpriority="high"><link rel="preload" href="t" as="image" fetchpriority="high"><link rel="preload" href="3" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="l" as="image" fetchpriority="high"><link rel="preload" href="9" as="image" fetchpriority="high"><link rel="preload" href="4" as="image" fetchpriority="high"><link rel="preload" href="N" as="image" fetchpriority="high"><link rel="preload" href="2" as="image" fetchpriority="high"><link rel="preload" href="R" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="0" as="image" fetchpriority="high"><link rel="preload" href="s" as="image" fetchpriority="high"><link rel="preload" href="4" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="k" as="image" fetchpriority="high"><link rel="preload" href="g" as="image" fetchpriority="high"><link rel="preload" href="5" as="image" fetchpriority="high"><link rel="preload" href="e" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="9" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="Y" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="d" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="U" as="image" fetchpriority="high"><link rel="preload" href="J" as="image" fetchpriority="high"><link rel="preload" href="X" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="C" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="u" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="W" as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="r" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="c" as="image" fetchpriority="high"><link rel="preload" href="_" as="image" fetchpriority="high"><link rel="preload" href="Z" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="1" as="image" fetchpriority="high"><link rel="preload" href="V" as="image" fetchpriority="high"><link rel="preload" href="T" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="B" as="image" fetchpriority="high"><link rel="preload" href="6" as="image" fetchpriority="high"><link rel="preload" href="S" as="image" fetchpriority="high"><link rel="preload" href="F" as="image" fetchpriority="high"><link rel="preload" href="Q" as="image" fetchpriority="high"><link rel="preload" href="." as="image" fetchpriority="high"><link rel="preload" href="p" as="image" fetchpriority="high"><link rel="preload" href="n" as="image" fetchpriority="high"><link rel="preload" href="g" as="image" fetchpriority="high"><meta name="keywords" content="C++"/><meta name="description" content="技术与美日新月异"/><link rel="canonical" href="http://cwlrin.github.io/c-cpp/cpp-base/C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"><title>C++ 运算符重载</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 运算符重载</h1><div class="meta"><span class="item" title="创建时间：2020-11-17 16:17:54"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2020-11-17T16:17:54+08:00">2020-11-17</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>57k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>52 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">七葉の喫茶ステラ</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYZ05QV1RmeEQxSGt3Ul94N2RQd0s4Qkg5eW9WWndYVndVQUJXZC1uWWprTnc_ZT1VTnB6SFQ.png" loading="eager" decoding="async" fetchpriority="high" alt="Nana7ha's Café Stella"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/" itemprop="item" rel="index" title="分类于C/C++"><span itemprop="name">C/C++<meta itemprop="position" content="0"/></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/c-cpp/cpp-basic/" itemprop="item" rel="index" title="分类于C++ 基础"><span itemprop="name">C++ 基础<meta itemprop="position" content="1"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://cwlrin.github.io/c-cpp/cpp-base/C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="樱小路七叶"/><meta itemprop="description" content=", 技术与美日新月异"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nana7ha's Café Stella"/></span><div class="body md" itemprop="articleBody"><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2>
<p>在 C++ 中，类的私有成员（包括私有数据成员和私有成员函数）只能被该类自己的成员函数以及友元函数 / 类访问。友元关系是一种特殊的访问权限，允许非成员函数或类访问另一个类的私有成员。</p>
<p>友元关系通过在类内部使用  <code>friend</code>  关键字声明建立。可以声明友元函数或友元类：</p>
<ol>
<li><strong>友元函数</strong>：可以是 <strong>普通函数</strong>，也可以是 <strong>成员函数</strong>，它们可以访问声明它们为友元的类的私有成员。</li>
<li><strong>友元类</strong>：整个类的所有成员函数都能访问声明它们为友元的类的私有成员。</li>
</ol>
<p>友元的三种形式：<strong>普通函数、成员函数、友元类</strong></p>
<h3 id="普通函数形式"><a class="anchor" href="#普通函数形式">#</a> 普通函数形式</h3>
<p>程序中有  <code>Point</code>  类，需要求取两个点的距离。按照设想，我们定义一个普通函数  <code>distance</code> ，接收两个  <code>Point</code>  对象作为参数，通过公式计算这两个点之间的距离。但  <code>Point</code>  的  <code>_ix</code>  和  <code>_iy</code>  是私有成员，在类外不能通过对象访问。</p>
<p>可以将  <code>distance</code>  函数声明为友元，允许它访问类的私有成员。这样， <code>distance</code>  函数可以直接读取两个  <code>Point</code>  对象的坐标数据，并计算它们之间的距离。</p>
<p>以下是完整的示例代码，包括  <code>Point</code>  类和友元函数  <code>distance</code> ：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span>  <span class="token comment">// 包含 sqrt 函数</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// 声明友元函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// 友元的第一种形式</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 普通函数声明为一个类的友元函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 那么在这个函数中可以访问类的私有成员</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 计算两点之间的距离</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 建立一个观念</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 如果函数的参数为对象</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// 形参首先想到 const 引用的形式</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">float</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">float</span> dist <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Distance: "</span> <span class="token operator">&lt;&lt;</span> dist <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="成员函数形式"><a class="anchor" href="#成员函数形式">#</a> 成员函数形式</h3>
<p>要让一个类的成员函数访问另一个类的私有成员，可以在第二个类中声明第一个类的成员函数为友元。这需要在第二个类的类定义中进行友元声明，并确保声明的友元函数与定义的函数完全匹配。</p>
<p>如果  <code>distance</code>  函数不再是一个普通函数，而是  <code>Line</code>  类的一个成员函数，也就是说需要在一个类（ <code>Line</code> ）的成员函数中访问另一个类（ <code>Point</code> ）的私有成员，那么又该如何实现呢？</p>
<ul>
<li>
<p>如果将  <code>Point</code>  类定义在  <code>Line</code>  类之前， <code>Line</code>  类的成员函数要访问  <code>Point</code>  类的私有成员，需要在  <code>Point</code>  类中将  <code>Line</code>  的这个成员函数设为友元函数 —— 此时编译器并不认识  <code>Line</code>  类；</p>
</li>
<li>
<p>如果将  <code>Line</code>  类定义在  <code>Point</code>  类之前，那么  <code>distance</code>  函数需要接受两个  <code>const Point &amp;</code>  作为参数 —— 此时编译器不认识  <code>Point</code>  类；</p>
</li>
</ul>
<p>解决方法：在  <code>Line</code>  前面做一个  <code>Point</code>  类的前向声明；</p>
<p>但如果将  <code>distance</code>  的函数体写在  <code>Line</code>  类中，编译器虽然知道了有一个  <code>Point</code>  类，但并不知道  <code>Point</code>  类具体有什么成员，所以此时在函数体中访问  <code>_ix</code> 、  <code>_iy</code>  都会报错，编译器并不认识它们。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 前向声明</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">float</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">+</span>   <span class="token comment">//error，有问题，不知道 Point 的具体实现</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>前向声明的用处：进行了前向声明的类，可以以引用或指针的形式作为函数的参数，只要不涉及到对该类对象具体成员的访问，编译器可以通过。</p>
<p>（让编译器认识这个类，但是注意如果只进行前向声明，这个类的具体实现没有的话，无法使用这个类的对象，无法创建）</p>
<p>以下是使用友元成员函数的示例：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span>  <span class="token comment">// 包含 sqrt 函数</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 前向声明</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">float</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// Line 类的成员函数定义</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">float</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_ix <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="25"></td><td><pre>              <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_iy <span class="token operator">-</span> rhs<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  Line line<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token keyword">float</span> dist <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Distance: "</span> <span class="token operator">&lt;&lt;</span> dist <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出</p>
<pre><code>Distance: 5
</code></pre>
<h3 id="友元类"><a class="anchor" href="#友元类">#</a> 友元类</h3>
<p>假设类  <code>Line</code>  中不止有一个  <code>distance</code>  成员函数，还有其他成员函数，它们都需要访问  <code>Point</code>  的私有成员，如果还像上面的方式一个一个设置友元，就比较繁琐了，可以直接将  <code>Line</code>  类设置为  <code>Point</code>  的友元类。在  <code>Point</code>  类中声明  <code>Line</code>  类是本类的友元类，那么  <code>Line</code>  类中的所有成员函数中都可以访问  <code>Point</code>  类的私有成员。</p>
<p>通过声明友元类，可以使得该友元类的所有成员函数都能访问声明类的私有和保护成员。这种方法在需要广泛访问私有成员时非常有用，尤其是在设计类库或框架时。</p>
<p>以下是使用友元类的示例：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// 声明友元类</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Line</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_p1</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_p2</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token comment">// 使用友元类权限访问 Point 的私有成员</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">float</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_p1<span class="token punctuation">.</span>_ix <span class="token operator">-</span> _p2<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>_p1<span class="token punctuation">.</span>_ix <span class="token operator">-</span> _p2<span class="token punctuation">.</span>_ix<span class="token punctuation">)</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token punctuation">(</span>_p1<span class="token punctuation">.</span>_iy <span class="token operator">-</span> _p2<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>_p1<span class="token punctuation">.</span>_iy <span class="token operator">-</span> _p2<span class="token punctuation">.</span>_iy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  Point _p1<span class="token punctuation">,</span> _p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  Line <span class="token function">line</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Distance: "</span> <span class="token operator">&lt;&lt;</span> line<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>输出：</p>
<pre><code>Distance: 5
</code></pre>
<p>注意事项：</p>
<ul>
<li><strong>信息隐藏</strong>：虽然友元类可以访问私有成员，但这可能会破坏封装性和信息隐藏，因此应谨慎使用。</li>
<li><strong>设计权衡</strong>：在设计类时，需要权衡封装性和易用性，友元类提供了一种扩展类接口的灵活性，但同时也带来了风险。</li>
</ul>
<h3 id="友元的特点"><a class="anchor" href="#友元的特点">#</a> 友元的特点</h3>
<ol>
<li><strong>访问权限</strong>：友元函数或友元类可以访问声明它的类的所有成员，包括私有和保护成员。</li>
<li><strong>破坏封装性</strong>：通过允许外部函数或类访问私有成员，友元关系破坏了类的封装性。这是其设计的一部分，使得友元关系需要谨慎使用。</li>
<li><strong>使用限制</strong>：友元关系不是类型安全的，因为它允许违反正常的访问控制。</li>
<li><strong>单向性</strong>：声明友元关系是单向的。如果类 A 是类 B 的友元，并不意味着类 B 就是类 A 的友元，除非显式声明。</li>
<li><strong>非传递性</strong>：友元关系不具有传递性。即使类 A 是类 B 的友元，类 B 是类 C 的友元，也不能推断出类 A 是类 C 的友元。</li>
<li><strong>不继承友元</strong>：派生类不会继承基类的友元。每个类需要独立声明友元关系。</li>
</ol>
<h2 id="运算符重载"><a class="anchor" href="#运算符重载">#</a> 运算符重载</h2>
<h3 id="运算符重载的介绍"><a class="anchor" href="#运算符重载的介绍">#</a> 运算符重载的介绍</h3>
<p>在 C++ 中，预定义的运算符默认仅适用于基本的内置数据类型，如整数和浮点数。对于用户定义的类型，这些运算符并不直接适用。虽然可以通过定义特定的函数来模拟运算符的行为，但这种方法缺乏直观性和简洁性。C++ 提供了运算符重载（Operator Overloading）的特性，允许我们为自定义类型定义运算符的行为。</p>
<p>运算符重载的核心思想是，通过扩展运算符的功能，使得自定义类型在操作时能够与内置类型保持一致性。这样，我们就能够利用运算符的直观表达能力，以一种简洁易懂的方式定义自定义类型的行为。此外，运算符重载还有助于提高代码的可维护性和可复用性，因为它允许我们以一种更自然的方式处理自定义数据类型。</p>
<p>运算符重载可以定义自定义类型的运算符行为，从而使得这些类型在进行运算时表现得像内置类型一样。</p>
<p>能够重载的运算符有 42 个：</p>
<table>
<thead>
<tr>
<th><code> +</code></th>
<th><code> -</code></th>
<th><code> *</code></th>
<th><code> /</code></th>
<th><code> %</code></th>
<th><code> ^</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code> &amp;</code></td>
<td><code>|</code></td>
<td><code> ~</code></td>
<td><code> !</code></td>
<td><code> =</code></td>
<td><code> &lt;</code></td>
</tr>
<tr>
<td><code> &gt;</code></td>
<td><code> +=</code></td>
<td><code> -=</code></td>
<td><code> *=</code></td>
<td><code> /=</code></td>
<td><code> %=</code></td>
</tr>
<tr>
<td><code> ^=</code></td>
<td><code> &amp;=</code></td>
<td><code>|=</code></td>
<td><code> &gt;&gt;</code></td>
<td><code> &lt;&lt;</code></td>
<td><code> &gt;&gt;=</code></td>
</tr>
<tr>
<td><code> &lt;&lt;=</code></td>
<td><code> ==</code></td>
<td><code> !=</code></td>
<td><code> &gt; =</code></td>
<td><code> &lt;=</code></td>
<td><code> &amp;&amp;</code></td>
</tr>
<tr>
<td><code>||</code></td>
<td><code> ++</code></td>
<td><code> --</code></td>
<td><code> -&gt;*</code></td>
<td><code> -&gt;</code></td>
<td><code> ,</code></td>
</tr>
<tr>
<td><code> []</code></td>
<td><code> ()</code></td>
<td><code> new</code></td>
<td><code> delete</code></td>
<td><code> new []</code></td>
<td><code> delete []</code></td>
</tr>
</tbody>
</table>
<p>不能重载的运算符包括：</p>
<ul>
<li><code>.</code>  ：成员访问运算符。</li>
<li><code>.*</code> ：成员指针访问运算符。</li>
<li><code>?:</code> ：三目运算符。</li>
<li><code>::</code> ：作用域限定符。</li>
<li><code>sizeof</code> ：长度运算符。</li>
</ul>
<h3 id="运算符重载的规则"><a class="anchor" href="#运算符重载的规则">#</a> 运算符重载的规则</h3>
<p>在 C++ 中，运算符重载遵循以下规则：</p>
<ol>
<li><strong>自定义类型要求</strong>：运算符重载的操作数必须包含至少一个自定义类类型或枚举类型，不能全部为内置类型。</li>
<li><strong>优先级和结合性</strong>：运算符的优先级和结合性在重载后保持不变，例如在表达式  <code>a == b + c</code>  中，加法运算符的优先级高于等于运算符。</li>
<li><strong>操作数个数不变</strong>：运算符重载时，其操作数的个数应保持不变。</li>
<li><strong>默认参数限制</strong>：运算符重载时，不能设置默认参数，因为设置默认值实际上改变了操作数的个数。</li>
<li><strong>短路求值特性</strong>：对于逻辑与（ <code>&amp;&amp;</code> ）和逻辑或（ <code>||</code> ）运算符，重载后不再具备短路求值特性，必须在进入函数体之前完成所有参数的计算，因此不推荐重载这些运算符。</li>
<li><strong>不存在的运算符</strong>：不能创造一个不存在的运算符，如  <code>@</code> 、 <code>$</code> 、 <code>、</code> 。</li>
</ol>
<h3 id="运算符重载的形式"><a class="anchor" href="#运算符重载的形式">#</a> 运算符重载的形式</h3>
<p>运算符重载可以通过以下三种形式实现：</p>
<ol>
<li><strong>友元函数</strong>：通过定义友元函数来重载运算符，这样可以访问类的私有成员。</li>
<li><strong>普通函数</strong>：将运算符重载定义为一个普通的全局函数。</li>
<li><strong>成员函数</strong>：将运算符重载定义为类的成员函数，这样可以更自然地与类的行为集成。</li>
</ol>
<h3 id="运算符重载-2"><a class="anchor" href="#运算符重载-2">#</a>  <code>+</code>  运算符重载</h3>
<p>需求：实现一个复数类，复数分为实部和虚部，重载  <code>+</code>  运算符，使其能够处理两个复数之间的加法运算（实部加实部，虚部加虚部）</p>
<h4 id="友元函数实现"><a class="anchor" href="#友元函数实现">#</a> 友元函数实现</h4>
<p>我们可以定义一个普通函数  <code>add</code> ，它接收两个  <code>Complex</code>  对象作为参数，并返回它们的和。由于需要访问  <code>Complex</code>  类的私有成员，我们可以将这个函数声明为  <code>Complex</code>  类的友元。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span>  <span class="token comment">// 实部</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">double</span> _imag<span class="token punctuation">;</span>  <span class="token comment">// 虚部</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">imag</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">friend</span> Complex <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>Complex <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>real <span class="token operator">+</span> rhs<span class="token punctuation">.</span>real<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>imag <span class="token operator">+</span> rhs<span class="token punctuation">.</span>imag<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  Complex <span class="token function">cx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  Complex <span class="token function">cx2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  Complex cx3 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>cx<span class="token punctuation">,</span> cx2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为了使代码更直观和简洁，我们可以定义一个运算符重载函数  <code>operator+</code> ，这样可以直接使用  <code>+</code>  运算符来完成两个  <code>Complex</code>  对象的加法运算。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real<span class="token punctuation">,</span> <span class="token keyword">double</span> imag<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_imag</span><span class="token punctuation">(</span>imag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 运算符重载：友元函数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">friend</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token comment">// 打印函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> _real <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> _imag <span class="token operator">&lt;&lt;</span> <span class="token string">"i)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">double</span> _imag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 加法运算符重载</span></pre></td></tr><tr><td data-num="21"></td><td><pre>Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>_real <span class="token operator">+</span> rhs<span class="token punctuation">.</span>_real<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>_imag <span class="token operator">+</span> rhs<span class="token punctuation">.</span>_imag<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  Complex <span class="token function">cx1</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  Complex <span class="token function">cx2</span><span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  Complex cx3 <span class="token operator">=</span> cx1 <span class="token operator">+</span> cx2<span class="token punctuation">;</span>  <span class="token comment">// 使用重载的 + 运算符</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  cx3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出: (4, 6i)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>运算符重载的步骤</strong></p>
<ol>
<li><strong>确定返回类型</strong>：加法运算的返回值应该是一个临时的  <code>Complex</code>  对象，因此返回类型为  <code>Complex</code> 。</li>
<li><strong>定义函数名</strong>：使用  <code>operator+</code>  作为函数名。</li>
<li><strong>补充参数列表</strong>：加法运算有两个操作数，分别是两个  <code>Complex</code>  对象。由于加法操作不改变操作数的值，可以使用  <code>const</code>  引用作为形参。</li>
<li><strong>完成函数体</strong>：直接调用  <code>Complex</code>  构造函数创建一个新的对象作为返回值。</li>
</ol>
<p><strong>友元函数的优势</strong></p>
<p>对于不会修改操作数值的运算符（如加号），倾向于采用友元函数的方式重载，因为这样可以访问类的私有成员，同时保持操作数的不变性。</p>
<h4 id="普通函数实现"><a class="anchor" href="#普通函数实现">#</a> 普通函数实现</h4>
<p>如果需要在类外的普通函数中访问类的私有成员，可以提供公共的访问器（getter）函数。然而，这种方法通常会破坏封装性，因为它公开了类的内部细节。</p>
<p><strong>实际工作中不推荐使用，因为这样做几乎完全失去了对私有成员的保护。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real<span class="token punctuation">,</span> <span class="token keyword">double</span> image<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_image</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// Getter functions</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">double</span> <span class="token function">getReal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _real<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">double</span> <span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _image<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 友元声明，以便下面的运算符重载函数访问私有成员</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">friend</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">double</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 运算符重载函数</span></pre></td></tr><tr><td data-num="20"></td><td><pre>Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">getReal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">.</span><span class="token function">getReal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                 lhs<span class="token punctuation">.</span><span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rhs<span class="token punctuation">.</span><span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  Complex <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  Complex c3 <span class="token operator">=</span> c1 <span class="token operator">+</span> c2<span class="token punctuation">;</span> <span class="token comment">// 使用运算符重载进行加法</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c3: ("</span> <span class="token operator">&lt;&lt;</span> c3<span class="token punctuation">.</span><span class="token function">getReal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> c3<span class="token punctuation">.</span><span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"i)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="成员函数实现"><a class="anchor" href="#成员函数实现">#</a> 成员函数实现</h4>
<p>除了使用友元函数，运算符重载函数也可以定义为  <code>Complex</code>  类的成员函数。这种方式下，加法运算符的左操作数实际上是调用对象本身，因此在参数列表中只需要右操作数。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real<span class="token punctuation">,</span> <span class="token keyword">double</span> imag<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_image</span><span class="token punctuation">(</span>imag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 成员函数实现加法运算符重载</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// 会有一个默认的 this 指针作为第一个参数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>_real <span class="token operator">+</span> rhs<span class="token punctuation">.</span>_real<span class="token punctuation">,</span> _image <span class="token operator">+</span> rhs<span class="token punctuation">.</span>_image<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">double</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  Complex <span class="token function">cp1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  Complex <span class="token function">cp2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  Complex cp3 <span class="token operator">=</span> cp1 <span class="token operator">+</span> cp2<span class="token punctuation">;</span>  <span class="token comment">// 调用 cp1.operator+(cp2)</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cp3: ("</span> <span class="token operator">&lt;&lt;</span> cp3<span class="token punctuation">.</span>_real <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> cp3<span class="token punctuation">.</span>_image <span class="token operator">&lt;&lt;</span> <span class="token string">"i)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>虽然语法上允许在  <code>operator+</code>  中实现减法运算，但这与人们的直觉思维不符，可能会引起不必要的混乱。因此，除非有特别的理由，应尽量使重载的运算符与其内置的语义保持一致。</p>
<h3 id="运算符重载-3"><a class="anchor" href="#运算符重载-3">#</a>  <code>+=</code>  运算符重载</h3>
<ol>
<li><strong>确定重载方式</strong>：选择成员函数方式重载，因为  <code>+=</code>  运算符会修改左侧操作数的值。</li>
<li><strong>确定函数的返回值</strong>： <code>+=</code>  运算符重载函数应返回对当前对象的引用，以便支持链式操作。</li>
<li><strong>编写函数名</strong>：使用  <code>operator+=</code>  作为函数名。</li>
<li><strong>补充参数列表</strong>：需要一个参数，即右侧操作数，通常以  <code>const</code>  引用的形式传递。</li>
<li><strong>完成函数体</strong>：实现加法逻辑，并更新当前对象的状态。</li>
</ol>
<p>以下是  <code>Complex</code>  类的  <code>+=</code>  运算符重载实现：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real<span class="token punctuation">,</span> <span class="token keyword">double</span> imag<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_image</span><span class="token punctuation">(</span>imag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 加法运算符重载（成员函数）</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  Complex<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    _real <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>_real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    _image <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>_image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 返回当前对象的引用</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">double</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  Complex <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  Complex <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  c1 <span class="token operator">+=</span> c2<span class="token punctuation">;</span> <span class="token comment">// 使用 += 运算符</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c1 += c2: "</span> <span class="token operator">&lt;&lt;</span> c1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意事项：</p>
<ul>
<li><strong>返回引用</strong>： <code>+=</code>  运算符重载应返回对当前对象的引用，以支持链式操作。</li>
<li><strong>修改对象</strong>： <code>+=</code>  运算符重载会修改左侧操作数的状态。</li>
</ul>
<h3 id="重载形式的选择"><a class="anchor" href="#重载形式的选择">#</a> 重载形式的选择</h3>
<p><strong>运算符重载的选择</strong></p>
<p>在 C++ 中，运算符重载可以通过成员函数或友元函数实现。选择哪种形式取决于运算符的特性：</p>
<ol>
<li><strong>友元函数</strong>：适用于不会修改操作数的运算符。友元函数可以访问类的私有成员，适合需要读取但不需要修改操作数的场景。</li>
<li><strong>成员函数</strong>：适用于会修改操作数的运算符。成员函数可以直接访问和修改调用对象的状态，适合需要改变操作数值的场景。</li>
</ol>
<p><strong>特定运算符的重载形式</strong></p>
<ul>
<li><strong>赋值 ( <code>=</code> )</strong>、<strong>下标 ( <code>[]</code> )</strong>、<strong>调用 ( <code>()</code> )</strong>、<strong>成员访问 ( <code>-&gt;</code> )</strong>、<strong>成员指针访问 ( <code>-&gt;*</code> )</strong>：这些运算符必须通过成员函数形式重载，因为它们需要直接访问或修改对象的状态。</li>
<li><strong>递增 ( <code>++</code> )</strong>、<strong>递减 ( <code>--</code> )</strong>、<strong>解引用 ( <code>*</code> )</strong>：与给定类型密切相关的运算符，通常应该是成员函数形式重载，因为它们通常需要改变对象的状态。</li>
<li><strong>对称性运算符</strong>（如 <strong>相等性 ( <code>==</code> )</strong>、<strong>不等性 ( <code>!=</code> )</strong>、<strong>位运算符 ( <code>&lt;&lt;</code> )</strong>）：这些运算符可能需要转换任意一端的运算对象，通常应该是友元形式重载，以保持对称性和灵活性。</li>
</ul>
<h3 id="运算符重载-4"><a class="anchor" href="#运算符重载-4">#</a>  <code>++</code>  运算符重载</h3>
<p>自增运算符 ( <code>++</code> ) 有两种形式：前置和后置。它们在语义上有细微差别，前置版本直接返回增加后的值，而后置版本返回增加前的值。</p>
<p>前置  <code>++</code> ：</p>
<ul>
<li>返回增加后的引用。</li>
<li>常用于连续增加操作。</li>
</ul>
<p>后置  <code>++</code> ：</p>
<ul>
<li>返回增加前值的副本。</li>
<li>常用于单独的增加操作。</li>
</ul>
<p>前置形式和后置形式都是只有一个操作数（本对象），参数完全相同的情况下，只有返回类型不同不能构成重载。前置形式和后置形式的区分只能通过设计层面人为地加上区分。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real<span class="token punctuation">,</span> <span class="token keyword">double</span> imag<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_image</span><span class="token punctuation">(</span>imag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 前置自增运算符重载</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  Complex<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Prefix ++"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token operator">++</span>_real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token operator">++</span>_image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">// 后置自增运算符重载</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">// 参数列表中多加一个 int 表示后置 ++</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  Complex <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Postfix ++"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    Complex <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token operator">++</span>_real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token operator">++</span>_image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">double</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">double</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="运算符重载-5"><a class="anchor" href="#运算符重载-5">#</a>  <code>[]</code>  运算符重载</h3>
<p>需求：定义一个  <code>CharArray</code>  类，模拟  <code>char</code>  数组，需要通过下标访问运算符能够对对应下标位置字符进行访问。</p>
<ul>
<li>
<p>分析  <code>[ ]</code>  运算符重载函数的返回类型，因为通过下标取出字符后可能进行写操作，需要改变  <code>CharArray</code>  对象的内容，所以应该用  <code>char</code>  引用；</p>
</li>
<li>
<p><code>[ ]</code>  运算符的操作数有两个，一个是  <code>CharArray</code>  对象，一个是下标数据， <code>ch [0]</code>  的本质是  <code>ch.operator[](0)</code> ；</p>
</li>
</ul>
<p>函数体实现需要考虑下标访问越界情况，若未越界则返回对应下标位置的字符，若越界返回终止符。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CharArray</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">CharArray</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_capacity</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>pstr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>_capacity<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">strcpy</span><span class="token punctuation">(</span>_data<span class="token punctuation">,</span> pstr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token operator">~</span><span class="token function">CharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      _data <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token comment">// "hello" 来创建</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token comment">// capacity = 6</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token comment">// 下标只能取到 4</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> _capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">return</span> _data<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"out of range"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token keyword">static</span> <span class="token keyword">char</span> nullchar <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">return</span> nullchar<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> _data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  size_t _capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token keyword">char</span> <span class="token operator">*</span>_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>CharArray <span class="token function">ca</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>ca<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果要禁止  <code>CharArray</code>  对象通过下标访问修改字符数组中的元素，应该怎么办？</p>
<p>要禁止  <code>CharArray</code>  对象通过下标访问修改字符数组中的元素，可以将  <code>operator[]</code>  重载为返回一个对字符的常量引用（ <code>const char&amp;</code> ），而不是一个对字符的引用（ <code>char&amp;</code> ）。这样，当用户尝试通过下标访问来修改字符时，编译器将会报错，因为他们不能修改一个常量引用。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CharArray</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">CharArray</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_capacity</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>pstr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>_capacity<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">strcpy</span><span class="token punctuation">(</span>_data<span class="token punctuation">,</span> pstr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token operator">~</span><span class="token function">CharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">// 返回常量引用</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t idx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> _capacity <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token keyword">return</span> _data<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Out of range"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> nullchar <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token keyword">return</span> nullchar<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> _data <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  size_t _capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">char</span> <span class="token operator">*</span>_data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  CharArray <span class="token function">ca</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ca[0]: "</span> <span class="token operator">&lt;&lt;</span> ca<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出字符 'h'</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token comment">//ca [0] = 'x'; // 这将导致编译错误，因为我们不能修改常量引用</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="输入输出流运算符重载"><a class="anchor" href="#输入输出流运算符重载">#</a> 输入输出流运算符重载</h3>
<h4 id="输出流运算符重载"><a class="anchor" href="#输出流运算符重载">#</a> 输出流运算符重载</h4>
<p>在之前的例子中，我们如果想打印一个对象时，常用的方法是通过定义一个  <code>print</code>  成员函数来完成，但使用起来不太方便。我们希望打印一个对象，与打印一个整型数据在形式上没有差别 (如下例子)，那就必须要重载  <code>&lt;&lt;</code>  运算符。</p>
<p><strong>需求：</strong></p>
<p>我们希望  <code>Complex</code>  类型的对象能够像内置类型一样，使用输出流运算符  <code>&lt;&lt;</code>  进行输出。</p>
<p><strong>分析：</strong></p>
<ul>
<li>输出流运算符  <code>&lt;&lt;</code>  通常有两个操作数：左侧是输出流对象，右侧是我们想要输出的对象。如果我们将  <code>&lt;&lt;</code>  运算符定义为  <code>Complex</code>  类的成员函数，那么  <code>Complex</code>  对象将作为左操作数，这与内置类型的使用方式不符。因此选择使用友元函数来重载  <code>&lt;&lt;</code>  运算符。</li>
<li>当我们使用  <code>cout &lt;&lt; cx</code>  时，我们期望表达式的结果是  <code>cout</code>  对象本身，以便可以链式调用其他输出操作。由于  <code>cout</code>  是一个全局对象，我们不能返回它的副本，因此重载函数的返回类型应为  <code>ostream &amp;</code> 。</li>
<li>在参数列表中，第一个参数是输出流对象（例如  <code>cout</code> ），我们应明确其类型和参数名；第二个参数是  <code>Complex</code>  对象，由于我们不会修改它，所以使用  <code>const</code>  引用。</li>
<li>在函数体内，我们将  <code>Complex</code>  对象的信息输出到输出流  <code>os</code> ，并且不添加  <code>endl</code> ，以避免不必要的换行。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">//...</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> _x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">int</span> _y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_x <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_y <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">return</span> os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  Point <span class="token function">pt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> pt <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token comment">// 本质形式： operator &lt;&lt; (cout, pt) &lt;&lt; endl;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为了和内置类型的使用方式保持一致，输出流运算符重载采用友元形式。</p>
<p>如果采用成员形式进行运算符重载，那么自定义类型对象必然会作为第一个参数。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>c1 <span class="token operator">&lt;&lt;</span> cout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>c1<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="输入流运算符重载"><a class="anchor" href="#输入流运算符重载">#</a> 输入流运算符重载</h4>
<p>需求：对于  <code>Complex</code>  对象，希望像内置类型数据一样，使用输入流运算符可以对其进行输入</p>
<p>以下是  <code>Complex</code>  类的输入流运算符重载实现，包括合法性检查的功能：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">//...</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">friend</span> istream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span> is<span class="token punctuation">,</span> Complex <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> _real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">int</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>istream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  is <span class="token operator">>></span> rhs<span class="token punctuation">.</span>_real<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  is <span class="token operator">>></span> rhs<span class="token punctuation">.</span>_image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">return</span> is<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果不想分开输出实部和虚部，也可以直接连续输入，空格符、换行符都能作为分隔符</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>istream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  is <span class="token operator">>></span> rhs<span class="token punctuation">.</span>_x <span class="token operator">>></span> rhs<span class="token punctuation">.</span>_y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> is<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>还有个问题需要考虑，使用输入流时需要判断是否是合法输入</p>
<p>可以封装一个函数判断接收到的是合法的  <code>int</code>  数据，在  <code>&gt;&gt;</code>  运算符重载函数中调用。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">inputInt</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入一个 int 型数据"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span>is <span class="token operator">>></span> number<span class="token punctuation">,</span> <span class="token operator">!</span>is<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"istream has broken"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      is<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      is<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>streamsize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入一个 int 型数据"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token comment">// 正常输入的情况 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Complex <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入实部："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token comment">/* is >> rhs._real; */</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token function">inputInt</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>_real<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入虚部："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token comment">/* is >> rhs._image; */</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token function">inputInt</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>_image<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">return</span> is<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h3>
<p><strong>成员访问运算符包括  <code>.</code>  和  <code>-&gt;</code> ，其中  <code>.</code>  运算符是不能重载的， <code>-&gt;</code>  运算符是可以重载的。</strong></p>
<p>箭头访问运算符  <code>-&gt;</code>  和解引用运算符  <code>*</code>  ，它们是指针操作最常用的两个运算符。</p>
<p>箭头运算符只能以成员函数的形式重载，其返回值必须是一个指针或者重载了箭头运算符的对象。</p>
<h4 id="两层结构下的使用"><a class="anchor" href="#两层结构下的使用">#</a> 两层结构下的使用</h4>
<p>例子：建立一个双层的结构， <code>MiddleLayer</code>  含有一个  <code>Data*</code>  型的数据成员</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token operator">~</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Data()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">int</span> _data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MiddleLayer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token function">MiddleLayer</span><span class="token punctuation">(</span>Data <span class="token operator">*</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token operator">:</span> <span class="token function">_pdata</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MiddleLayer(Data*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token operator">~</span><span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~MiddleLayer()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pdata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>      <span class="token keyword">delete</span> _pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>      _pdata <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  Data <span class="token operator">*</span>_pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>Data *</code>  原生指针的用法如下，需要关注堆空间资源的回收</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>Data <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果用这种方式创建  <code>MiddleLayer</code>  对象，我们发现不需要手动  <code>delet pdata</code> ，并没有发生内存泄露，反而手动  <code>delet pdata</code>  后会有  <code>double free</code>  的问题。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  Data <span class="token operator">*</span>pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> pdata<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  MiddleLayer <span class="token function">ml</span><span class="token punctuation">(</span>pdata<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">//ml 底层的指针接管堆上的 Data 对象后</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 可以完成自动回收</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">// 但是如果仍然手动 delete，会有 double free 问题</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">/* delete pdata; */</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为  <code>MiddleLayer</code>  对象实际上对堆上  <code>Data</code>  对象形成了接管。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VUSE5VWFhaNzdGR2dPSDRUTHhsb2JzQnZPZ0Z5S0tlbDZDU1M1LUw5Nkg1bGc_ZT15V2xWMHM.png" alt="image-20240704162631330.png" /></p>
<p>当然，也可以让  <code>Middlelayer</code>  对象自己管理一个  <code>Data</code>  对象。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Data <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>MiddleLayer <span class="token function">ml</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYdmRaNGl3dTdWTG1VVWtQRU5QQzg4Qm5TMENfLVYtb0NHczlPS2RTUTZzZmc_ZT1kUjR3b0Y.png" alt="image-20240704164759971.png" /></p>
<p>需求：希望实现一个这样的效果，创建  <code>MiddleLayer</code>  对象  <code>ml</code> ，让  <code>ml</code>  对象可以使用箭头运算符去调用  <code>Data</code>  类的成员函数  <code>getData</code></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>MiddleLayer <span class="token function">ml</span><span class="token punctuation">(</span><span class="token keyword">new</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> ml<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个需求很合理，因为  <code>MiddleLayer</code>  的数据成员只有一个  <code>Data*</code>  类型的指针</p>
<p>箭头运算符无法应对  <code>MiddleLayer</code>  对象，那么可以定义箭头运算符重载函数。</p>
<ul>
<li>首先不用考虑重载形式，箭头运算符必须以成员函数形式重载；</li>
<li>然后考虑返回类型，返回值需要使用箭头运算符调用 getData 函数，而原生的用法只有  <code>Data *</code>  才能这么用，所以返回值应该是一个  <code>Data*</code>  ，此时应该直接返回   <code> _pdata</code> ；</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Data<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> _pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>解引用运算符应该如何重载能够实现同样的效果呢？直接使用  <code>MiddleLayer</code>  对象模仿  <code>Data*</code>  指针去访问  <code>getData</code>  函数。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MiddleLayer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">MiddleLayer</span><span class="token punctuation">(</span>Data <span class="token operator">*</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_pdata</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MiddleLayer(Data*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token operator">~</span><span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~MiddleLayer()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pdata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">delete</span> _pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      _pdata <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  Data <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> _pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>  Data <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">*</span>_pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  Data <span class="token operator">*</span>_pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  Data <span class="token operator">*</span>pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> pdata<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>pdata<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token keyword">delete</span> pdata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token comment">// 规范使用</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  MiddleLayer <span class="token function">ml</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token comment">// 第一个箭头与 operator 连在一起作为函数名</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token comment">// 第二个箭头是编译器自动加上的箭头，</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token comment">// 表示原生的成员访问运算符</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token comment">//</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token comment">// 以往的运算符重载案例中，比如 cx1 += cx2;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token comment">// 本质是 cx1.operator+=(cx2);</span></pre></td></tr><tr><td data-num="42"></td><td><pre>  <span class="token comment">// ++cx1;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>  <span class="token comment">// 本质是 cx1.operator++()</span></pre></td></tr><tr><td data-num="44"></td><td><pre>  <span class="token comment">// 箭头运算符相比而言，比较特别</span></pre></td></tr><tr><td data-num="45"></td><td><pre>  <span class="token comment">/* cout &lt;&lt; (ml.operator->())->getData() &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="46"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> ml<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>  <span class="token comment">// 本质</span></pre></td></tr><tr><td data-num="50"></td><td><pre>  <span class="token comment">/* cout &lt;&lt; ml.operator*().getData() &lt;&lt; endl; */</span></pre></td></tr><tr><td data-num="51"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>ml<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>  <span class="token comment">// 智能指针的雏形</span></pre></td></tr><tr><td data-num="54"></td><td><pre>  <span class="token comment">// 利用局部对象的生命周期来管理堆空间资源</span></pre></td></tr><tr><td data-num="55"></td><td><pre>  <span class="token comment">//ml 不是一个指针，本质上是一个对象</span></pre></td></tr><tr><td data-num="56"></td><td><pre>  <span class="token comment">// 这个对象管理的堆空间可以借助析构函数进行自动回收</span></pre></td></tr><tr><td data-num="57"></td><td><pre>  <span class="token comment">// 有了相应的运算符重载函数的支持后</span></pre></td></tr><tr><td data-num="58"></td><td><pre>  <span class="token comment">// 这个对象可以像原生的指针一样使用</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VhUV9kdklPWnR0RHR1YWlacVV5ei1zQjgwZkx4TDk5bUtzWG9jdzV2X09oZmc_ZT01R2tlOUE.png" alt="undefined202403141137735.png" /></p>
<p>当我们完成了以上的需求后，还有一件 “神奇” 的事情，使用的语句中有  <code>new</code>  没有  <code>delete</code> ，但是检查发现并没有内存泄漏。</p>
<p>原因： <code>MiddleLayer</code>  类通过重载箭头运算符  <code>-&gt;</code>  和解引用运算符  <code>*</code> ，使得它的行为类似于指针，也可以像指针一样进行使用，但是这个对象在栈帧结束时会自动销毁，自动调用析构函数回收了它的数据成员所申请的堆空间。</p>
<p>实际上，这就是智能指针的雏形：其思想就是通过对象的生命周期来管理资源。</p>
<h4 id="三层结构下的使用"><a class="anchor" href="#三层结构下的使用">#</a> 三层结构下的使用</h4>
<p>如果结构再加一层，引入一个  <code>ThirdLayer</code>  类。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ThirdLayer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">ThirdLayer</span><span class="token punctuation">(</span>MiddleLayer <span class="token operator">*</span>pml<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_pml</span><span class="token punctuation">(</span>pml<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ThirdLayer(MiddleLayer*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token operator">~</span><span class="token function">ThirdLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ThirdLayer()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pml<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">delete</span> _pml<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      _pml <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  MiddleLayer <span class="token operator">*</span>_pml<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>创建  <code>ThirdLayer</code>  对象时注意避免这样的错误：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 错误的创建方式，让 tl 对象接管了栈上的 MiddleLayer 对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 在执行析构时会发生段错误</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Data <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>MiddleLayer <span class="token function">ml</span><span class="token punctuation">(</span>pl<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>ThirdLayer <span class="token function">tl</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ml<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VkUkFhcEJpdDBWS2tpSDZLNmdBM2RZQjdmY1ZyN2lXSkJyWml1NVBBTHQtSXc_ZT1LZzFUdHo.png" alt="image-20240612144423149.png" /></p>
<p>注意：应该让  <code>ThirdLayer</code>  底层的指针管理一个堆上的  <code>MiddleLayer</code>  对象。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZTDJPQ1g3Q0xaS3NWUFhPV2RGZVJNQnp1ZmdWT0Y1Z2dobEdId01MTzFkQ3c_ZT1qSE5NSzk.png" alt="image-20240704171204060.png" /></p>
<p>希望实现如下使用方式，思考一下应该如何对  <code>ThirdLayer</code>  进行对应的运算符重载</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>ThirdLayer <span class="token function">tl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token keyword">new</span> Data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> tl<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>tl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在  <code>ThirdLayer</code>  类中定义这两个成员函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 有 MiddleLayer 重载的 operator-> 函数作为铺垫</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 这里只需要返回 MiddleLayer 对象即可</span></pre></td></tr><tr><td data-num="3"></td><td><pre>MiddleLayer <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span>_pml<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 一步一步解引用</span></pre></td></tr><tr><td data-num="8"></td><td><pre>MiddleLayer <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span>_pml<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>箭头运算符的使用：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// MiddleLayer 中定义了 operator-> 作为铺垫</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 使得 MiddleLayer 对象能够直接使用 -> 去访问 Data 的成员</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token generic-function"><span class="token function">cout</span> <span class="token generic class-name"><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">-></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 第一个 operator-> 是 ThirdLayer 类的成员函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 执行完的返回值是一个 MiddleLayer 对象</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 由于 MiddleLayer 类中已经对 -> 运算符进行过重载</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 所以 MiddlerLayer 对象可以直接用 ->getData ()</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 第二个 operator-> 是 MiddleLayer 类的成员函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> tl<span class="token operator">-></span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>解引用运算符的使用：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ThirdLayer <span class="token function">tl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 一步一步解引用</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 前一个 operator* 是 ThirdLayer 的成员函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 后一个 operator* 是 MiddleLayer 的成员函数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> tl<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>tl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果解引用的使用也希望和箭头运算符一样，一步到位，又该如何实现？</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ThirdLayer <span class="token function">tl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token keyword">new</span> Data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>tl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>如下三种 return 的形式都可以实现：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Data <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>_pml<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 本质</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>_pml<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 需要友元的支持</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>_pml<span class="token punctuation">)</span><span class="token punctuation">.</span>_pdata<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 一步到位解引用</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> tl<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>tl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="内存分析"><a class="anchor" href="#内存分析">#</a> 内存分析</h4>
<p>三层的结构比较复杂，我们可以通过内存图的方式进行分析。</p>
<p><code>ThirdLayer</code>  对象的创建</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>ThirdLayer <span class="token function">tl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MiddleLayer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>实际上的内存结构如图：</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VRbGV2NUpkWEhaSnBJcTFRb0hqbk1RQko4N0lIOWZNN3dSTkx4Ulkxa3piYWc_ZT1kazF0NTE.png" alt="image-20240522174607616.png" /></p>
<p><strong>创建过程：</strong></p>
<ol>
<li>** 创建  <code>ThirdLayer</code>  对象：** 当创建一个  <code>ThirdLayer</code>  对象时，首先调用  <code>ThirdLayer</code>  的构造函数。</li>
<li>** 创建  <code>MiddleLayer</code>  对象：** 在  <code>ThirdLayer</code>  构造函数的参数初始化过程中，会创建一个  <code>MiddleLayer</code>  对象。</li>
<li>** 创建  <code>Data</code>  对象：** 在创建  <code>MiddleLayer</code>  对象的过程中，会创建一个  <code>Data</code>  对象。</li>
<li><strong>初始化指针数据成员：</strong>
<ul>
<li>首先， <code>Data</code>  对象被构造完成。</li>
<li>然后， <code>MiddleLayer</code>  的指针数据成员  <code>_pdata</code>  被初始化为指向新创建的  <code>Data</code>  对象。</li>
<li>最后， <code>ThirdLayer</code>  的指针数据成员  <code>_pml</code>  被初始化为指向新创建的  <code>MiddleLayer</code>  对象。</li>
</ul>
</li>
</ol>
<p><strong>销毁过程：</strong></p>
<ol>
<li><strong>销毁  <code>ThirdLayer</code>  对象</strong>：当  <code>ThirdLayer</code>  对象的生命周期结束时，首先调用  <code>ThirdLayer</code>  的析构函数。</li>
<li><strong>销毁  <code>MiddleLayer</code>  对象：</strong>
<ul>
<li>在  <code>ThirdLayer</code>  的析构函数中，会调用  <code>delete</code>  来释放  <code>MiddleLayer</code>  对象。</li>
<li>这将首先调用  <code>MiddleLayer</code>  的析构函数。</li>
</ul>
</li>
<li><strong>销毁  <code>Data</code>  对象：</strong>
<ul>
<li>在  <code>MiddleLayer</code>  的析构函数中，会调用  <code>delete</code>  来释放  <code>Data</code>  对象。</li>
<li>这将调用  <code>Data</code>  的析构函数。</li>
</ul>
</li>
</ol>
<h3 id="可调用实体"><a class="anchor" href="#可调用实体">#</a> 可调用实体</h3>
<p>当我们探讨 “调用” 这一术语时，首先映入脑海的是 <strong>普通函数</strong> 和 <strong>函数指针</strong>。随着对面向对象编程的深入了解，我们又发现了 <strong>成员函数</strong> 的存在。这些都可以被统称为 可调用实体。实际上，为了适应多样化的编程需求，C++ 还引入了其他类型的可调用实体，它们通常通过运算符的重载来实现。</p>
<p>普通函数的一个关键特性是它们不具备状态保持能力。一旦执行结束，其所在的函数栈空间就会被回收，导致无法保留执行过程中的状态信息。这限制了它们在需要状态持久化的场景中的应用。相比之下，类与对象的引入为我们提供了一种机制，使得状态信息得以在对象的生命周期内得以保持。只要对象不被销毁，其状态就能持续存在。</p>
<h2 id="函数对象"><a class="anchor" href="#函数对象">#</a> 函数对象</h2>
<p>首先，我们有一个类  <code>FunctionObject</code> ，我们希望这个类的对象能够像函数一样被调用。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">FunctionObject</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  FunctionObject fo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">fo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 让对象像函数一样被调用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码看起来有些奇怪，因为对象  <code>fo</code>  本身并不是一个函数。为了解决这个问题，我们需要重载函数调用运算符  <code>()</code> 。</p>
<p>函数调用运算符必须以成员函数的形式进行重载。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">FunctionObject</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FunctionObject operator()()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  FunctionObject fo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">fo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 现在可以正常调用</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在定义  <code>operator()</code>  时，第一对小括号总是空的，表示我们正在定义的运算符名称，第二对小括号是函数参数列表，与普通函数的参数列表完全相同。</p>
<p>与其他运算符不同，函数调用运算符的参数可以根据需要来确定，并不固定。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">FunctionObject</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">// 第一个 () 与 operator 连在一起作为函数名</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 第二个 () 代表该函数的参数列表的括号</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FunctionObject operator()()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"operator()(int,int)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  FunctionObject fo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 调用无参版本</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 调用有参版本</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>重载了函数调用运算符的类的对象称为函数对象。由于参数列表可以随意扩展，所以可以有很多重载形式（对应了普通函数的多种重载形式）。</p>
<p>函数对象的优点：</p>
<ol>
<li><strong>携带状态</strong>：函数对象可以封装自己的数据成员和成员函数，具有更好的面向对象特性。</li>
<li><strong>记录调用次数</strong>：可以记录函数对象被调用的次数，而普通函数只能通过全局变量实现（全局变量不够安全）。</li>
</ol>
<p>函数对象是 STL（标准模板库）的六大组件之一，可以做很多定制化的行为。</p>
<h3 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h3>
<p>在 C++ 中，函数指针允许我们将函数当作对象来处理。定义函数指针时，需要明确指出指针指向的函数类型，包括返回类型和参数类型。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"display:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 省略形式</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> print<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    p <span class="token operator">=</span> display<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    </pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 完整形式</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>print<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>display<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    </pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中， <code>p</code>  和  <code>p2</code>  是函数指针，定义函数指针  <code>p</code>  后，可以指向  <code>print</code>  函数，也可以再指向 `display 函数，并通过函数指针调用函数。</p>
<p>我们可以将函数指针抽象为一个类，这个类的对象就是特定类型的函数指针。这样的抽象有助于我们更好地管理和使用函数指针。</p>
<p><code>p</code>  和  <code>p2</code>  可以抽象出一个函数指针类型  <code>void(*)(int)</code>  。</p>
<p>该类型为逻辑类型，不能在代码中直接以这种形式写出。</p>
<p>以前我们使用  <code>typedef</code>  可以定义类型别名，这段程序中函数指针  <code>p</code> 、 <code>p2</code>  的类型是  <code>void(*)(int)</code> ，但是 C++ 中是没有这个类的。</p>
<p>这里，我们使用  <code>typedef</code>  定义了一个新类型  <code>Function</code> ，它代表一个指向接受一个  <code>int</code>  参数并返回  <code>void</code>  的函数的指针。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>Function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用  <code>Function</code>  类型，我们可以更简洁地定义和使用函数指针。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"display:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"show:"</span> <span class="token operator">&lt;&lt;</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> INT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>Function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token comment">// 定义函数指针时，</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token comment">// 要确定这个指针所指向的函数的返回类型和参数信息</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token comment">// 简略形式</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  Function f</pre></td></tr><tr><td data-num="21"></td><td><pre>  f <span class="token operator">=</span> print<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  f <span class="token operator">=</span> display<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中， <code>f</code>  是一个  <code>Function</code>  类型的变量，它可以指向任何符合  <code>Function</code>  类型的函数。</p>
<h3 id="成员函数指针"><a class="anchor" href="#成员函数指针">#</a> 成员函数指针</h3>
<p>在 C++ 中，成员函数指针是指向类成员函数的指针。与普通函数指针相比，成员函数指针需要额外的信息，即它们所属的类。这是因为成员函数总是与某个对象关联的。</p>
<p>定义成员函数指针时，需要指定成员函数的返回类型、参数类型以及它所属的类。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">FFF</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FFF::print:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FFF::display:"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>定义一个函数指针要明确指针指向的函数的返回类型、参数类型，那么定义一个成员函数指针还需要确定的是这个成员函数是哪个类的成员函数（类的作用域）</p>
<p>与普通函数指针不一样的是，成员函数指针的定义和使用都需要使用完整写法，不能使用省略写法，定义时要完整写出指针声明，使用时要完整写出解引用（解出成员函数后接受参数进行调用）。</p>
<p>另外，成员函数需要通过对象来调用，成员函数指针也需要通过对象来调用。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义成员函数指针时需要确定其指向的成员函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 类的名称、返回类型、参数情况</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 指向成员函数和调用成员函数时，需要用完整形式</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token punctuation">(</span>FFF<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>FFF<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>FFF ff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>ff<span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通过对象调用成员函数指针</span></pre></td></tr></table></figure><p>这里， <code>p</code>  是一个指向  <code>FFF</code>  类成员函数的指针，它指向  <code>print</code>  函数。通过对象  <code>ff</code>  调用成员函数指针。</p>
<p>为了简化成员函数指针的使用，可以使用  <code>typedef</code>  来定义成员函数指针的类型。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>FFF<span class="token double-colon punctuation">::</span><span class="token operator">*</span>MemberFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 定义成员函数类型 MemberFunction</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>MemberFunction mf <span class="token operator">=</span> <span class="token operator">&amp;</span>FFF<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span>  <span class="token comment">// 定义成员函数指针</span></pre></td></tr><tr><td data-num="4"></td><td><pre>FFF fff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span>fff<span class="token punctuation">.</span><span class="token operator">*</span>mf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通过对象调用成员函数指针</span></pre></td></tr></table></figure><ul>
<li><code>.*</code> ：成员指针运算符的第一种形式，用于通过对象调用成员函数指针。</li>
<li><code>-&gt;</code> ：成员指针运算符的第二种形式，用于通过指针调用成员函数指针。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>FFF <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">FFF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>fp<span class="token operator">-></span><span class="token operator">*</span>mf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通过指针调用成员函数指针</span></pre></td></tr></table></figure><ol>
<li><strong>回调函数</strong>：可以将成员函数指针作为参数传递给其他函数，使其他函数能够在特定条件下调用该成员函数。</li>
<li><strong>事件处理</strong>：将成员函数指针存储在事件处理程序中，以便在特定事件发生时调用相应的成员函数。</li>
<li><strong>多态性</strong>：通过将成员函数指针存储在基类指针中，可以实现多态性，在运行时能够调用相应的成员函数。</li>
</ol>
<h3 id="空指针的使用"><a class="anchor" href="#空指针的使用">#</a> 空指针的使用</h3>
<p>示例代码</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bar::test0()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bar::test1(): "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bar::test2(): "</span> <span class="token operator">&lt;&lt;</span> _data <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> _data <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    Bar <span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    fp<span class="token operator">-></span><span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以调用</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    fp<span class="token operator">-></span><span class="token function">test1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以调用</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    fp<span class="token operator">-></span><span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个类  <code>Bar</code> ，它有三个成员函数： <code>test0()</code> 、 <code>test1(int x)</code>  和  <code>test2()</code> 。然后，我们创建了一个空指针  <code>fp</code> ，并尝试调用这些成员函数。</p>
<ul>
<li><code>fp-&gt;test0();</code>  可以成功调用，因为  <code>test0()</code>  不访问任何数据成员。</li>
<li><code>fp-&gt;test1(3);</code>  也可以成功调用，因为它同样不访问任何数据成员。</li>
<li><code>fp-&gt;test2();</code>  会导致错误，因为它试图访问数据成员  <code>_data</code> 。</li>
</ul>
<p>在 C++ 中，非虚成员函数可以在没有对象上下文的情况下调用。这意味着即使指针是空的，编译器也能正确地调用这些函数。但是，如果成员函数试图访问对象的数据成员，就会出错，因为空指针没有指向有效的对象。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VmTUFjVHZHSUtsSmhGT3lLdndaRkZJQml3OWMydVA5VU8yenVxR3BTSktZQWc_ZT1ISFZ2ZHY.png" alt="image-20231128173635460.png" /></p>
<p>在 C++ 中，我们可以将以下实体视为可调用实体：</p>
<ul>
<li><strong>普通函数</strong></li>
<li><strong>函数指针</strong></li>
<li><strong>成员函数</strong></li>
<li><strong>成员函数指针</strong></li>
<li><strong>函数对象</strong></li>
</ul>
<p>这些可调用实体提供了多种调用函数的方式，但使用时需要注意它们的上下文依赖性。特别是在使用空指针调用成员函数时，要确保成员函数不会访问对象的数据成员，以避免未定义的行为。</p>
<p>虽然技术上可以使用空指针调用非虚成员函数，但这并不是一个好的编程习惯。在实际编程中，应该避免这样做，以确保代码的安全性和可读性。</p>
<h2 id="类型转换函数"><a class="anchor" href="#类型转换函数">#</a> 类型转换函数</h2>
<p>在 C++ 中，类型转换是一个强大的特性，允许我们在不同的类型之间进行转换。这包括从基本数据类型转换到自定义类型，以及从自定义类型转换到其他类型。让我们详细探讨这两种转换方式。</p>
<h3 id="由其他类型向自定义类型转换"><a class="anchor" href="#由其他类型向自定义类型转换">#</a> 由其他类型向自定义类型转换</h3>
<p>这种转换通常由类的构造函数实现。如果类中定义了合适的构造函数，编译器可以自动将其他类型的值转换为自定义类型的对象。这种转换一般称为 <strong>隐式转换</strong>。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">,</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _ix <span class="token operator">=</span> _iy <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>Point pt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 隐式转换</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 等价于 Point pt = Point (1);</span></pre></td></tr></table></figure><p>在这个例子中， <code>Point</code>  类有一个接受单个  <code>int</code>  参数的构造函数。编译器使用这个构造函数将  <code>int</code>  类型的值  <code>1</code>  转换为  <code>Point</code>  类型的对象。</p>
<p><strong>防止隐式转换：</strong></p>
<p>为了防止不希望的隐式转换，可以在构造函数前加上  <code>explicit</code>  关键字。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">explicit</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _ix <span class="token operator">=</span> _iy <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="由自定义类型向其他类型转换"><a class="anchor" href="#由自定义类型向其他类型转换">#</a> 由自定义类型向其他类型转换</h3>
<p>这种转换可以通过类型转换函数实现。类型转换函数是一种特殊的成员函数，其形式固定，没有返回类型和参数，且必须返回目标类型的值。</p>
<p><strong>类型转换函数的特征：</strong></p>
<ol>
<li>必须是成员函数。</li>
<li>没有返回类型。</li>
<li>没有参数。</li>
<li>必须返回目标类型的值。</li>
</ol>
<h4 id="自定义类型向内置类型转换"><a class="anchor" href="#自定义类型向内置类型转换">#</a> 自定义类型向内置类型转换</h4>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">,</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"operator int()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> _ix <span class="token operator">+</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>Point <span class="token function">pt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> pt<span class="token punctuation">;</span>  <span class="token comment">// 自定义类型向内置类型转换</span></pre></td></tr><tr><td data-num="14"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>Point</code>  类定义了一个类型转换函数  <code>operator int()</code> ，允许将  <code>Point</code>  类型的对象转换为  <code>int</code>  类型的值。</p>
<h4 id="自定义类型之间的转换"><a class="anchor" href="#自定义类型之间的转换">#</a> 自定义类型之间的转换</h4>
<p>自定义类型不仅可以转换为内置类型，还可以转换为其他自定义类型。关键在于将类型转换函数定义在哪个类中。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">double</span> _real<span class="token punctuation">,</span> _image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_image</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">operator</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"operator Point()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_image<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>Point pt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>Complex <span class="token function">cx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>pt <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment">// 自定义类型向自定义类型转换</span></pre></td></tr></table></figure><p>在这个例子中， <code>Complex</code>  类定义了一个类型转换函数  <code>operator Point()</code> ，允许将  <code>Complex</code>  类型的对象转换为  <code>Point</code>  类型的对象。</p>
<h4 id="转换的优先级"><a class="anchor" href="#转换的优先级">#</a> 转换的优先级</h4>
<ol>
<li><strong>赋值运算符函数</strong>：如果存在，将优先使用。</li>
<li><strong>类型转换函数</strong>：如果没有赋值运算符函数，将使用类型转换函数。</li>
<li><strong>隐式转换（特殊的构造函数）</strong>：如果前两者都不存在，将使用隐式转换。</li>
</ol>
<p><strong>优先级：</strong> 赋值运算符函数 &gt; 类型转换函数 &gt; 隐式转换</p>
<p>用一个  <code>Complex</code>  对象给  <code>Point</code>  对象赋值</p>
<p>编译器会先到 Point 类中找有没有合适的赋值运算符函数（ <code>Point&amp; operator =(const Complex &amp; rhs)</code> ），如果有的话，编译器就知道了怎样去进行赋值操作，不需要任何的转换；如果没有，编译器再到  <code>Complex</code>  类中找有没有合适的类型转换函数（ <code>operator Point()</code> ），如果有的话，就可以让  <code>cx</code>  对象调用类型转换函数，返回一个临时的  <code>Point</code>  对象，然后再用这个临时的  <code>Point</code>  对象给  <code>pt</code>  赋值。</p>
<p>如果前两种方式都行不通，编译器再会到  <code>Point</code>  类中找有没有合适的构造函数，可以利用一个  <code>Complex</code>  对象创建出一个  <code>Point</code>  对象（隐式转换的途径）。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>cx<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 优先级 1：特殊的赋值运算符函数（运算符重载的思路）</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cx <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 优先级 2：类型转换函数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cx <span class="token operator">=</span> <span class="token function">Complex</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 优先级 3 ：特殊构造函数（隐式转换的思路）</span></pre></td></tr></table></figure><h2 id="c-运算符优先级排序与结合性"><a class="anchor" href="#c-运算符优先级排序与结合性">#</a> C++ 运算符优先级排序与结合性</h2>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>描述</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>::</code></td>
<td>作用域解析</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>1</td>
<td><code>a++, a--</code></td>
<td>后缀自增与自减</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>1</td>
<td><code>type(), type&#123;&#125;</code></td>
<td>函数风格转换</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>2</td>
<td><code>a()</code></td>
<td>函数调用</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>2</td>
<td><code>a[]</code></td>
<td>下标</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>2</td>
<td><code>.-&gt;</code></td>
<td>成员访问</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>2</td>
<td><code>++a, --a</code></td>
<td>前缀自增与自减</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>2</td>
<td><code>+a, -a</code></td>
<td>一元加与减</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>2</td>
<td><code>!, -</code></td>
<td>逻辑非和逐位非</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>2</td>
<td><code>(type)</code></td>
<td>C 风格转换</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>2</td>
<td><code>*a</code></td>
<td>间接 (解引用)</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>3</td>
<td><code>&amp;a</code></td>
<td>取址</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>3</td>
<td><code>sizeof</code></td>
<td>取大小</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>3</td>
<td><code>co_await</code></td>
<td>await 表达式 (C++20)</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>3</td>
<td><code>new, new[]</code></td>
<td>动态内存分配</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>3</td>
<td><code>delete, delete[]</code></td>
<td>动态内存释放</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>4</td>
<td><code>.* ,-&gt;*</code></td>
<td>成员指针</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>5</td>
<td><code>a*b, a/b, a%b</code></td>
<td>乘法、除法与余数</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>6</td>
<td><code>a+ba-b</code></td>
<td>加法与减法</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>7</td>
<td><code>&lt;&lt;, &gt;&gt;</code></td>
<td>逐位左移与右移</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>8</td>
<td><code>&lt;=&gt;</code></td>
<td>三路比较运算符 (C++20 起)</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>9</td>
<td><code>&lt;, &lt;=, &gt;, &gt;=</code></td>
<td>分别为 &lt;与≤与&gt; 与 ≥ 的关系运算符</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>10</td>
<td><code>==, !=</code></td>
<td>分别为 = 与 ≠ 的相等性运算符</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>11</td>
<td><code>a&amp;b</code></td>
<td>逐位与</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>12</td>
<td><code>^</code></td>
<td>逐位异或 (互斥或)</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>13</td>
<td><code>|</code></td>
<td>逐位或 (可兼或)</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>14</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>15</td>
<td><code>||</code></td>
<td>逻辑或</td>
<td>从左到右 →</td>
</tr>
<tr>
<td>16</td>
<td><code>a?b:c</code></td>
<td>三元条件</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>throw</code></td>
<td>throw 运算符</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>co_yield</code></td>
<td>yield 表达式 (C++20)</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>=</code></td>
<td>直接赋值 (C++ 类默认提供)</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>+=, -=</code></td>
<td>以和及差复合赋值</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>*=, /=, %=</code></td>
<td>以积、商及余数复合赋值</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>&lt;&lt;=, &gt;&gt;=</code></td>
<td>以逐位左移及右移复合赋值</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>16</td>
<td><code>&amp;=, ^= ,|=</code></td>
<td>以逐位与、异或及或复合赋值</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>17</td>
<td><code>,</code></td>
<td>逗号</td>
<td>从左到右 →</td>
</tr>
</tbody>
</table>
<h2 id="嵌套类"><a class="anchor" href="#嵌套类">#</a> 嵌套类</h2>
<h3 id="嵌套类的定义"><a class="anchor" href="#嵌套类的定义">#</a> 嵌套类的定义</h3>
<p>在 C++ 中，类提供了两种作用域：类作用域和类名作用域，它们在访问控制和成员访问方面起着关键作用。</p>
<p><strong>类作用域</strong> 是指类定义内部的范围。在这个作用域内定义的所有成员（包括变量、函数、类型别名等）都可以被类的所有成员函数访问。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 类的成员函数内访问 _b</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">int</span> _b<span class="token punctuation">;</span>  <span class="token comment">// 类作用域内的成员变量</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>_b</code>  是类作用域内的成员变量，可以在类的所有成员函数中访问。</p>
<p><strong>类名作用域</strong> 是指可以通过类名访问的作用域。这主要用于访问类的静态成员和嵌套类型。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">int</span> _a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> _b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> MyClass<span class="token double-colon punctuation">::</span>_a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 类名作用域内的静态成员</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  MyClass<span class="token double-colon punctuation">::</span>_a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  <span class="token comment">// 类外部访问 _a</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中， <code>_a</code>  是一个静态成员，可以通过类名来访问。</p>
<p>在函数和其他类定义的外部定义的类称为 <strong>全局类</strong>，绝大多数的 C++ 类都是全局类。我们在前面定义的所有类都在全局作用域中，全局类具有全局作用域。</p>
<p>与之对应的，一个类 A 还可以定义在另一类 B 的定义中，这就是 <strong>嵌套类</strong> 结构。A 类被称为 B 类的 <strong>内部类</strong>，B 类被称为 A 类的 <strong>外部类</strong>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 嵌套类</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_pt1</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pt2</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>    Point _pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    Point _pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>Point</code>  是  <code>Line</code>  类的内部类。</p>
<p>嵌套类无法在外部类的作用域外直接创建对象，需要在外部类的类名作用域内才能创建。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>Point <span class="token function">pt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 错误</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Line<span class="token double-colon punctuation">::</span>Point <span class="token function">pt2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确</span></pre></td></tr></table></figure><p>嵌套类并不会影响外部类的存储结构。只有当外部类包含内部类的对象成员时，外部类对象的内存布局中才会包含内部类对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_pt1</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pt2</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  Point _pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  Point _pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">double</span> length <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>如果  <code>Line</code>  类中没有  <code>Point</code>  类的对象成员， <code>sizeof(Line) = 8</code></li>
<li>如果  <code>Line</code>  类中有两个  <code>Point</code>  类的对象成员， <code>sizeof(Line) = 24</code></li>
</ul>
<p>如果要使用输出流运算符输出  <code>Line</code>  对象，需要为  <code>Point</code>  类定义输出流运算符重载函数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* public: */</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point(int,int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">friend</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_pt1</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pt2</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Line(int*4)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">friend</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Line<span class="token double-colon punctuation">::</span>Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">friend</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Line <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  Point _pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  Point _pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// 为了用输出流运算符输出 Point 对象</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// 其中访问了 Point 的私有数据成员 (_ix, _iy)</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// 所以要设为 Point 的友元</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// 而且在形参中不能直接使用 Point 类型名称，需要加上 Line 的类名作用域</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// 如果 Point 是 Line 中的私有成员类型</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// 还需要将这个函数声明为 Line 的友元</span></pre></td></tr><tr><td data-num="37"></td><td><pre>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Line<span class="token double-colon punctuation">::</span>Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_ix <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_iy <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token keyword">return</span> os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token comment">// 为了用输出流运算符输出 Line 对象</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment">// 其中访问了 Line 的私有数据成员 (_ptl, _pt2)</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token comment">// 所以要设为 Line 的友元</span></pre></td></tr><tr><td data-num="45"></td><td><pre>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Line <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>  os <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_pt1 <span class="token operator">&lt;&lt;</span> <span class="token string">"------>"</span> <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>  <span class="token keyword">return</span> os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，我们为  <code>Point</code>  类定义了输出流运算符重载函数，并将其声明为  <code>Line</code>  类的友元函数，以便在  <code>Line</code>  类的外部定义。同时，我们也为  <code>Line</code>  类定义了输出流运算符重载函数。</p>
<h3 id="嵌套类结构的访问权限"><a class="anchor" href="#嵌套类结构的访问权限">#</a> 嵌套类结构的访问权限</h3>
<p>在 C++ 中，嵌套类（内部类）与外部类（定义内部类的类）之间可以有紧密的联系，包括相互访问对方的成员。</p>
<h4 id="外部类对内部类的成员进行访问"><a class="anchor" href="#外部类对内部类的成员进行访问">#</a> 外部类对内部类的成员进行访问</h4>
<p>外部类可以直接访问内部类的公有成员，不需要任何特殊的声明。这是因为内部类定义在外部类的范围内，所以外部类对内部类有完全的访问权限。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> innerValue <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">accessInner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    Inner inner<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> inner<span class="token punctuation">.</span>innerValue <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 直接访问内部类的成员</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中， <code>Outer</code>  类可以直接访问其内部类  <code>Inner</code>  的成员  <code>innerValue</code> 。</p>
<h4 id="内部类对外部类的成员进行访问"><a class="anchor" href="#内部类对外部类的成员进行访问">#</a> 内部类对外部类的成员进行访问</h4>
<p>内部类可以访问定义它的外部类的成员，就像它们是外部类的友元一样。这包括私有成员，因为内部类是定义在外部类作用域内的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> outerValue <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">accessOuter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> outerValue <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 访问外部类的私有成员</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">accessInner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    Inner inner<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    inner<span class="token punctuation">.</span><span class="token function">accessOuter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 内部类访问外部类的私有成员</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这个例子中，内部类  <code>Inner</code>  可以直接访问外部类  <code>Outer</code>  的私有成员  <code>outerValue</code> 。</p>
<h4 id="内部类相当于外部类的友元类"><a class="anchor" href="#内部类相当于外部类的友元类">#</a> 内部类相当于外部类的友元类</h4>
<p>由于内部类可以访问外部类的私有成员，这相当于内部类是外部类的友元类。这种关系使得内部类可以为外部类提供额外的灵活性和封装性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">performAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token comment">// 可以访问外部类的公有、保护、私有成员</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      outerObject<span class="token punctuation">.</span><span class="token function">performPrivateAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">performPrivateAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Performing private action."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  Outer outerObject<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  Outer<span class="token double-colon punctuation">::</span>Inner innerObject <span class="token operator">=</span> outerObject<span class="token punctuation">.</span><span class="token function">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  innerObject<span class="token punctuation">.</span><span class="token function">performAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 内部类访问外部类的私有成员函数</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中，内部类  <code>Inner</code>  可以访问外部类  <code>Outer</code>  的私有成员函数  <code>performPrivateAction</code> 。</p>
<p>总结：</p>
<ul>
<li><strong>外部类对内部类的访问</strong>：外部类可以直接访问内部类的公有成员。</li>
<li><strong>内部类对外部类的访问</strong>：内部类可以访问外部类的公有、保护和私有成员，就像它们是外部类的友元一样。</li>
<li><strong>内部类与外部类的关系</strong>：内部类在定义它的外部类的作用域内，因此它们之间可以有紧密的联系和相互访问。</li>
</ul>
<table>
<thead>
<tr>
<th>访问成员方式</th>
<th>不依赖对象直接访问</th>
<th>类名作用域访问</th>
<th>通过对象直接访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部类对内部类</td>
<td>无</td>
<td>内部类的静态成员 + 声明友元才 ok</td>
<td>内部类的私有成员，需要声明友元</td>
</tr>
<tr>
<td>内部类对外部类</td>
<td>外部类的静态成员</td>
<td>外部类的静态成员</td>
<td>即使是私有成员也 ok</td>
</tr>
</tbody>
</table>
<h3 id="pimpl-模式"><a class="anchor" href="#pimpl-模式">#</a> pimpl 模式</h3>
<p>Pimpl（Pointer to Implementation）模式，也被称为编译防火墙，是一种在 C++ 中常用的设计技巧，用于隐藏类的实现细节。这种模式通过将类的具体实现移到另一个私有类中来实现，从而使得类的实现文件与头文件分离，有助于减少编译依赖和编译时间。</p>
<h4 id="pimpl-模式的实现步骤"><a class="anchor" href="#pimpl-模式的实现步骤">#</a> Pimpl 模式的实现步骤</h4>
<ol>
<li><strong>头文件（接口）</strong>：
<ul>
<li>只声明对外的接口。</li>
<li>使用一个指向实现类的指针来管理资源。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p Line.hpp</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token operator">~</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">printLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 打印 Line 对象的信息</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">LineImpl</span><span class="token punctuation">;</span> <span class="token comment">// 类的前向声明</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  LineImpl <span class="token operator">*</span> _pimpl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2">
<li><strong>实现文件（具体实现）</strong>：
<ul>
<li>定义嵌套的实现类。 <code>LineImpl</code>  是  <code>Line</code>  的内部类， <code>Point</code>  是  <code>LineImpl</code>  的内部类</li>
<li>实现所有成员函数。 <code>Line</code>  类对外公布的接口都是使用  <code>LineImpl</code>  进行具体实现的。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p LineImpl.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Line.hpp"</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Line</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">LineImpl</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>  Point _pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  Point _pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token function">LineImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token operator">:</span> <span class="token function">_pt1</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pt2</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> y1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">,</span> <span class="token keyword">int</span> y2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  _pimpl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LineImpl</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Line</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">delete</span> _pimpl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">printLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Line from ("</span> <span class="token operator">&lt;&lt;</span> _pimpl<span class="token operator">-></span>_pt1<span class="token punctuation">.</span>_ix <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> _pimpl<span class="token operator">-></span>_pt1<span class="token punctuation">.</span>_iy </pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token operator">&lt;&lt;</span> <span class="token string">") to ("</span> <span class="token operator">&lt;&lt;</span> _pimpl<span class="token operator">-></span>_pt2<span class="token punctuation">.</span>_ix <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> _pimpl<span class="token operator">-></span>_pt2<span class="token punctuation">.</span>_iy <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> Line<span class="token double-colon punctuation">::</span>LineImpl<span class="token double-colon punctuation">::</span>Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>_ix <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>_iy <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token keyword">return</span> os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3">
<li><strong>测试文件</strong>：使用对外提供的接口。在测试文件中创建  <code>Line</code>  对象（最外层），使用  <code>Line</code>  对外提供的接口，但是不知道具体的实现</li>
</ol>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p Line.cc</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Line.hpp"</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Line <span class="token function">line</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    line<span class="token punctuation">.</span><span class="token function">printLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4">
<li><strong>打包库文件</strong>：使用  <code>ar</code>  工具将对象文件打包成库文件。</li>
</ol>
<figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> build-essential</pre></td></tr><tr><td data-num="2"></td><td><pre>g++ <span class="token parameter variable">-c</span> LineImpl.cc <span class="token parameter variable">-o</span> LineImpl.o</pre></td></tr><tr><td data-num="3"></td><td><pre>ar rcs libLine.a LineImpl.o</pre></td></tr></table></figure><ol start="5">
<li><strong>编译测试文件</strong>：使用库文件进行编译。</li>
</ol>
<figure class="highlight bash"><figcaption data-lang="bash"><span>h</span></figcaption><table><tr><td data-num="1"></td><td><pre>g++ Line.cc -L. <span class="token parameter variable">-lLine</span> <span class="token parameter variable">-o</span> LineTest</pre></td></tr></table></figure><h4 id="pimpl-模式的好处"><a class="anchor" href="#pimpl-模式的好处">#</a> Pimpl 模式的好处</h4>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VlOXMtQ05YZHdOQ2h4WDE0aWd3bkZvQlBQNzAwLVI4a3p6Z0NUN2N0Sm9tT0E_ZT1GSnhlZU4.png" alt="image-20231030151731561-1717571243828-1.png" /></p>
<ol>
<li><strong>实现信息隐藏</strong>：类的实现细节被隐藏在私有的实现类中，头文件只需要包含必要的接口声明。</li>
<li><strong>减少编译依赖</strong>：用户只需要包含头文件，不需要关心实现细节，减少了编译时的依赖。</li>
<li><strong>编译时间优化</strong>：修改实现文件不需要重新编译头文件的包含者，只需要重新链接库文件。</li>
<li><strong>库的平滑升级</strong>：只要接口不变，用户可以无缝替换库文件，实现库的平滑升级。</li>
</ol>
<h2 id="单例对象自动释放"><a class="anchor" href="#单例对象自动释放">#</a> 单例对象自动释放</h2>
<p>在讨论类与对象的章节时，我们深入了解了单例模式的实现。在标准的单例模式中，一个名为  <code>_pInstance</code>  的静态指针用来保存单例对象的实例。通常，这个单例对象需要程序员手动调用一个  <code>destroy</code>  函数来释放。</p>
<p>然而，在实际的开发环境中，我们更倾向于单例对象能够自动释放，以减少内存泄漏的风险。为了检测内存泄漏，开发者通常会使用像 Valgrind 这样的工具。如果单例对象没有被正确释放，Valgrind 可能会将其误报为内存泄漏，这就需要程序员额外去验证和处理，增加了工作负担。</p>
<p>那么，如何确保单例对象能够自动释放呢？</p>
<p>当我们考虑自动释放时，自然就会想到析构函数。析构函数会在对象生命周期结束时自动被调用，我们可以利用这一点来实现单例对象的自动释放。</p>
<h3 id="方式一利用对象生命周期管理单例资源"><a class="anchor" href="#方式一利用对象生命周期管理单例资源">#</a> 方式一：利用对象生命周期管理单例资源</h3>
<p>在单例模式中，确保单例对象能够自动释放的一种方法是利用另一个对象的生命周期来管理单例资源。这可以通过在析构函数中释放单例对象来实现，从而确保当管理对象被销毁时，单例对象也会被自动释放。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VjM2xmN09ERUdoQ25sQVFYUjFMdVNJQklHQmNXMm1Fekk0U0hYZXZoZVJGUUE_ZT1KTXRDRkw.png" alt="image-20231030155337808.png" /></p>
<ol>
<li><strong>析构函数自动调用</strong>：通过在管理对象的析构函数中释放单例对象，可以确保单例对象的生命周期与该管理对象的生命周期绑定。</li>
<li><strong>避免手动释放</strong>：如果同时手动调用单例类的  <code>destroy</code>  函数，可能会导致重复释放（double free）问题。因此，可以去掉  <code>destroy</code>  函数，完全依赖自动释放机制。</li>
<li><strong>避免多个管理对象</strong>：不应让多个管理对象同时托管同一个单例对象，以防止释放逻辑的混乱。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">AutoRelease</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">AutoRelease</span><span class="token punctuation">(</span>Singleton <span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_p</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"AutoRelease(Singleton*)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token operator">~</span><span class="token function">AutoRelease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~AutoRelease()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">delete</span> _p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      _p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  Singleton <span class="token operator">*</span> _p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span> <span class="token function">test0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  AutoRelease <span class="token function">ar</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这个例子中， <code>AutoRelease</code>  对象在构造时接收一个  <code>Singleton</code>  对象，并在析构时释放它。这确保了当  <code>AutoRelease</code>  对象的生命周期结束时， <code>Singleton</code>  对象也会被自动释放。</p>
<h3 id="方式二嵌套类与静态对象实现单例自动释放"><a class="anchor" href="#方式二嵌套类与静态对象实现单例自动释放">#</a> 方式二：嵌套类与静态对象实现单例自动释放</h3>
<p>在 C++ 中，通过使用嵌套类和静态对象，我们可以设计一个自动释放单例对象的机制。这种方法利用静态对象的生命周期特性，确保在程序结束时自动释放单例对象。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZemRPSlIyTUxsS2plMHBEM3FRN1RNQnE4ZkJSU0lHSnhNa3J3b3g1djFlaUE_ZT05R2ZzaWI.png" alt="image-20240705173858726.png" /></p>
<p>核心思想：</p>
<ul>
<li><strong>嵌套类</strong>：定义一个嵌套类  <code>AutoRelease</code> ，其作用是管理单例对象的生命周期。</li>
<li><strong>静态对象</strong>：在程序的全局静态区域创建  <code>AutoRelease</code>  类的静态实例。这样，当程序结束时， <code>AutoRelease</code>  对象会被销毁，自动调用其析构函数。</li>
</ul>
<p>实现步骤：</p>
<ol>
<li><strong>定义单例类</strong>：包含一个嵌套的  <code>AutoRelease</code>  类。</li>
<li><strong>定义静态成员</strong>：在单例类中定义一个静态指针  <code>_pInstance</code>  指向单例对象，以及一个静态  <code>AutoRelease</code>  对象  <code>_ar</code> 。</li>
<li><strong>实现自动释放</strong>：在  <code>AutoRelease</code>  的析构函数中释放  <code>_pInstance</code> 。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pInstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      _pInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Singleton destroyed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_ix</pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_iy</pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    _ix <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    _iy <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">static</span> Singleton <span class="token operator">*</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AutoRelease</span> _ar<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">AutoRelease</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>   <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token operator">~</span><span class="token function">AutoRelease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>_pInstance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token keyword">delete</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        _pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"AutoRelease destroyed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment">// 初始化静态成员</span></pre></td></tr><tr><td data-num="44"></td><td><pre>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>_pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>Singleton<span class="token double-colon punctuation">::</span>AutoRelease Singleton<span class="token double-colon punctuation">::</span>_ar<span class="token punctuation">;</span></pre></td></tr></table></figure><p>程序结束时的自动销毁过程：</p>
<ol>
<li><strong>程序结束</strong>：程序运行结束，开始销毁全局静态对象。</li>
<li><strong>销毁  <code>AutoRelease</code>  对象</strong>：全局静态区域的  <code>Singleton::_ar</code>  对象被销毁。</li>
<li><strong>调用析构函数</strong>： <code>Singleton::_ar</code>  的析构函数被调用，释放  <code>Singleton::_pInstance</code> 。</li>
<li><strong>释放单例对象</strong>： <code>_pInstance</code>  指向的单例对象被释放。</li>
</ol>
<h3 id="使用-atexit-和-destroy-实现单例自动释放"><a class="anchor" href="#使用-atexit-和-destroy-实现单例自动释放">#</a> 使用  <code>atexit</code>  和  <code>destroy</code>  实现单例自动释放</h3>
<p>在 C++ 中，确保程序退出时执行必要的清理工作，如释放资源，可以通过注册  <code>atexit</code>  函数来实现。这种方法与程序的退出方式无关，无论是通过  <code>main()</code>  结束、调用  <code>exit()</code>  还是通过异常退出，注册的函数都会被调用。</p>
<p>实现步骤：</p>
<ol>
<li><strong>注册清理函数</strong>：在获取单例对象时，使用  <code>atexit</code>  注册一个清理函数  <code>destroy</code> 。</li>
<li><strong>实现清理函数</strong>：定义  <code>destroy</code>  函数来释放单例对象。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atexit></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pInstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token function">atexit</span><span class="token punctuation">(</span>destroy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注册退出时调用的函数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      _pInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    _ix <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    _iy <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_ix</pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_iy</pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_ix</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_iy</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Singleton(int,int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Singleton()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>_pInstance<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>      <span class="token keyword">delete</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>      _pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete heap"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>_pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在多线程环境中，即使使用了  <code>atexit</code>  和  <code>destroy</code>  方法，仍然存在线程安全问题。如果多个线程同时访问  <code>getInstance</code>  函数，可能会创建多个单例对象，从而导致内存泄漏。</p>
<ol>
<li><strong>使用饿汉式初始化</strong>：在程序启动时立即创建单例对象，确保  <code>getInstance</code>  函数的第一次调用是在程序启动时。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 初始化代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    _ix <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    _iy <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_ix</pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_iy</pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token comment">// 饿汉式初始化</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    _pInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">atexit</span><span class="token punctuation">(</span>destroy<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>_pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// 在程序启动时调用</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="2">
<li><strong>将  <code>destroy</code>  函数私有化</strong>：防止在多线程环境中手动调用  <code>destroy</code>  函数导致  <code>_pInstance</code>  变为空指针。</li>
</ol>
<h3 id="方式四结合-atexit-和-pthread_once-实现线程安全单例"><a class="anchor" href="#方式四结合-atexit-和-pthread_once-实现线程安全单例">#</a> 方式四：结合  <code>atexit</code>  和  <code>pthread_once</code>  实现线程安全单例</h3>
<p>在 Linux 平台上，为了确保在多线程环境中单例对象的创建是线程安全的，我们可以使用  <code>pthread_once</code>  函数。 <code>pthread_once</code>  保证初始化代码只执行一次，无论多少次调用  <code>getInstance</code>  方法。</p>
<p><code>pthread_once</code>  是 POSIX 线程库（pthreads）中的一个函数，用于确保在多线程程序中某个初始化例程只执行一次。这在初始化全局变量或静态变量时非常有用，特别是当这些变量可能会被多个线程访问时。</p>
<p>函数原型：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">pthread_once</span><span class="token punctuation">(</span><span class="token class-name">pthread_once_t</span> <span class="token operator">*</span>once_control<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>init_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>参数：</p>
<ul>
<li><code>once_control</code> ：一个指向  <code>pthread_once_t</code>  类型的变量的指针，这个变量用于记录初始化例程是否已经被执行过。必须由调用线程初始化为  <code>PTHREAD_ONCE_INIT</code> 。</li>
<li><code>init_routine</code> ：一个函数指针，指向实际执行初始化工作的函数。这个函数不接受任何参数，并且没有返回值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回  <code>0</code>  表示成功。</li>
<li>返回  <code>EAGAIN</code>  表示系统资源不足，无法完成请求。</li>
<li>返回  <code>ENOMEM</code>  表示内存分配失败。</li>
<li>返回  <code>EINVAL</code>  表示  <code>once_control</code>  不是一个有效的初始化过的  <code>pthread_once_t</code>  对象。</li>
</ul>
<p>用法：</p>
<ol>
<li>
<p><strong>初始化</strong>：在程序中定义一个  <code>pthread_once_t</code>  类型的变量，并将其初始化为  <code>PTHREAD_ONCE_INIT</code> 。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">pthread_once_t</span> once_control <span class="token operator">=</span> PTHREAD_ONCE_INIT<span class="token punctuation">;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>定义初始化函数</strong>：定义一个执行初始化工作的函数。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">init_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 初始化代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>调用  <code>pthread_once</code> </strong>：在需要进行初始化的地方调用  <code>pthread_once</code>  函数。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>once_control<span class="token punctuation">,</span> init_function<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 处理错误</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
</ol>
<p>工作机制：</p>
<ul>
<li>当第一个线程调用  <code>pthread_once</code>  并且  <code>once_control</code>  变量为  <code>PTHREAD_ONCE_INIT</code>  时， <code>init_routine</code>  函数会被调用。</li>
<li>在  <code>init_routine</code>  函数执行期间， <code>once_control</code>  变量会被修改为一个非  <code>PTHREAD_ONCE_INIT</code>  的值，以防止其他线程再次执行  <code>init_routine</code> 。</li>
<li>如果  <code>init_routine</code>  函数成功执行， <code>once_control</code>  变量会保持修改后的状态。这样，后续对  <code>pthread_once</code>  的调用将直接返回，不会再次执行  <code>init_routine</code> 。</li>
</ul>
<p>注意事项：</p>
<ul>
<li><code>pthread_once</code>  只能保证  <code>init_routine</code>  函数在多线程环境中只执行一次，它不提供锁的功能。</li>
<li><code>pthread_once</code>  不适用于局部静态变量的初始化，因为局部静态变量的初始化在 C 语言中已经是线程安全的。</li>
<li><code>pthread_once</code>  通常用于全局变量或静态变量的初始化。</li>
</ul>
<p>关键点：</p>
<ol>
<li><strong> <code>pthread_once</code> </strong>：确保初始化函数只执行一次。</li>
<li><strong> <code>atexit</code> </strong>：注册一个函数，在程序退出时自动调用。</li>
</ol>
<p>实现步骤：</p>
<ol>
<li><strong>定义单例类</strong>：包含静态指针  <code>_pInstance</code>  和  <code>pthread_once_t</code>  类型的静态变量  <code>_once</code> 。</li>
<li><strong>定义初始化函数</strong>：在初始化函数中创建单例对象，并注册  <code>destroy</code>  函数。</li>
<li><strong>私有化初始化函数和销毁函数</strong>：防止手动调用造成问题。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 仍然是通过 getInstance 函数使用单例对象，但不是简单 if 判断</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 创建对象的功能交给 init_r 函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">//pthread_once 控制 init_r 只会执行一次</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">pthread_once</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_once<span class="token punctuation">,</span> init_r<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    _ix <span class="token operator">=</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    _iy <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_ix <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>_iy <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token comment">//init_t 不能被手动调用，否则会造成内存泄露</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token comment">// 绕开了 getInstance 中通过 pthread_once 进行的控制</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    _pInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">atexit</span><span class="token punctuation">(</span>destroy<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_pInstance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>      <span class="token keyword">delete</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>      _pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// C++11 default constructor</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Singleton()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>  Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre> <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="48"></td><td><pre>  <span class="token keyword">int</span> _ix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>  <span class="token keyword">int</span> _iy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> _pInstance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>  <span class="token keyword">static</span> pthread_once_t _once<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre></pre></td></tr><tr><td data-num="54"></td><td><pre>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>_pInstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>pthread_once_t Singleton<span class="token double-colon punctuation">::</span>_once <span class="token operator">=</span> PTHREAD_ONCE_INIT<span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意事项：</p>
<ol>
<li><strong>私有化初始化函数</strong>：防止手动调用  <code>init_r</code>  函数绕过  <code>pthread_once</code>  的控制，导致内存泄漏。</li>
<li><strong>私有化销毁函数</strong>：防止手动调用  <code>destroy</code>  函数导致再次调用  <code>getInstance</code>  时无法创建单例对象。</li>
</ol>
<h2 id="stdstring-的底层实现"><a class="anchor" href="#stdstring-的底层实现">#</a>  <code>std::string</code>  的底层实现</h2>
<p>当我们探讨  <code>std::string</code>  的内存占用时，我们实际上是在考察其底层实现机制。 <code>std::string</code>  对象的大小可以通过  <code>sizeof(std::string)</code>  来测量，但这个值会因不同编译器和不同版本的编译器而异。</p>
<p>历史上， <code>std::string</code>  的实现有多种方式，主要包括：</p>
<ol>
<li>
<p><strong>Eager Copy（立即复制）</strong>：在这种实现中，无论何时复制字符串，都会完整地复制其内容。这种方式简单，但在频繁复制不修改的字符串时效率不高。</p>
</li>
<li>
<p><strong>Copy-On-Write (COW，写时复制)</strong>：这种技术延迟了复制操作，直到字符串的内容需要被修改时才进行。这减少了不必要的数据复制，提高了效率。</p>
</li>
<li>
<p><strong>Short String Optimization (SSO，短字符串优化)</strong>：这是目前大多数标准库实现  <code>std::string</code>  时采用的技术。它允许短字符串直接存储在  <code>std::string</code>  对象内部，从而避免了频繁的内存分配。</p>
</li>
</ol>
<p><code>std::string</code>  的底层实现是面试中的一个常见问题。虽然现代的实现通常采用 SSO，但了解其发展过程中的不同设计思想也是非常有价值的。</p>
<p>以立即复制为例，无论什么情况下复制字符串，都会拷贝其内容，这种方式在我们之前已经讨论过。但这种方式在处理不需要修改内容的字符串时效率不高，因此后来发展出了写时复制的实现方式。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 如果 std::string 的实现采用立即复制</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>string <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> str1<span class="token punctuation">;</span> <span class="token comment">// 立即复制，str2 会重新申请空间并复制内容</span></pre></td></tr></table></figure><p>在立即复制的实现中，创建  <code>str2</code>  时会重新申请内存并复制  <code>str1</code>  的内容，这在内容不需要改变时效率较低。</p>
<p>现代  <code>std::string</code>  实现通常采用 SSO，这样在创建短字符串时可以减少内存分配的开销。但  <code>sizeof(std::string)</code>  的大小仍然取决于编译器的实现细节。</p>
<h3 id="写时复制原理探究"><a class="anchor" href="#写时复制原理探究">#</a> 写时复制原理探究</h3>
<p>写时复制是一种在对象复制时不立即复制数据，而是让多个对象共享相同的数据，直到数据需要修改时才进行复制的优化技术。</p>
<p>Q1: 何时回收堆空间的字符串内容？</p>
<p>在写时复制模式中，多个  <code>std::string</code>  对象可能指向同一块堆内存中的字符串数据。引用计数（refcount）是管理这块内存的关键机制：</p>
<ul>
<li><strong>复制操作</strong>：当一个  <code>std::string</code>  对象复制给另一个时，两者的引用计数都指向相同的字符串数据，引用计数加 1。</li>
<li><strong>销毁对象</strong>：当一个  <code>std::string</code>  对象被销毁时，引用计数减 1。</li>
<li><strong>回收内存</strong>：只有当引用计数减至 0 时，即没有对象使用该字符串数据时，堆空间上的字符串数据才会被释放。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>string <span class="token function">str2</span><span class="token punctuation">(</span><span class="token string">"hello,wuhan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>string str3 <span class="token operator">=</span> str2<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VZdVc0SjlhS1RKT2dKWElLNGVHRWJjQklMTC1fcmdmYzlVTFhZeEV6V09Oc0E_ZT1iTm1id3I.png" alt="image-20231030171818083.png" /></p>
<p>在这种情况下， <code>str2</code>  和  <code>str3</code>  共享相同的字符串数据。直到其中一个对象尝试修改字符串时，才会创建新内存空间。</p>
<p>Q2：引用计数的位置</p>
<ol>
<li>
<p><strong>普通数据成员</strong>：将引用计数作为普通成员变量会导致一个对象的改变影响其他对象，这是不合理的。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSY3BPVHQ1dTk5SWdoTWdtdDh6ZkxjQkxXNWFfU0ZPWU1WTFA2cEdJMThUSVE_ZT05YXN0Mkk.png" alt="image-20231030180507191.png" /></p>
</li>
<li>
<p><strong>静态成员</strong>：静态成员变量被类的所有对象共享，无法精确反映每个对象的引用情况。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VUVzRyLVhmcHJaQ2d0eVlINl81TjVjQnpnY0diTFlGS2FwNUpTci1MVnZMdUE_ZT1ab2NpaEk.png" alt="image-20231030180549996.png" /></p>
</li>
<li>
<p><strong>堆空间</strong>：将引用计数存储在堆空间中是可行的，并且可以进一步优化。</p>
<ul>
<li>
<p><strong>优化方案</strong>：将引用计数和字符串内容保存在一起，通常引用计数保存在字符串内容的前面，这样可以方便地访问和更新计数。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VUMVpZWlFEMDVsTHBONmVPSElPbkdJQndBR1NMdThRQ19LUU9GcXRwelZNOFE_ZT02eWJFZmc.png" alt="image-20231030180607030.png" /></p>
</li>
</ul>
</li>
</ol>
<p><strong>合并分配</strong>：将引用计数和字符串内容合并到一个分配块中，这样只需要一次  <code>new</code>  表达式即可分配两者所需的内存。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VYRlhaa3Z4czNKR3RqOHhZN0xtQ1E0QmZDOTNFck1jRklDRWtOX3JLR3ZWX1E_ZT1nc2w3b2g.png" alt="image-20231030180657333.png" /></p>
<p>复制和赋值操作</p>
<ul>
<li><strong>复制操作</strong>：复制构造函数通过增加引用计数来共享相同的字符串数据。</li>
<li><strong>赋值操作</strong>：赋值操作需要先减少原对象字符串的引用计数（如果计数减至 0，则释放内存），然后将对象的指针指向新字符串的内存，并增加新内存的引用计数。
<ul>
<li>原本空间的引用计数 - 1，引用计数减到 0，才真正回收堆空间</li>
<li>让自己的指针指向新的空间，并将新空间的引用计数 +1</li>
</ul>
</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VWUDNBYmszSnhCQmtjbzNCc1ZfZVdVQmFsR3QzZWl6dlczb3h6NHZoMzRYbmc_ZT1DT3BnS3Y.png" alt="image-20231030180747854.png" /></p>
<h3 id="写时复制的实现"><a class="anchor" href="#写时复制的实现">#</a> 写时复制的实现</h3>
<p>实现一个支持写时复制的字符串类是一个深入理解 COW 机制的好方法。我们将重点关注赋值运算符和下标访问运算符的实现，因为它们是 COW 实现中最关键的部分。</p>
<h4 id="赋值运算符的实现"><a class="anchor" href="#赋值运算符的实现">#</a> 赋值运算符的实现</h4>
<p>赋值运算符需要特别考虑何时复制共享的数据。如果两个字符串对象共享相同的数据，赋值操作可能导致需要独立拥有一份数据副本。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VSOVdxUEp6T09kTWo0N1VleUhMVy1zQmxKU2NTY0Z5MGxKdHQ5VlZuRkNBb0E_ZT1wYjk3djU.png" alt="image-20240430175542299.png" /></p>
<p><strong>实现细节</strong>：</p>
<ul>
<li>当字符串对象进行复制操作时，引用计数增加。</li>
<li>当字符串对象被销毁时，引用计数减少。</li>
<li>只有当引用计数减为 0 时，才真正回收堆空间上的字符串。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>CowString <span class="token operator">&amp;</span> CowString<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CowString <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 自赋值的判断</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试回收空间</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    _pstr <span class="token operator">=</span> rhs<span class="token punctuation">.</span>_pstr<span class="token punctuation">;</span> <span class="token comment">// 修改指向</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">increaseRefcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增加新空间的引用计数</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 返回本对象</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="下标访问运算符的实现"><a class="anchor" href="#下标访问运算符的实现">#</a> 下标访问运算符的实现</h4>
<p>下标访问运算符不能简单地返回对应位置的字符，因为它需要区分读操作和写操作。</p>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VkRDEwd3pnbkYxRHYxSklBT01Xb1FFQlhkbE1VQWJCb3R6TXZkMjNzNFA1Nmc_ZT1POFpWaUg.png" alt="image-20240430175822276.png" /></p>
<p><strong>实现细节</strong>：</p>
<ul>
<li>对于读操作，直接返回字符。</li>
<li>对于写操作，需要创建一个新的数据副本以进行修改。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CharProxy</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token function">CharProxy</span><span class="token punctuation">(</span>CowString<span class="token operator">&amp;</span> self<span class="token punctuation">,</span> size_t idx<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_str</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_index</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 重载输出流运算符</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">friend</span> ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> CharProxy<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    os <span class="token operator">&lt;&lt;</span> rhs<span class="token punctuation">.</span>_pstr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> os<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 重载赋值运算符</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  CharProxy<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    _self<span class="token punctuation">.</span><span class="token function">writeChar</span><span class="token punctuation">(</span>_index<span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token comment">// 类型转换函数，用于读操作</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">operator</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> _str<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>_idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  CowString <span class="token operator">&amp;</span> _self<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  size_t _idx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>CharProxy <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">CharProxy</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="遗留问题"><a class="anchor" href="#遗留问题">#</a> 遗留问题</h4>
<p>如果  <code>str1</code>  和  <code>str3</code>  共享同一块内存空间存储字符串内容，我们需要确保写操作不会影响读操作。</p>
<p><strong>问题描述</strong>：</p>
<ul>
<li>读操作（如  <code>cout &lt;&lt; str1[0] &lt;&lt; endl;</code> ）可以直接进行，无需复制或更改引用计数。</li>
<li>写操作（如  <code>str1[0] = 'H';</code> ）需要让  <code>str1</code>  申请新的空间进行修改，以保证不影响  <code>str3</code>  的内容。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>创建一个内部类  <code>CharProxy</code> ，让  <code>CowString</code>  的  <code>operator[]</code>  函数返回这个新类型的对象。</li>
<li>在  <code>CharProxy</code>  类中重载  <code>&lt;&lt;</code>  和  <code>=</code>  运算符，以便区分读操作和写操作。</li>
</ul>
<p><img loading="lazy" data-src="https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy9iZGU1MWU2MjVlZjhmY2M1L0VhaG9vdUV0aWlWQ2tiNzJIOFgwNlNvQk9PR1VHR3JMcnN6S0JfZU9Fbkx1WEE_ZT1yS1lnTjM.png" alt="image-20240502095411828.png" /><br />
)</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 读操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 直接读取字符</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 写操作</span></pre></td></tr><tr><td data-num="5"></td><td><pre>str1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'H'</span><span class="token punctuation">;</span> <span class="token comment">// 触发写时复制，创建新空间进行修改</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CowString</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">class</span> <span class="token class-name">CharProxy</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">CharProxy</span><span class="token punctuation">(</span>CowString <span class="token operator">&amp;</span> self<span class="token punctuation">,</span>size_t idx<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token operator">:</span> <span class="token function">_self</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">,</span> <span class="token function">_idx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">char</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 初步的模拟，完善的代码还需要加上判断</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    CharProxy <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> CharProxy <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      _self<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>_idx<span class="token punctuation">]</span> <span class="token operator">=</span> rhs<span class="token punctuation">.</span>_self<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>rhs<span class="token punctuation">.</span>_idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">operator</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">return</span> _self<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>_idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span> os<span class="token punctuation">,</span><span class="token keyword">const</span> CharProxy <span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    CowString <span class="token operator">&amp;</span> _self<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    size_t _idx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//str1 [0] 返回一个 CharProxy 对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 能够利用的材料只有 str1 和 下标</span></pre></td></tr><tr><td data-num="3"></td><td><pre>CowString<span class="token double-colon punctuation">::</span>CharProxy CowString<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t idx<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">CharProxy</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">char</span> CowString<span class="token double-colon punctuation">::</span>CharProxy<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>_idx <span class="token operator">&lt;</span> _self<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>_self<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      _self<span class="token punctuation">.</span><span class="token function">decreaseRefcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原本空间的引用计数 -1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">char</span> <span class="token operator">*</span> temp <span class="token operator">=</span> _self<span class="token punctuation">.</span><span class="token function">malloc</span><span class="token punctuation">(</span>_self<span class="token punctuation">.</span>_pstr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 深拷贝</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token function">strcpy</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span>_self<span class="token punctuation">.</span>_pstr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      _self<span class="token punctuation">.</span>_pstr <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token comment">// 改变指向</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      _self<span class="token punctuation">.</span><span class="token function">initRefcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化新空间的引用计数</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    _self<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>_idx<span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span> <span class="token comment">// 完成赋值操作</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> _self<span class="token punctuation">.</span>_pstr<span class="token punctuation">[</span>_idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">char</span> nullchar <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> nullchar<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>总结：当运算符需要处理自定义类型对象时，先看一看这个自定义类型有没有相应的运算符重载函数，如果有，那么这个运算符就可以处理这个自定义类型对象；</p>
<p>如果没有运算符重载，就无法直接处理，需要进行转换。先看看这个自定义类型中有没有类型转换函数，转换成一个该运算符可以直接处理的类型的数据。如果没有类型转换函数，会再看看有没有隐式转换的途径。（一般，大多数情况谨慎使用隐式转换）</p>
<h3 id="短字符串优化sso"><a class="anchor" href="#短字符串优化sso">#</a> 短字符串优化（SSO）</h3>
<p>短字符串优化（Short String Optimization, SSO）是现代 C++ 标准库实现  <code>std::string</code>  类时采用的一种技术。这种技术可以减少小字符串的内存开销和提高其性能。</p>
<p>核心思想：</p>
<ul>
<li><strong>小字符串</strong>：当字符串的长度小于或等于一个特定值（通常为 15 或更多，取决于实现）时，字符串数据直接存储在  <code>std::string</code>  对象内部的字符数组中。</li>
<li><strong>大字符串</strong>：当字符串长度超过这个特定值时，内部的指针指向堆上分配的内存区域，用于存储字符串数据。</li>
</ul>
<p>实现的好处：</p>
<ul>
<li><strong>减少内存开销</strong>：对于短字符串，避免了额外的堆内存分配，因为数据直接存储在  <code>std::string</code>  对象内部。</li>
<li><strong>提高效率</strong>：拷贝短字符串时，只需拷贝对象内部的字符数组，而不需要进行堆内存的分配和释放。</li>
</ul>
<h3 id="fbstring"><a class="anchor" href="#fbstring">#</a> fbstring</h3>
<p>Facebook 提出的策略是一种折衷方案，结合了 Eager Copy、Copy-On-Write (COW) 和 Short String Optimization (SSO) 这三种技术的优点，以适应不同长度的字符串。这种策略在 Facebook 的开源库 folly 中实现为 fbstring 类。</p>
<ol>
<li>
<p><strong>短字符串优化（SSO）</strong>：</p>
<ul>
<li>对于非常短的字符串（长度 0 到 22 个字符），使用 SSO。这是因为短字符串在实际应用中非常常见，使用 SSO 可以避免频繁的内存分配和释放，从而提高性能。</li>
<li>在这个长度范围内，字符串直接存储在 fbstring 对象内部的字符数组中，无需动态分配内存。</li>
</ul>
</li>
<li>
<p><strong>立即复制（Eager Copy）</strong>：</p>
<ul>
<li>对于中等长度的字符串（23 到 255 个字符），使用 Eager Copy 策略。这是因为中等长度的字符串复制成本相对较低，且预测复制次数较少，因此直接复制是可行的。</li>
<li>这种策略下，fbstring 对象包含一个指向堆上动态分配的字符串数据的指针，以及表示字符串大小和容量的字段。</li>
</ul>
</li>
<li>
<p><strong>写时复制（COW）</strong>：</p>
<ul>
<li>对于长字符串（超过 255 个字符），使用 COW 策略。这是因为长字符串的复制成本很高，使用 COW 可以避免不必要的数据复制，直到字符串内容实际被修改时才进行复制。</li>
<li>在这种策略下，fbstring 对象包含一个指向堆上的字符串数据和引用计数的指针，这样可以确保多个 fbstring 对象可以共享相同的字符串数据，直到其中一个对象修改字符串时才进行复制。</li>
</ul>
</li>
</ol>
<p>内存布局：</p>
<p>每个 fbstring 对象占用的内存大小固定为 24 字节，具体布局如下：</p>
<ol>
<li>
<p><strong>短字符串（SSO）</strong>：</p>
<ul>
<li>23 字节用于存储字符串数据（包括空字符 '\0'）。</li>
<li>1 字节用于存储字符串的长度。</li>
</ul>
</li>
<li>
<p><strong>中等长度字符串（Eager Copy）</strong>：</p>
<ul>
<li>8 字节用于存储指向字符串数据的指针。</li>
<li>8 字节用于存储字符串的长度。</li>
<li>8 字节用于存储字符串的容量。</li>
</ul>
</li>
<li>
<p><strong>长字符串（COW）</strong>：</p>
<ul>
<li>8 字节用于存储指向字符串数据和引用计数的指针。</li>
<li>8 字节用于存储字符串的长度。</li>
<li>8 字节用于存储字符串的容量。</li>
</ul>
</li>
</ol>
<div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i>C++</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-12-15 17:42:17" itemprop="dateModified" datetime="2024-12-15T17:42:17+08:00">2024-12-15</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>樱小路七叶<i class="ic i-at"><em>@</em></i>Nana7ha's Café Stella</li><li class="link"><strong>本文链接：</strong><a href="http://cwlrin.github.io/c-cpp/cpp-base/C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" title="C++ 运算符重载">http://cwlrin.github.io/c-cpp/cpp-base/C++ 运算符重载/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/c-cpp/cpp-base/C++%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="prev" itemprop="url" title="C++ 输入输出流" style="background-image: linear-gradient(to bottom right, #8980dd, #b9aaf1);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>C++ 基础</span><h3>C++ 输入输出流</h3></a></div><div class="item right"><a href="/c-cpp/cpp-base/C++%20%E5%85%B3%E8%81%94%E6%80%A7%E5%AE%B9%E5%99%A8/" rel="next" itemprop="url" title="C++ 关联性容器" style="background-image: linear-gradient(to bottom right, #a590de, #ececfa);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>C++ 基础</span><h3>C++ 关联性容器</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.</span> <span class="toc-text"> 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 普通函数形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 成员函数形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text"> 友元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text"> 友元的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text"> 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text"> 运算符重载的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text"> 运算符重载的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text"> 运算符重载的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-2"><span class="toc-number">2.4.</span> <span class="toc-text">  +  运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 友元函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 普通函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 成员函数实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-3"><span class="toc-number">2.5.</span> <span class="toc-text">  +&#x3D;  运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.6.</span> <span class="toc-text"> 重载形式的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-4"><span class="toc-number">2.7.</span> <span class="toc-text">  ++  运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-5"><span class="toc-number">2.8.</span> <span class="toc-text">  []  运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.9.</span> <span class="toc-text"> 输入输出流运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.9.1.</span> <span class="toc-text"> 输出流运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.9.2.</span> <span class="toc-text"> 输入流运算符重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.10.</span> <span class="toc-text"> 成员访问运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.10.1.</span> <span class="toc-text"> 两层结构下的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.10.2.</span> <span class="toc-text"> 三层结构下的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">2.10.3.</span> <span class="toc-text"> 内存分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BD%93"><span class="toc-number">2.11.</span> <span class="toc-text"> 可调用实体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text"> 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.1.</span> <span class="toc-text"> 函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text"> 成员函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text"> 空指针的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text"> 类型转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%90%91%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.</span> <span class="toc-text"> 由其他类型向自定义类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%90%91%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text"> 由自定义类型向其他类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%90%91%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 自定义类型向内置类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 自定义类型之间的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 转换的优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text"> C++ 运算符优先级排序与结合性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text"> 嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text"> 嵌套类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">6.2.</span> <span class="toc-text"> 嵌套类结构的访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%B1%BB%E5%AF%B9%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 外部类对内部类的成员进行访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 内部类对外部类的成员进行访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">6.2.3.</span> <span class="toc-text"> 内部类相当于外部类的友元类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pimpl-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text"> pimpl 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pimpl-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.3.1.</span> <span class="toc-text"> Pimpl 模式的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pimpl-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.3.2.</span> <span class="toc-text"> Pimpl 模式的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE"><span class="toc-number">7.</span> <span class="toc-text"> 单例对象自动释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E5%88%A9%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%8D%95%E4%BE%8B%E8%B5%84%E6%BA%90"><span class="toc-number">7.1.</span> <span class="toc-text"> 方式一：利用对象生命周期管理单例资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%B5%8C%E5%A5%97%E7%B1%BB%E4%B8%8E%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE"><span class="toc-number">7.2.</span> <span class="toc-text"> 方式二：嵌套类与静态对象实现单例自动释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-atexit-%E5%92%8C-destroy-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE"><span class="toc-number">7.3.</span> <span class="toc-text"> 使用  atexit  和  destroy  实现单例自动释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B%E7%BB%93%E5%90%88-atexit-%E5%92%8C-pthread_once-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8D%95%E4%BE%8B"><span class="toc-number">7.4.</span> <span class="toc-text"> 方式四：结合  atexit  和  pthread_once  实现线程安全单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stdstring-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.</span> <span class="toc-text">  std::string  的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6"><span class="toc-number">8.1.</span> <span class="toc-text"> 写时复制原理探究</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.</span> <span class="toc-text"> 写时复制的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 赋值运算符的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.2.</span> <span class="toc-text"> 下标访问运算符的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.3.</span> <span class="toc-text"> 遗留问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96sso"><span class="toc-number">8.3.</span> <span class="toc-text"> 短字符串优化（SSO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fbstring"><span class="toc-number">8.4.</span> <span class="toc-text"> fbstring</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/c-cpp/cpp-base/%E4%BB%8E%20C%20%E5%88%B0%20C++/" rel="bookmark" title="从 C 到 C++">从 C 到 C++</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" rel="bookmark" title="C++ 类和对象">C++ 类和对象</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="bookmark" title="C++ 输入输出流">C++ 输入输出流</a></li><li  class="active"><a href="/c-cpp/cpp-base/C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" rel="bookmark" title="C++ 运算符重载">C++ 运算符重载</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E5%85%B3%E8%81%94%E6%80%A7%E5%AE%B9%E5%99%A8/" rel="bookmark" title="C++ 关联性容器">C++ 关联性容器</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%BB%A7%E6%89%BF/" rel="bookmark" title="C++ 继承">C++ 继承</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E5%A4%9A%E6%80%81/" rel="bookmark" title="C++ 多态">C++ 多态</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E6%A8%A1%E6%9D%BF/" rel="bookmark" title="C++ 模板">C++ 模板</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" rel="bookmark" title="C++ 移动语义">C++ 移动语义</a></li><li ><a href="/c-cpp/cpp-base/C++%20%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" rel="bookmark" title="C++ 资源管理">C++ 资源管理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="樱小路七叶" src="/assets/avatar.jpg"/><p class="name" itemprop="name">樱小路七叶</p><div class="description" itemprop="description">技术与美日新月异</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">97</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/cwlrin" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;cwlrin"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/ying-xiao-lu-qi-ye" class="item zhihu" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ying-xiao-lu-qi-ye"><i class="ic i-zhihu"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=411590211" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;411590211"><i class="ic i-cloud-music"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/8013992" class="item bilibili" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;8013992"><i class="ic i-bilibili"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/c-cpp/cpp-base/C++%20%E5%85%B3%E8%81%94%E6%80%A7%E5%AE%B9%E5%99%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/c-cpp/cpp-base/C++%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">樱小路七叶 @ 七葉の喫茶ステラ</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.5m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">22:37</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `c-cpp/cpp-base/C++ 运算符重载/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.14" type="module" fetchpriority="high" defer></script></body></html>